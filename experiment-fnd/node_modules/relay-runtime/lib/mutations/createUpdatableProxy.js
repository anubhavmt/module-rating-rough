/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));

var _require = require('../store/RelayStoreUtils'),
    getArgumentValues = _require.getArgumentValues;

var nonUpdatableKeys = ['id', '__id', '__typename', 'js'];

function createUpdatableProxy(updatableProxyRootRecord, variables, selections, recordSourceProxy) {
  var mutableUpdatableProxy = {};
  updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy);

  if (process.env.NODE_ENV !== "production") {
    Object.freeze(mutableUpdatableProxy);
  } // unless ReaderSelection carries more type information, we will never be able
  // to flowtype mutableUpdatableProxy without a type assertion.
  // $FlowFixMe[unclear-type]


  return mutableUpdatableProxy;
}

function updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy) {
  var _selection$alias3;

  var _iterator = (0, _createForOfIteratorHelper2["default"])(selections),
      _step;

  try {
    var _loop = function _loop() {
      var selection = _step.value;

      switch (selection.kind) {
        case 'LinkedField':
          if (selection.plural) {
            Object.defineProperty(mutableUpdatableProxy, (_selection$alias = selection.alias) !== null && _selection$alias !== void 0 ? _selection$alias : selection.name, {
              // $FlowFixMe[incompatible-call] these getters and setters have different types on purpose
              get: createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy),
              set: createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
            });
          } else {
            Object.defineProperty(mutableUpdatableProxy, (_selection$alias2 = selection.alias) !== null && _selection$alias2 !== void 0 ? _selection$alias2 : selection.name, {
              get: createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy),
              set: createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
            });
          }

          break;

        case 'ScalarField':
          var scalarFieldName = (_selection$alias3 = selection.alias) !== null && _selection$alias3 !== void 0 ? _selection$alias3 : selection.name;
          Object.defineProperty(mutableUpdatableProxy, scalarFieldName, {
            get: function get() {
              var _selection$args;

              var newVariables = getArgumentValues((_selection$args = selection.args) !== null && _selection$args !== void 0 ? _selection$args : [], variables); // Flow incorrect assumes that the return value for the get method must match
              // the set parameter.

              return updatableProxyRootRecord.getValue(selection.name, newVariables // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type
              );
            },
            set: nonUpdatableKeys.includes(selection.name) ? undefined : // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type
            function (newValue) {
              var _selection$args2;

              var newVariables = getArgumentValues((_selection$args2 = selection.args) !== null && _selection$args2 !== void 0 ? _selection$args2 : [], variables);
              updatableProxyRootRecord.setValue(newValue, selection.name, newVariables);
            }
          });
          break;

        case 'InlineFragment':
          if (updatableProxyRootRecord.getType() === selection.type) {
            updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy);
          }

          break;

        case 'ClientExtension':
          updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy);
          break;

        case 'FragmentSpread':
          // Explicitly ignore
          break;

        default:
          throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _selection$alias;

      var _selection$alias2;

      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
  return function set(newValue) {
    var _selection$args3;

    var newVariables = getArgumentValues((_selection$args3 = selection.args) !== null && _selection$args3 !== void 0 ? _selection$args3 : [], variables);

    if (newValue == null) {
      throw new Error('Do not assign null to plural linked fields; assign an empty array instead.');
    } else {
      var recordProxies = newValue.map(function (item) {
        if (item == null) {
          throw new Error('When assigning an array of items, none of the items should be null or undefined.');
        }

        var __id = item.__id;

        if (__id == null) {
          throw new Error('The __id field must be present on each item passed to the setter. This indicates a bug in Relay.');
        }

        var newValueRecord = recordSourceProxy.get(__id);

        if (newValueRecord == null) {
          throw new Error("Did not find item with data id ".concat(__id, " in the store."));
        }

        return newValueRecord;
      });
      updatableProxyRootRecord.setLinkedRecords(recordProxies, selection.name, newVariables);
    }
  };
}

function createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
  return function set(newValue) {
    var _selection$args4;

    var newVariables = getArgumentValues((_selection$args4 = selection.args) !== null && _selection$args4 !== void 0 ? _selection$args4 : [], variables);

    if (newValue == null) {
      updatableProxyRootRecord.setValue(newValue, selection.name, newVariables);
    } else {
      var __id = newValue.__id;

      if (__id == null) {
        throw new Error('The __id field must be present on the argument. This indicates a bug in Relay.');
      }

      var newValueRecord = recordSourceProxy.get(__id);

      if (newValueRecord == null) {
        throw new Error("Did not find item with data id ".concat(__id, " in the store."));
      }

      updatableProxyRootRecord.setLinkedRecord(newValueRecord, selection.name, newVariables);
    }
  };
}

function createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
  return function () {
    var _selection$args5;

    var newVariables = getArgumentValues((_selection$args5 = selection.args) !== null && _selection$args5 !== void 0 ? _selection$args5 : [], variables);
    var linkedRecords = updatableProxyRootRecord.getLinkedRecords(selection.name, newVariables);

    if (linkedRecords != null) {
      return linkedRecords.map(function (linkedRecord) {
        if (linkedRecord != null) {
          var updatableProxy = {};
          updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy);

          if (process.env.NODE_ENV !== "production") {
            Object.freeze(updatableProxy);
          } // Flow incorrect assumes that the return value for the get method must match
          // the set parameter.
          // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type


          return updatableProxy;
        } else {
          return linkedRecord;
        } // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type

      });
    } else {
      return linkedRecords;
    }
  };
}

function createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
  return function () {
    var _selection$args6;

    var newVariables = getArgumentValues((_selection$args6 = selection.args) !== null && _selection$args6 !== void 0 ? _selection$args6 : [], variables);
    var linkedRecord = updatableProxyRootRecord.getLinkedRecord(selection.name, newVariables);

    if (linkedRecord != null) {
      var updatableProxy = {};
      updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy);

      if (process.env.NODE_ENV !== "production") {
        Object.freeze(updatableProxy);
      } // Flow incorrect assumes that the return value for the get method must match
      // the set parameter.
      // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type


      return updatableProxy;
    } else {
      return linkedRecord;
    }
  };
}

module.exports = {
  createUpdatableProxy: createUpdatableProxy
};