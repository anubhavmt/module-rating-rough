/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _require = require('../query/GraphQLTag'),
    getFragment = _require.getFragment;

var _require2 = require('./RelayModernSelector'),
    getSelector = _require2.getSelector;

var invariant = require('invariant'); // When we call the user-supplied resolver function, it will in turn call
// `readFragment`, but that's a global function -- it needs information
// about what resolver is being executed, which is supplied by putting the
// info on this stack before we call the resolver function.


var contextStack = [];

function withResolverContext(context, cb) {
  contextStack.push(context);

  try {
    return cb();
  } finally {
    contextStack.pop();
  }
} // NOTE: these declarations are copied from 'useFragment'; it would be good
// to figure out how to share the same type signature between the two functions.
// The declarations ensure that the type of the returned data is:
//   - non-nullable if the provided ref type is non-nullable
//   - nullable if the provided ref type is nullable
//   - array of non-nullable if the provided ref type is an array of
//     non-nullable refs
//   - array of nullable if the provided ref type is an array of nullable refs


function readFragment(fragmentInput, fragmentKey) {
  if (!contextStack.length) {
    throw new Error('readFragment should be called only from within a Relay Resolver function.');
  }

  var context = contextStack[contextStack.length - 1];
  var fragmentNode = getFragment(fragmentInput);
  var fragmentSelector = getSelector(fragmentNode, fragmentKey);
  !(fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, "Expected a selector for the fragment of the resolver ".concat(fragmentNode.name, ", but got null.")) : invariant(false) : void 0;
  !(fragmentSelector.kind === 'SingularReaderSelector') ? process.env.NODE_ENV !== "production" ? invariant(false, "Expected a singular reader selector for the fragment of the resolver ".concat(fragmentNode.name, ", but it was plural.")) : invariant(false) : void 0;

  var _context$getDataForRe = context.getDataForResolverFragment(fragmentSelector, fragmentKey),
      data = _context$getDataForRe.data,
      isMissingData = _context$getDataForRe.isMissingData;

  if (isMissingData) {
    throw RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL;
  }

  return data;
}

var RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL = {};
module.exports = {
  readFragment: readFragment,
  withResolverContext: withResolverContext,
  RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL: RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL
};