/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));

var recycleNodesInto = require('../../util/recycleNodesInto');

var _require = require('../../util/RelayConcreteNode'),
    RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;

var _require2 = require('../ClientID'),
    generateClientID = _require2.generateClientID,
    generateClientObjectClientID = _require2.generateClientObjectClientID;

var RelayModernRecord = require('../RelayModernRecord');

var RelayRecordSource = require('../RelayRecordSource');

var _require3 = require('../RelayStoreUtils'),
    RELAY_RESOLVER_ERROR_KEY = _require3.RELAY_RESOLVER_ERROR_KEY,
    RELAY_RESOLVER_INVALIDATION_KEY = _require3.RELAY_RESOLVER_INVALIDATION_KEY,
    RELAY_RESOLVER_SNAPSHOT_KEY = _require3.RELAY_RESOLVER_SNAPSHOT_KEY,
    RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY,
    getStorageKey = _require3.getStorageKey;

var LiveResolverStore = require('./LiveResolverStore');

var _require4 = require('./LiveResolverSuspenseSentinel'),
    isSuspenseSentinel = _require4.isSuspenseSentinel;

var invariant = require('invariant');

var warning = require("fbjs/lib/warning"); // When this experiment gets promoted to stable, these keys will move into
// `RelayStoreUtils`.


var RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = '__resolverLieStateSubscription';
var RELAY_RESOLVER_LIVE_STATE_VALUE = '__resolverLiveStateValue';
var RELAY_RESOLVER_LIVE_STATE_DIRTY = '__resolverLiveStateDirty';
var RELAY_RESOLVER_RECORD_TYPENAME = '__RELAY_RESOLVER__';
/**
 * An experimental fork of store/ResolverCache.js intended to let us experiment
 * with Live Resolvers.
 */

function addDependencyEdge(edges, from, to) {
  var set = edges.get(from);

  if (!set) {
    set = new Set();
    edges.set(from, set);
  }

  set.add(to);
}

var LiveResolverCache = /*#__PURE__*/function () {
  function LiveResolverCache(getRecordSource, store) {
    this._resolverIDToRecordIDs = new Map();
    this._recordIDToResolverIDs = new Map();
    this._getRecordSource = getRecordSource;
    this._store = store;
  }

  var _proto = LiveResolverCache.prototype;

  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {
    var recordSource = this._getRecordSource();

    var recordID = RelayModernRecord.getDataID(record);
    var storageKey = getStorageKey(field, variables);
    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);

    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {
      var _linkedID, _evaluationResult$sna;

      // Cache miss; evaluate the selector and store the result in a new record:
      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);
      linkedRecord = RelayModernRecord.create(linkedID, RELAY_RESOLVER_RECORD_TYPENAME);
      var evaluationResult = evaluate();

      if (field.kind === RELAY_LIVE_RESOLVER) {
        if (evaluationResult.resolverResult !== undefined) {
          if (process.env.NODE_ENV !== "production") {
            !isLiveStateValue(evaluationResult.resolverResult) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected a @live Relay Resolver to return a value that implements LiveState.') : invariant(false) : void 0;
          }

          var liveState = // $FlowFixMe[incompatible-type] - casting mixed
          evaluationResult.resolverResult;

          this._setLiveStateValue(linkedRecord, linkedID, liveState);
        }
      } else {
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);
      }

      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);
      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);
      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:

      var nextRecord = RelayModernRecord.clone(record);
      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);
      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:

      var resolverID = evaluationResult.resolverID;
      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);
      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);
      var seenRecordIds = (_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.seenRecords;

      if (seenRecordIds != null) {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(seenRecordIds),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var seenRecordID = _step.value;
            addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    } else if (field.kind === RELAY_LIVE_RESOLVER && RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY)) {
      var _linkedID2;

      // If this is an Live Resolver, we might have a cache hit (the
      // fragment data hasn't changed since we last evaluated the resolver),
      // but it might still be "dirty" (the live state changed and we need
      // to call `.read()` again).
      linkedID = (_linkedID2 = linkedID) !== null && _linkedID2 !== void 0 ? _linkedID2 : generateClientID(recordID, storageKey);
      linkedRecord = RelayModernRecord.clone(linkedRecord); // $FlowFixMe[incompatible-type] - casting mixed

      var _liveState = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE); // Set the new value for this and future reads.


      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, _liveState.read()); // Mark the resolver as clean again.

      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
      recordSource.set(linkedID, linkedRecord);
    } // $FlowFixMe[incompatible-type] - will always be empty


    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY]; // $FlowFixMe[incompatible-type] - casting mixed

    var snapshot = linkedRecord[RELAY_RESOLVER_SNAPSHOT_KEY]; // $FlowFixMe[incompatible-type] - casting mixed

    var error = linkedRecord[RELAY_RESOLVER_ERROR_KEY];
    var suspenseID = null;

    if (isSuspenseSentinel(answer)) {
      var _linkedID3;

      suspenseID = (_linkedID3 = linkedID) !== null && _linkedID3 !== void 0 ? _linkedID3 : generateClientID(recordID, storageKey);
    }

    return [answer, linkedID, error, snapshot, suspenseID];
  };

  _proto.getLiveResolverPromise = function getLiveResolverPromise(liveStateID) {
    var recordSource = this._getRecordSource();

    var liveStateRecord = recordSource.get(liveStateID);
    !(liveStateRecord != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected to find record for live resolver.') : invariant(false) : void 0; // $FlowFixMe[incompatible-type] - casting mixed

    var liveState = RelayModernRecord.getValue(liveStateRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
    return new Promise(function (resolve) {
      var unsubscribe = liveState.subscribe(function () {
        unsubscribe();
        resolve();
      });
    });
  } // Register a new Live State object in the store, subscribing to future
  // updates.
  ;

  _proto._setLiveStateValue = function _setLiveStateValue(linkedRecord, linkedID, liveState) {
    // If there's an existing subscription, unsubscribe.
    // $FlowFixMe[incompatible-type] - casting mixed
    var previousUnsubscribe = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);

    if (previousUnsubscribe != null) {
      previousUnsubscribe();
    } // Subscribe to future values
    // Note: We subscribe before reading, since subscribing could potentially
    // trigger a synchronous update. By reading second way we will always
    // observe the new value, without needing to double render.


    var handler = this._makeLiveStateHandler(linkedID);

    var unsubscribe = liveState.subscribe(handler); // Store the live state value for future re-reads.

    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE, liveState); // Store the current value, for this read, and future cached reads.

    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, liveState.read()); // Mark the field as clean.

    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false); // Store our our unsubscribe function for future cleanup.

    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, unsubscribe);
  } // Create a callback to handle notifications from the live source that the
  // value may have changed.
  ;

  _proto._makeLiveStateHandler = function _makeLiveStateHandler(linkedID) {
    var _this = this;

    return function () {
      var currentSource = _this._getRecordSource();

      var currentRecord = currentSource.get(linkedID);

      if (!currentRecord) {
        // If there is no record yet, it means the subscribe function fired an
        // update synchronously on subscribe (before we even created the record).
        // In this case we can safely ignore this update, since we will be
        // reading the new value when we create the record.
        return;
      }

      var nextSource = RelayRecordSource.create();
      var nextRecord = RelayModernRecord.clone(currentRecord); // Mark the field as dirty. The next time it's read, we will call
      // `LiveState.read()`.

      RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, true);
      nextSource.set(linkedID, nextRecord);

      _this._store.publish(nextSource); // In the future, this notify might be defferred if we are within a
      // transaction.


      _this._store.notify();
    };
  };

  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {
    var recordSource = this._getRecordSource();

    var visited = new Set();
    var recordsToVisit = Array.from(updatedDataIDs);

    while (recordsToVisit.length) {
      var recordID = recordsToVisit.pop();
      updatedDataIDs.add(recordID);

      var fragmentSet = this._recordIDToResolverIDs.get(recordID);

      if (fragmentSet == null) {
        continue;
      }

      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(fragmentSet),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var fragment = _step2.value;

          if (!visited.has(fragment)) {
            var recordSet = this._resolverIDToRecordIDs.get(fragment);

            if (recordSet == null) {
              continue;
            }

            var _iterator3 = (0, _createForOfIteratorHelper2["default"])(recordSet),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var anotherRecordID = _step3.value;

                this._markInvalidatedResolverRecord(anotherRecordID, recordSource);

                if (!visited.has(anotherRecordID)) {
                  recordsToVisit.push(anotherRecordID);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  };

  _proto._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource) // Written to
  {
    var record = recordSource.get(dataID);

    if (!record) {
      process.env.NODE_ENV !== "production" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;
      return;
    }

    var nextRecord = RelayModernRecord.clone(record);
    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);
    recordSource.set(dataID, nextRecord);
  };

  _proto._isInvalid = function _isInvalid(record, getDataForResolverFragment) {
    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {
      return false;
    } // $FlowFixMe[incompatible-type] - storing values in records is not typed


    var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);
    var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;
    var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;

    if (originalInputs == null || readerSelector == null) {
      process.env.NODE_ENV !== "production" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;
      return true;
    }

    var _getDataForResolverFr = getDataForResolverFragment(readerSelector),
        latestValues = _getDataForResolverFr.data;

    var recycled = recycleNodesInto(originalInputs, latestValues);

    if (recycled !== originalInputs) {
      return true;
    }

    return false;
  } // If a given record does not exist, creates an empty record consisting of
  // just an `id` field, along with a namespaced `__id` field and insert it into
  // the store.
  ;

  _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
    var key = generateClientObjectClientID(typeName, id);

    var recordSource = this._getRecordSource();

    if (!recordSource.has(key)) {
      var newRecord = RelayModernRecord.create(key, typeName);
      RelayModernRecord.setValue(newRecord, 'id', id);
      recordSource.set(key, newRecord);
    }

    return key;
  } // Given the set of possible invalidated DataID
  // (Example may be: records from the reverted optimistic update)
  // this method will remove resolver records from the store,
  // which will force a reader to re-evaluate the value of this field.
  ;

  _proto.invalidateResolverRecords = function invalidateResolverRecords(invalidatedDataIDs) {
    if (invalidatedDataIDs.size === 0) {
      return;
    }

    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var dataID = _step4.value;

        var record = this._getRecordSource().get(dataID);

        if (record != null && RelayModernRecord.getType(record) === RELAY_RESOLVER_RECORD_TYPENAME) {
          this._getRecordSource()["delete"](dataID);
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  };

  return LiveResolverCache;
}(); // Validate that a value is live state


function isLiveStateValue(v) {
  return v != null && typeof v === 'object' && typeof v.read === 'function' && typeof v.subscribe === 'function';
}

module.exports = {
  LiveResolverCache: LiveResolverCache
};