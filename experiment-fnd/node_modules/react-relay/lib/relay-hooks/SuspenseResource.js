/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var invariant = require('invariant');

var TEMPORARY_RETAIN_DURATION_MS = 5 * 60 * 1000;
/**
 * Allows you to retain a resource as part of a component lifecycle accounting
 * for Suspense. You temporarily retain the resource during render, then
 * permanently retain it during commit and release it during unmount.
 */

var SuspenseResource = /*#__PURE__*/function () {
  function SuspenseResource(retain) {
    var _this = this;

    (0, _defineProperty2["default"])(this, "_retainCount", 0);
    (0, _defineProperty2["default"])(this, "_retainDisposable", null);
    (0, _defineProperty2["default"])(this, "_releaseTemporaryRetain", null);

    this._retain = function (environment) {
      _this._retainCount++;

      if (_this._retainCount === 1) {
        _this._retainDisposable = retain(environment);
      }

      return {
        dispose: function dispose() {
          _this._retainCount = Math.max(0, _this._retainCount - 1);

          if (_this._retainCount === 0) {
            !(_this._retainDisposable != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + "If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;

            _this._retainDisposable.dispose();

            _this._retainDisposable = null;
          }
        }
      };
    };
  }

  var _proto = SuspenseResource.prototype;

  _proto.temporaryRetain = function temporaryRetain(environment) {
    var _this2 = this;

    var _this$_releaseTempora;

    // If we're executing in a server environment, there's no need
    // to create temporary retains, since the component will never commit.
    if (environment.isServer()) {
      return {
        dispose: function dispose() {}
      };
    } // temporaryRetain is called during the render phase. However,
    // given that we can't tell if this render will eventually commit or not,
    // we create a timer to autodispose of this retain in case the associated
    // component never commits.
    // If the component /does/ commit, permanentRetain will clear this timeout
    // and permanently retain the data.


    var retention = this._retain(environment);

    var releaseQueryTimeout = null;

    var releaseTemporaryRetain = function releaseTemporaryRetain() {
      clearTimeout(releaseQueryTimeout);
      releaseQueryTimeout = null;
      _this2._releaseTemporaryRetain = null;
      retention.dispose();
    };

    releaseQueryTimeout = setTimeout(releaseTemporaryRetain, TEMPORARY_RETAIN_DURATION_MS); // NOTE: Since temporaryRetain can be called multiple times, we release
    // the previous temporary retain after we re-establish a new one, since
    // we only ever need a single temporary retain until the permanent retain is
    // established.
    // temporaryRetain may be called multiple times by React during the render
    // phase, as well as multiple times by other query components that are
    // rendering the same query/variables.

    (_this$_releaseTempora = this._releaseTemporaryRetain) === null || _this$_releaseTempora === void 0 ? void 0 : _this$_releaseTempora.call(this);
    this._releaseTemporaryRetain = releaseTemporaryRetain;
    return {
      dispose: function dispose() {
        var _this$_releaseTempora2;

        (_this$_releaseTempora2 = _this2._releaseTemporaryRetain) === null || _this$_releaseTempora2 === void 0 ? void 0 : _this$_releaseTempora2.call(_this2);
      }
    };
  };

  _proto.permanentRetain = function permanentRetain(environment) {
    var disposable = this._retain(environment);

    this.releaseTemporaryRetain();
    return disposable;
  };

  _proto.releaseTemporaryRetain = function releaseTemporaryRetain() {
    var _this$_releaseTempora3;

    (_this$_releaseTempora3 = this._releaseTemporaryRetain) === null || _this$_releaseTempora3 === void 0 ? void 0 : _this$_releaseTempora3.call(this);
    this._releaseTemporaryRetain = null;
  };

  _proto.getRetainCount = function getRetainCount() {
    return this._retainCount;
  };

  return SuspenseResource;
}();

module.exports = SuspenseResource;