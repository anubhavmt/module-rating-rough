/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var useRelayEnvironment = require('../useRelayEnvironment');

var getQueryResultOrFetchQuery = require('./getQueryResultOrFetchQuery_REACT_CACHE');

var invariant = require('invariant');

var _require = require('react'),
    useDebugValue = _require.useDebugValue,
    useEffect = _require.useEffect,
    useMemo = _require.useMemo,
    useRef = _require.useRef,
    useState = _require.useState;

var _require2 = require('relay-runtime'),
    areEqualSelectors = _require2.areEqualSelectors,
    createOperationDescriptor = _require2.createOperationDescriptor,
    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,
    getSelector = _require2.getSelector,
    getVariablesFromFragment = _require2.getVariablesFromFragment,
    handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors,
    recycleNodesInto = _require2.recycleNodesInto;

var warning = require("fbjs/lib/warning");

function isMissingData(state) {
  if (state.kind === 'bailout') {
    return false;
  } else if (state.kind === 'singular') {
    return state.snapshot.isMissingData;
  } else {
    return state.snapshots.some(function (s) {
      return s.isMissingData;
    });
  }
}

function getMissingClientEdges(state) {
  if (state.kind === 'bailout') {
    return null;
  } else if (state.kind === 'singular') {
    var _state$snapshot$missi;

    return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
  } else {
    var edges = null;

    var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var snapshot = _step.value;

        if (snapshot.missingClientEdges) {
          var _edges;

          edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];

          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var edge = _step2.value;
              edges.push(edge);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return edges;
  }
}

function handlePotentialSnapshotErrorsForState(environment, state) {
  if (state.kind === 'singular') {
    handlePotentialSnapshotErrors(environment, state.snapshot.missingRequiredFields, state.snapshot.relayResolverErrors);
  } else if (state.kind === 'plural') {
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var snapshot = _step3.value;
        handlePotentialSnapshotErrors(environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
}
/**
 * Check for updates to the store that occurred concurrently with rendering the given `state` value,
 * returning a new (updated) state if there were updates or null if there were no changes.
 */


function handleMissedUpdates(environment, state) {
  if (state.kind === 'bailout') {
    return null;
  } // FIXME this is invalid if we've just switched environments.


  var currentEpoch = environment.getStore().getEpoch();

  if (currentEpoch === state.epoch) {
    return null;
  } // The store has updated since we rendered (without us being subscribed yet),
  // so check for any updates to the data we're rendering:


  if (state.kind === 'singular') {
    var currentSnapshot = environment.lookup(state.snapshot.selector);
    var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);
    var updatedCurrentSnapshot = {
      data: updatedData,
      isMissingData: currentSnapshot.isMissingData,
      missingClientEdges: currentSnapshot.missingClientEdges,
      missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
      seenRecords: currentSnapshot.seenRecords,
      selector: currentSnapshot.selector,
      missingRequiredFields: currentSnapshot.missingRequiredFields,
      relayResolverErrors: currentSnapshot.relayResolverErrors
    };
    return [updatedData !== state.snapshot.data, {
      kind: 'singular',
      snapshot: updatedCurrentSnapshot,
      epoch: currentEpoch
    }];
  } else {
    var didMissUpdates = false;
    var currentSnapshots = [];

    for (var index = 0; index < state.snapshots.length; index++) {
      var snapshot = state.snapshots[index];

      var _currentSnapshot = environment.lookup(snapshot.selector);

      var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);

      var _updatedCurrentSnapshot = {
        data: _updatedData,
        isMissingData: _currentSnapshot.isMissingData,
        missingClientEdges: _currentSnapshot.missingClientEdges,
        missingLiveResolverFields: _currentSnapshot.missingLiveResolverFields,
        seenRecords: _currentSnapshot.seenRecords,
        selector: _currentSnapshot.selector,
        missingRequiredFields: _currentSnapshot.missingRequiredFields,
        relayResolverErrors: _currentSnapshot.relayResolverErrors
      };

      if (_updatedData !== snapshot.data) {
        didMissUpdates = true;
      }

      currentSnapshots.push(_updatedCurrentSnapshot);
    }

    !(currentSnapshots.length === state.snapshots.length) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected same number of snapshots') : invariant(false) : void 0;
    return [didMissUpdates, {
      kind: 'plural',
      snapshots: currentSnapshots,
      epoch: currentEpoch
    }];
  }
}

function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
  var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
  var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
    id: missingClientEdgeRequestInfo.clientEdgeDestinationID // TODO should be a reserved name

  });
  var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig); // This may suspend. We don't need to do anything with the results; all we're
  // doing here is started the query if needed and retaining and releasing it
  // according to the component mount/suspense cycle; getQueryResultOrFetchQuery
  // already handles this by itself.

  var _getQueryResultOrFetc = getQueryResultOrFetchQuery(environment, queryOperationDescriptor, {
    fetchPolicy: queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy
  }),
      _ = _getQueryResultOrFetc[0],
      effect = _getQueryResultOrFetc[1];

  return effect;
}

function subscribeToSnapshot(environment, state, setState) {
  if (state.kind === 'bailout') {
    return function () {};
  } else if (state.kind === 'singular') {
    var disposable = environment.subscribe(state.snapshot, function (latestSnapshot) {
      setState(function (_) {
        return {
          kind: 'singular',
          snapshot: latestSnapshot,
          epoch: environment.getStore().getEpoch()
        };
      });
    });
    return function () {
      disposable.dispose();
    };
  } else {
    var disposables = state.snapshots.map(function (snapshot, index) {
      return environment.subscribe(snapshot, function (latestSnapshot) {
        setState(function (existing) {
          !(existing.kind === 'plural') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot go from singular to plural or from bailout to plural.') : invariant(false) : void 0;
          var updated = (0, _toConsumableArray2["default"])(existing.snapshots);
          updated[index] = latestSnapshot;
          return {
            kind: 'plural',
            snapshots: updated,
            epoch: environment.getStore().getEpoch()
          };
        });
      });
    });
    return function () {
      var _iterator4 = (0, _createForOfIteratorHelper2["default"])(disposables),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var d = _step4.value;
          d.dispose();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    };
  }
}

function getFragmentState(environment, fragmentSelector, isPlural) {
  if (fragmentSelector == null) {
    return {
      kind: 'bailout'
    };
  } else if (fragmentSelector.kind === 'PluralReaderSelector') {
    return {
      kind: 'plural',
      snapshots: fragmentSelector.selectors.map(function (s) {
        return environment.lookup(s);
      }),
      epoch: environment.getStore().getEpoch()
    };
  } else {
    return {
      kind: 'singular',
      snapshot: environment.lookup(fragmentSelector),
      epoch: environment.getStore().getEpoch()
    };
  }
} // fragmentNode cannot change during the lifetime of the component, though fragmentRef may change.


function useFragmentInternal_REACT_CACHE(fragmentNode, fragmentRef, hookDisplayName, queryOptions, fragmentKey) {
  var _fragmentNode$metadat, _fragmentNode$metadat2;

  var fragmentSelector = useMemo(function () {
    return getSelector(fragmentNode, fragmentRef);
  }, [fragmentNode, fragmentRef]);
  var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;

  if (isPlural) {
    !(fragmentRef == null || Array.isArray(fragmentRef)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;
  } else {
    !!Array.isArray(fragmentRef) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;
  }

  !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), hookDisplayName) : invariant(false) : void 0;
  var environment = useRelayEnvironment();

  var _useState = useState(function () {
    return getFragmentState(environment, fragmentSelector, isPlural);
  }),
      rawState = _useState[0],
      setState = _useState[1]; // On second look this separate rawState may not be needed at all, it can just be
  // put into getFragmentState. Exception: can we properly handle the case where the
  // fragmentRef goes from non-null to null?


  var stateFromRawState = function stateFromRawState(state) {
    if (fragmentRef == null) {
      return {
        kind: 'bailout'
      };
    } else if (state.kind === 'plural' && state.snapshots.length === 0) {
      return {
        kind: 'bailout'
      };
    } else {
      return state;
    }
  };

  var state = stateFromRawState(rawState); // This copy of the state we only update when something requires us to
  // unsubscribe and re-subscribe, namely a changed environment or
  // fragment selector.

  var _useState2 = useState(state),
      rawSubscribedState = _useState2[0],
      setSubscribedState = _useState2[1]; // FIXME since this is used as an effect dependency, it needs to be memoized.


  var subscribedState = stateFromRawState(rawSubscribedState);

  var _useState3 = useState(fragmentSelector),
      previousFragmentSelector = _useState3[0],
      setPreviousFragmentSelector = _useState3[1];

  var _useState4 = useState(environment),
      previousEnvironment = _useState4[0],
      setPreviousEnvironment = _useState4[1];

  if (!areEqualSelectors(fragmentSelector, previousFragmentSelector) || environment !== previousEnvironment) {
    // Enqueue setState to record the new selector and state
    setPreviousFragmentSelector(fragmentSelector);
    setPreviousEnvironment(environment);
    var newState = stateFromRawState(getFragmentState(environment, fragmentSelector, isPlural));
    setState(newState);
    setSubscribedState(newState); // This causes us to form a new subscription
    // But render with the latest state w/o waiting for the setState. Otherwise
    // the component would render the wrong information temporarily (including
    // possibly incorrectly triggering some warnings below).

    state = newState;
    subscribedState = newState;
  } // Handle the queries for any missing client edges; this may suspend.
  // FIXME handle client edges in parallel.


  if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true) {
    // The fragment is validated to be static (in useFragment) and hasClientEdges is
    // a static (constant) property of the fragment. In practice, this effect will
    // always or never run for a given invocation of this hook.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    var effects = useMemo(function () {
      var missingClientEdges = getMissingClientEdges(state); // eslint-disable-next-line no-shadow

      var effects;

      if (missingClientEdges === null || missingClientEdges === void 0 ? void 0 : missingClientEdges.length) {
        effects = [];

        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var edge = _step5.value;
            effects.push(handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }

      return effects;
    }, [state, environment, fragmentNode, fragmentRef, queryOptions]); // See above note
    // eslint-disable-next-line react-hooks/rules-of-hooks

    useEffect(function () {
      if (effects === null || effects === void 0 ? void 0 : effects.length) {
        var cleanups = [];

        var _iterator6 = (0, _createForOfIteratorHelper2["default"])(effects),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var effect = _step6.value;
            cleanups.push(effect());
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return function () {
          var _iterator7 = (0, _createForOfIteratorHelper2["default"])(cleanups),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var cleanup = _step7.value;
              cleanup();
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        };
      }
    }, [effects]);
  }

  if (isMissingData(state)) {
    // Suspend if an active operation bears on this fragment, either the
    // fragment's owner or some other mutation etc. that could affect it:
    !(fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'refinement, see invariants above') : invariant(false) : void 0;
    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
    var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);

    if (pendingOperationsResult) {
      throw pendingOperationsResult.promise;
    } // Report required fields only if we're not suspending, since that means
    // they're missing even though we are out of options for possibly fetching them:


    handlePotentialSnapshotErrorsForState(environment, state);
  }

  useEffect(function () {
    // Check for updates since the state was rendered
    var currentState = subscribedState;
    var updates = handleMissedUpdates(environment, subscribedState);

    if (updates !== null) {
      var didMissUpdates = updates[0],
          updatedState = updates[1]; // TODO: didMissUpdates only checks for changes to snapshot data, but it's possible
      // that other snapshot properties may have changed that should also trigger a re-render,
      // such as changed missing resolver fields, missing client edges, etc.
      // A potential alternative is for handleMissedUpdates() to recycle the entire state
      // value, and return the new (recycled) state only if there was some change. In that
      // case the code would always setState if something in the snapshot changed, in addition
      // to using the latest snapshot to subscribe.

      if (didMissUpdates) {
        setState(updatedState);
      }

      currentState = updatedState;
    }

    return subscribeToSnapshot(environment, currentState, function (updater) {
      setState(function (latestState) {
        var _latestState$snapshot, _currentState$snapsho;

        if (((_latestState$snapshot = latestState.snapshot) === null || _latestState$snapshot === void 0 ? void 0 : _latestState$snapshot.selector) !== ((_currentState$snapsho = currentState.snapshot) === null || _currentState$snapsho === void 0 ? void 0 : _currentState$snapsho.selector)) {
          // Ignore updates to the subscription if it's for a previous fragment selector
          // than the latest one to be rendered. This can happen if the store is updated
          // after we re-render with a new fragmentRef prop but before the effect fires
          // in which we unsubscribe to the old one and subscribe to the new one.
          // (NB: it's safe to compare the selectors by reference because the selector
          // is recycled into new snapshots.)
          return latestState;
        } else {
          return updater(latestState);
        }
      });
    });
  }, [environment, subscribedState]);
  var data;

  if (isPlural) {
    // Plural fragments require allocating an array of the snasphot data values,
    // which has to be memoized to avoid triggering downstream re-renders.
    //
    // Note that isPlural is a constant property of the fragment and does not change
    // for a particular useFragment invocation site
    // eslint-disable-next-line react-hooks/rules-of-hooks
    data = useMemo(function () {
      if (state.kind === 'bailout') {
        return [];
      } else {
        !(state.kind === 'plural') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected state to be plural because fragment is plural') : invariant(false) : void 0;
        return state.snapshots.map(function (s) {
          return s.data;
        });
      }
    }, [state]);
  } else if (state.kind === 'bailout') {
    // This case doesn't allocate a new object so it doesn't have to be memoized
    data = null;
  } else {
    // This case doesn't allocate a new object so it doesn't have to be memoized
    !(state.kind === 'singular') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected state to be singular because fragment is singular') : invariant(false) : void 0;
    data = state.snapshot.data;
  }

  if (process.env.NODE_ENV !== "production") {
    if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function (d) {
      return d === undefined;
    }))) {
      process.env.NODE_ENV !== "production" ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : void 0;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue({
      fragment: fragmentNode.name,
      data: data
    });
  }

  return data;
}

module.exports = useFragmentInternal_REACT_CACHE;