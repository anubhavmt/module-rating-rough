/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var SuspenseResource = require('../SuspenseResource');

var _require = require('./RelayReactCache'),
    getCacheForType = _require.getCacheForType,
    getCacheSignal = _require.getCacheSignal;

var invariant = require('invariant');

var _require2 = require('relay-runtime'),
    RelayFeatureFlags = _require2.RelayFeatureFlags,
    fetchQueryInternal = _require2.__internal.fetchQuery;

var warning = require("fbjs/lib/warning");

var DEFAULT_FETCH_POLICY = 'store-or-network';

var QueryCache = /*#__PURE__*/function () {
  function QueryCache() {
    this._map = new Map();
  }

  var _proto = QueryCache.prototype;

  _proto.get = function get(environment, key) {
    var forEnv = this._map.get(environment);

    if (!forEnv) {
      forEnv = new Map();

      this._map.set(environment, forEnv);
    }

    return forEnv.get(key);
  };

  _proto.set = function set(environment, key, value) {
    var forEnv = this._map.get(environment);

    if (!forEnv) {
      forEnv = new Map();

      this._map.set(environment, forEnv);
    }

    forEnv.set(key, value);
  };

  _proto["delete"] = function _delete(environment, key) {
    var forEnv = this._map.get(environment);

    if (!forEnv) {
      return;
    }

    forEnv["delete"](key);

    if (forEnv.size === 0) {
      this._map["delete"](environment);
    }
  };

  return QueryCache;
}();

function createQueryCache() {
  return new QueryCache();
}

var noopOnCommit = function noopOnCommit() {
  return function () {
    return undefined;
  };
};

var noopPromise = new Promise(function () {});

function getQueryCacheKey(operation, fetchPolicy, renderPolicy, fetchKey) {
  return "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');
}

function constructQueryResult(operation) {
  var rootFragmentRef = {
    __id: operation.fragment.dataID,
    __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
    __fragmentOwner: operation.request
  };
  return {
    fragmentNode: operation.request.node.fragment,
    fragmentRef: rootFragmentRef
  };
}

function makeInitialCacheEntry() {
  return {
    status: 'pending',
    promise: noopPromise,
    onCommit: noopOnCommit,
    suspenseResource: null
  };
}

function getQueryResultOrFetchQuery_REACT_CACHE(environment, queryOperationDescriptor, options) {
  var _options$fetchPolicy, _options$renderPolicy;

  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : DEFAULT_FETCH_POLICY;
  var renderPolicy = (_options$renderPolicy = options === null || options === void 0 ? void 0 : options.renderPolicy) !== null && _options$renderPolicy !== void 0 ? _options$renderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
  var cache = getCacheForType(createQueryCache);
  var cacheKey = getQueryCacheKey(queryOperationDescriptor, fetchPolicy, renderPolicy, options === null || options === void 0 ? void 0 : options.fetchKey);
  var initialEntry = cache.get(environment, cacheKey);

  function updateCache(updater) {
    var currentEntry = cache.get(environment, cacheKey);

    if (!currentEntry) {
      currentEntry = makeInitialCacheEntry();
      cache.set(environment, cacheKey, currentEntry);
    } // $FlowExpectedError[prop-missing] Extra properties are passed in -- this is fine


    var newStatus = updater(currentEntry); // $FlowExpectedError[cannot-spread-inexact] Flow cannot understand that this is valid...

    cache.set(environment, cacheKey, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, currentEntry), newStatus)); // ... but we can because QueryCacheEntry spreads QueryCacheEntryStatus, so spreading
    // a QueryCacheEntryStatus into a QueryCacheEntry will result in a valid QueryCacheEntry.
  } // Initiate a query to fetch the data if needed:


  if (RelayFeatureFlags.USE_REACT_CACHE_LEGACY_TIMEOUTS) {
    var _entry;

    if (initialEntry === undefined) {
      onCacheMiss(environment, queryOperationDescriptor, fetchPolicy, renderPolicy, updateCache, options === null || options === void 0 ? void 0 : options.fetchObservable);
      var createdEntry = cache.get(environment, cacheKey);
      !(createdEntry !== undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'An entry should have been created by onCacheMiss. This is a bug in Relay.') : invariant(false) : void 0;
      _entry = createdEntry;
    } else {
      _entry = initialEntry;
    }

    if (!_entry.suspenseResource) {
      _entry.suspenseResource = new SuspenseResource(function () {
        var retention = environment.retain(queryOperationDescriptor);
        return {
          dispose: function dispose() {
            retention.dispose();
            cache["delete"](environment, cacheKey);
          }
        };
      });
    }

    if (_entry.onCommit === noopOnCommit) {
      _entry.onCommit = function () {
        !_entry.suspenseResource ? process.env.NODE_ENV !== "production" ? invariant(false, 'SuspenseResource should have been initialized. This is a bug in Relay.') : invariant(false) : void 0;

        var retention = _entry.suspenseResource.permanentRetain(environment);

        return function () {
          retention.dispose();
        };
      };
    }

    _entry.suspenseResource.temporaryRetain(environment);
  } else {
    if (initialEntry === undefined) {
      // This is the behavior we eventually want: We retain the query until the
      // presiding Cache component unmounts, at which point the AbortSignal
      // will be triggered.
      onCacheMiss(environment, queryOperationDescriptor, fetchPolicy, renderPolicy, updateCache, options === null || options === void 0 ? void 0 : options.fetchObservable); // Since this is the first time rendering, retain the query. React will
      // trigger the abort signal when this cache entry is no longer needed.

      var retention = environment.retain(queryOperationDescriptor);

      var dispose = function dispose() {
        retention.dispose();
        cache["delete"](environment, cacheKey);
      };

      var abortSignal = getCacheSignal();
      abortSignal.addEventListener('abort', dispose, {
        once: true
      });
    }
  }

  var entry = cache.get(environment, cacheKey); // could be a different entry now if synchronously resolved

  !(entry !== undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'An entry should have been created by onCacheMiss. This is a bug in Relay.') : invariant(false) : void 0;

  switch (entry.status) {
    case 'pending':
      throw entry.promise;

    case 'rejected':
      throw entry.error;

    case 'resolved':
      return [entry.result, entry.onCommit];
  }

  !false ? process.env.NODE_ENV !== "production" ? invariant(false, 'switch statement should be exhaustive') : invariant(false) : void 0;
}

function onCacheMiss(environment, operation, fetchPolicy, renderPolicy, updateCache, customFetchObservable) {
  // NB: Besides checking if the data is available, calling `check` will write missing
  // data to the store using any missing data handlers specified in the environment.
  var queryAvailability = environment.check(operation);
  var queryStatus = queryAvailability.status;
  var hasFullQuery = queryStatus === 'available';
  var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
  var shouldFetch;
  var shouldRenderNow;

  switch (fetchPolicy) {
    case 'store-only':
      {
        shouldFetch = false;
        shouldRenderNow = true;
        break;
      }

    case 'store-or-network':
      {
        shouldFetch = !hasFullQuery;
        shouldRenderNow = canPartialRender;
        break;
      }

    case 'store-and-network':
      {
        shouldFetch = true;
        shouldRenderNow = canPartialRender;
        break;
      }

    case 'network-only':
    default:
      {
        shouldFetch = true;
        shouldRenderNow = false;
        break;
      }
  }

  if (shouldFetch) {
    executeOperationAndKeepUpToDate(environment, operation, updateCache, customFetchObservable);
    updateCache(function (existing) {
      switch (existing.status) {
        case 'resolved':
          return existing;

        case 'rejected':
          return existing;

        case 'pending':
          return shouldRenderNow ? {
            status: 'resolved',
            result: constructQueryResult(operation)
          } : existing;
      }
    });
  } else {
    !shouldRenderNow ? process.env.NODE_ENV !== "production" ? invariant(false, 'Should either fetch or be willing to render. This is a bug in Relay.') : invariant(false) : void 0;
    updateCache(function (_existing) {
      return {
        status: 'resolved',
        result: constructQueryResult(operation)
      };
    });
  }
}

function executeOperationAndKeepUpToDate(environment, operation, updateCache, customFetchObservable) {
  var resolvePromise;
  var promise = new Promise(function (r) {
    resolvePromise = r;
  }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.

  promise.displayName = 'Relay(' + operation.request.node.operation.name + ')';
  var isFirstPayload = true; // FIXME We may still need to cancel network requests for live queries.

  var fetchObservable = customFetchObservable !== null && customFetchObservable !== void 0 ? customFetchObservable : fetchQueryInternal(environment, operation);
  fetchObservable.subscribe({
    start: function start(subscription) {},
    error: function error(_error) {
      if (isFirstPayload) {
        updateCache(function (_existing) {
          return {
            status: 'rejected',
            error: _error
          };
        });
      } else {
        // TODO:T92030819 Remove this warning and actually throw the network error
        // To complete this task we need to have a way of precisely tracking suspendable points
        process.env.NODE_ENV !== "production" ? warning(false, 'getQueryResultOrFetchQuery: An incremental payload for query `%` returned an error: `%`:`%`.', operation.request.node.operation.name, _error.message, _error.stack) : void 0;
      }

      resolvePromise();
      isFirstPayload = false;
    },
    next: function next(response) {
      // Stop suspending on the first payload because of streaming, defer, etc.
      updateCache(function (_existing) {
        return {
          status: 'resolved',
          result: constructQueryResult(operation)
        };
      });
      resolvePromise();
      isFirstPayload = false;
    }
  }); // If the above subscription yields a value synchronously, then one of the updates
  // above will have already happened and we'll now be in a resolved or rejected state.
  // But in the usual case, we save the promise to the entry here:

  updateCache(function (existing) {
    return existing.status === 'pending' ? {
      status: 'pending',
      promise: promise
    } : existing;
  });
}

module.exports = getQueryResultOrFetchQuery_REACT_CACHE;