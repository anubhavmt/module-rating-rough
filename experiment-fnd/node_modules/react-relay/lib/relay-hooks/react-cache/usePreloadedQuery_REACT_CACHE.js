/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _require = require('../loadQuery'),
    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;

var useMemoOperationDescriptor = require('../useMemoOperationDescriptor');

var useRelayEnvironment = require('../useRelayEnvironment');

var getQueryResultOrFetchQuery = require('./getQueryResultOrFetchQuery_REACT_CACHE');

var useFragmentInternal = require('./useFragmentInternal_REACT_CACHE');

var invariant = require('invariant');

var _require2 = require('react'),
    useDebugValue = _require2.useDebugValue,
    useEffect = _require2.useEffect;

var _require3 = require('relay-runtime'),
    _require3$__internal = _require3.__internal,
    fetchQueryDeduped = _require3$__internal.fetchQueryDeduped,
    fetchQuery = _require3$__internal.fetchQuery;

var warning = require("fbjs/lib/warning");

function usePreloadedQuery_REACT_CACHE(gqlQuery, preloadedQuery, options) {
  var environment = useRelayEnvironment();
  useTrackLoadQueryInRender();
  var fetchKey = preloadedQuery.fetchKey,
      fetchPolicy = preloadedQuery.fetchPolicy,
      source = preloadedQuery.source,
      variables = preloadedQuery.variables,
      networkCacheConfig = preloadedQuery.networkCacheConfig;
  var operation = useMemoOperationDescriptor(gqlQuery, variables, networkCacheConfig);
  var fetchObservable;

  if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {
    !(operation.request.node.params.name === preloadedQuery.name) ? process.env.NODE_ENV !== "production" ? invariant(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : invariant(false) : void 0;
    fetchObservable = fetchQueryDeduped(environment, operation.request.identifier, function () {
      if (environment === preloadedQuery.environment && source != null) {
        return environment.executeWithSource({
          operation: operation,
          source: source
        });
      } else {
        return environment.execute({
          operation: operation
        });
      }
    });
  } else {
    process.env.NODE_ENV !== "production" ? warning(preloadedQuery.isDisposed === false, 'usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. ' + 'This is because disposing the query marks it for future garbage ' + 'collection, and as such query results may no longer be present in the Relay ' + 'store. In the future, this will become a hard error.') : void 0;
    var fallbackFetchObservable = fetchQuery(environment, operation);

    if (source != null && environment === preloadedQuery.environment) {
      // If the source observable exists and the environments match, reuse
      // the source observable.
      // If the source observable happens to be empty, we need to fall back
      // and re-execute and de-dupe the query (at render time).
      fetchObservable = source.ifEmpty(fallbackFetchObservable);
    } else if (environment !== preloadedQuery.environment) {
      // If a call to loadQuery is made with a particular environment, and that
      // preloaded query is passed to usePreloadedQuery in a different environment
      // context, we cannot re-use the existing preloaded query.
      // Instead, we need to fall back and re-execute and de-dupe the query with
      // the new environment (at render time).
      // TODO T68036756 track occurences of this warning and turn it into a hard error
      process.env.NODE_ENV !== "production" ? warning(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : void 0;
      fetchObservable = fallbackFetchObservable;
    } else {
      // if (source == null)
      // If the source observable does not exist, we need to
      // fall back and re-execute and de-dupe the query (at render time).
      fetchObservable = fallbackFetchObservable;
    }
  } // Get the query going if needed -- this may suspend.


  var _getQueryResultOrFetc = getQueryResultOrFetchQuery(environment, operation, {
    fetchPolicy: fetchPolicy,
    renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy,
    fetchKey: fetchKey,
    fetchObservable: fetchObservable
  }),
      queryResult = _getQueryResultOrFetc[0],
      effect = _getQueryResultOrFetc[1];

  useEffect(effect); // Read the query's root fragment -- this may suspend.

  var fragmentNode = queryResult.fragmentNode,
      fragmentRef = queryResult.fragmentRef; // $FlowExpectedError[incompatible-return] Is this a fixable incompatible-return?

  var data = useFragmentInternal(fragmentNode, fragmentRef, 'usePreloadedQuery()', {
    fetchPolicy: fetchPolicy,
    networkCacheConfig: networkCacheConfig
  });

  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue({
      query: preloadedQuery.name,
      variables: preloadedQuery.variables,
      data: data,
      fetchKey: fetchKey,
      fetchPolicy: fetchPolicy,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    });
  }

  return data;
}

module.exports = usePreloadedQuery_REACT_CACHE;