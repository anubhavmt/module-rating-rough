/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+relay
 * 
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var ProfilerContext = require('./ProfilerContext');

var _require = require('./QueryResource'),
    getQueryCacheIdentifier = _require.getQueryCacheIdentifier,
    getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;

var useFetchTrackingRef = require('./useFetchTrackingRef');

var useFragmentNode = require('./useFragmentNode');

var useRelayEnvironment = require('./useRelayEnvironment');

var React = require('react');

var useContext = React.useContext,
    useEffect = React.useEffect,
    useState = React.useState,
    useRef = React.useRef;

function useLazyLoadQueryNode(_ref) {
  var query = _ref.query,
      componentDisplayName = _ref.componentDisplayName,
      fetchObservable = _ref.fetchObservable,
      fetchPolicy = _ref.fetchPolicy,
      fetchKey = _ref.fetchKey,
      renderPolicy = _ref.renderPolicy;
  var environment = useRelayEnvironment();
  var profilerContext = useContext(ProfilerContext);
  var QueryResource = getQueryResourceForEnvironment(environment);

  var _useState = useState(0),
      forceUpdateKey = _useState[0],
      forceUpdate = _useState[1];

  var _useFetchTrackingRef = useFetchTrackingRef(),
      startFetch = _useFetchTrackingRef.startFetch,
      completeFetch = _useFetchTrackingRef.completeFetch;

  var cacheBreaker = "".concat(forceUpdateKey, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');
  var cacheIdentifier = getQueryCacheIdentifier(environment, query, fetchPolicy, renderPolicy, cacheBreaker);
  var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function () {
    return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {
      start: startFetch,
      complete: completeFetch,
      error: completeFetch
    }, profilerContext);
  });
  var maybeHiddenOrFastRefresh = useRef(false);
  useEffect(function () {
    return function () {
      // Attempt to detect if the component was
      // hidden (by Offscreen API), or fast refresh occured;
      // Only in these situations would the effect cleanup
      // for "unmounting" run multiple times, so if
      // we are ever able to read this ref with a value
      // of true, it means that one of these cases
      // has happened.
      maybeHiddenOrFastRefresh.current = true;
    };
  }, []);
  useEffect(function () {
    if (maybeHiddenOrFastRefresh.current === true) {
      // This block only runs if the component has previously "unmounted"
      // due to it being hidden by the Offscreen API, or during fast refresh.
      // At this point, the current cached resource will have been disposed
      // by the previous cleanup, so instead of attempting to
      // do our regular commit setup, which would incorrectly attempt to
      // retain a cached query resource that was disposed, we need to force
      // a re-render so that the cache entry for this query is re-intiliazed and
      // and re-evaluated (and potentially cause a refetch).
      maybeHiddenOrFastRefresh.current = false;
      forceUpdate(function (n) {
        return n + 1;
      });
      return;
    }

    var disposable = QueryResource.retain(preparedQueryResult, profilerContext);
    return function () {
      disposable.dispose();
    }; // NOTE: We disable react-hooks-deps warning because the `environment`
    // and `cacheIdentifier` identities are capturing all information about whether
    // the effect should be re-executed and the query re-retained.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [environment, cacheIdentifier]);
  useEffect(function () {
    // Release any temporary retain that's not released. At this point, if the
    // cacheIdentifier doesn't change, the query is still permanently retained,
    // and the temporary retain is redundant.
    QueryResource.releaseTemporaryRetain(preparedQueryResult); // This effect is intended to run on every commit, thus no dependency
  });
  var fragmentNode = preparedQueryResult.fragmentNode,
      fragmentRef = preparedQueryResult.fragmentRef;

  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),
      data = _useFragmentNode.data;

  return data;
}

module.exports = useLazyLoadQueryNode;