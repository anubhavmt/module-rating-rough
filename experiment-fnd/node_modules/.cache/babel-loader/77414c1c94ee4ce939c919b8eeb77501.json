{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    fetchQuery = _require.__internal.fetchQuery,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    isRelayModernEnvironment = _require.isRelayModernEnvironment;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      // $FlowFixMe[incompatible-use]\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;\n    var request = this.execute({\n      environment: environment,\n      operation: operationOverride\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;","map":{"version":3,"names":["_interopRequireDefault","require","_defineProperty2","invariant","_require","fetchQuery","__internal","createOperationDescriptor","isRelayModernEnvironment","ReactRelayQueryFetcher","args","_cacheSelectionReference","cacheSelectionReference","_selectionReferences","selectionReferences","_proto","prototype","getSelectionReferences","lookupInStore","environment","operation","fetchPolicy","check","status","_retainCachedOperation","lookup","fragment","execute","_ref","_this","_ref$preservePrevious","preservePreviousReferences","reference","retain","error","concat","complete","disposeSelectionReferences","unsubscribe","setOnDataChange","onDataChange","_fetchOptions","process","env","NODE_ENV","onDataChangeCallbacks","push","_callOnDataChangeWhenSet","_error","_snapshot","snapshot","fetch","fetchOptions","cacheConfigOverride","_this2","fetchHasReturned","disposeRequest","oldOnDataChangeCallbacks","indexOf","operationOverride","request","node","variables","_pendingRequest","subscribe","next","_onQueryDataAvailable","notifyFirstResult","err","forEach","dispose","retry","_rootSubscription","_disposeCacheSelectionReference","r","_ref2","_this3","_this$_fetchOptions","maybeNewOnDataChangeCallbacks","Array","isArray","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/ReactRelayQueryFetcher.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    fetchQuery = _require.__internal.fetchQuery,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    isRelayModernEnvironment = _require.isRelayModernEnvironment;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      // $FlowFixMe[incompatible-use]\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;\n    var request = this.execute({\n      environment: environment,\n      operation: operationOverride\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;"],"mappings":"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"},"metadata":{},"sourceType":"script"}