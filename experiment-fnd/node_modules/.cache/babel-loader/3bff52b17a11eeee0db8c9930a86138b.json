{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    ALIASED_FRAGMENT_SPREAD = _require.ALIASED_FRAGMENT_SPREAD,\n    ALIASED_INLINE_FRAGMENT_SPREAD = _require.ALIASED_INLINE_FRAGMENT_SPREAD,\n    CLIENT_EDGE_TO_CLIENT_OBJECT = _require.CLIENT_EDGE_TO_CLIENT_OBJECT,\n    CLIENT_EDGE_TO_SERVER_OBJECT = _require.CLIENT_EDGE_TO_SERVER_OBJECT,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar ClientID = require('./ClientID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    CLIENT_EDGE_TRAVERSAL_PATH = _require3.CLIENT_EDGE_TRAVERSAL_PATH,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getModuleComponentKey = _require3.getModuleComponentKey,\n    getStorageKey = _require3.getStorageKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL = _require5.RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL,\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nvar invariant = require('invariant');\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    var _selector$clientEdgeT;\n\n    this._clientEdgeTraversalPath = RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_selector$clientEdgeT = selector.clientEdgeTraversalPath) === null || _selector$clientEdgeT === void 0 ? void 0 : _selector$clientEdgeT.length) ? (0, _toConsumableArray2[\"default\"])(selector.clientEdgeTraversalPath) : [];\n    this._missingClientEdges = [];\n    this._missingLiveResolverFields = [];\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n    this._resolverErrors = [];\n    this._fragmentName = selector.node.name;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var implementsInterface = this._implementsInterface(record, abstractKey);\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      missingClientEdges: RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._missingClientEdges.length ? this._missingClientEdges : null,\n      missingLiveResolverFields: this._missingLiveResolverFields,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields,\n      relayResolverErrors: this._resolverErrors\n    };\n  };\n\n  _proto._markDataAsMissing = function _markDataAsMissing() {\n    this._isMissingData = true;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._clientEdgeTraversalPath.length) {\n      var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1]; // Top can be null if we've traversed past a client edge into an ordinary\n      // client extension field; we never want to fetch in response to missing\n      // data off of a client extension field.\n\n      if (top !== null) {\n        this._missingClientEdges.push({\n          request: top.readerClientEdge.operation,\n          clientEdgeDestinationID: top.clientEdgeDestinationID\n        });\n      }\n    }\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._fragmentName;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [{\n              path: fieldPath,\n              owner: owner\n            }]\n          };\n        } else {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), [{\n              path: fieldPath,\n              owner: owner\n            }])\n          };\n        }\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          {\n            var fieldValue = this._readRequiredField(selection, record, data);\n\n            if (fieldValue == null) {\n              var action = selection.action;\n\n              if (action !== 'NONE') {\n                this._maybeReportUnexpectedNull(selection.path, action, record);\n              } // We are going to throw, or our parent is going to get nulled out.\n              // Either way, sibling values are going to be ignored, so we can\n              // bail early here as an optimization.\n\n\n              return false;\n            }\n\n            break;\n          }\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            if (this._readInlineFragment(selection, record, data) === false) {\n              return false;\n            }\n\n            break;\n          }\n\n        case RELAY_LIVE_RESOLVER:\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case ALIASED_FRAGMENT_SPREAD:\n          data[selection.name] = this._createAliasedFragmentSpread(selection, record);\n          break;\n\n        case ALIASED_INLINE_FRAGMENT_SPREAD:\n          {\n            var _fieldValue = this._readInlineFragment(selection.fragment, record, {});\n\n            if (_fieldValue === false) {\n              _fieldValue = null;\n            }\n\n            data[selection.name] = _fieldValue;\n            break;\n          }\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n            var alreadyMissingClientEdges = this._missingClientEdges.length;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.push(null);\n            }\n\n            var _hasExpectedData = this._traverseSelections(selection.selections, record, data); // The only case where we want to suspend due to missing data off of\n            // a client extension is if we reached a client edge that we might be\n            // able to fetch:\n\n\n            this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.pop();\n            }\n\n            if (!_hasExpectedData) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        case CLIENT_EDGE_TO_CLIENT_OBJECT:\n        case CLIENT_EDGE_TO_SERVER_OBJECT:\n          if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n            this._readClientEdge(selection, record, data);\n          } else {\n            throw new Error('Client edges are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      case RELAY_LIVE_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var _field$alias;\n\n    var fragment = field.fragment;\n    var storageKey = getStorageKey(fragment !== null && fragment !== void 0 ? fragment : field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var snapshot;\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (snapshot != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return {\n          data: snapshot.data,\n          isMissingData: snapshot.isMissingData\n        };\n      }\n\n      snapshot = read(_this._recordSource, singularReaderSelector, _this._resolverCache);\n      return {\n        data: snapshot.data,\n        isMissingData: snapshot.isMissingData\n      };\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var evaluate = function evaluate() {\n      if (fragment != null) {\n        var key = {\n          __id: RelayModernRecord.getDataID(record),\n          __fragmentOwner: _this._owner,\n          __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, fragment.args ? getArgumentValues(fragment.args, _this._variables) : {})\n        };\n        return withResolverContext(resolverContext, function () {\n          var _getResolverValue = getResolverValue(field, _this._variables, key, _this._fragmentName),\n              resolverResult = _getResolverValue[0],\n              resolverError = _getResolverValue[1];\n\n          return {\n            resolverResult: resolverResult,\n            snapshot: snapshot,\n            resolverID: resolverID,\n            error: resolverError\n          };\n        });\n      } else {\n        var _getResolverValue2 = getResolverValue(field, _this._variables, null, _this._fragmentName),\n            resolverResult = _getResolverValue2[0],\n            _resolverError = _getResolverValue2[1];\n\n        return {\n          resolverResult: resolverResult,\n          snapshot: undefined,\n          resolverID: resolverID,\n          error: _resolverError\n        };\n      }\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, evaluate, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1],\n        resolverError = _this$_resolverCache$[2],\n        cachedSnapshot = _this$_resolverCache$[3],\n        suspenseID = _this$_resolverCache$[4];\n\n    if (cachedSnapshot != null) {\n      if (cachedSnapshot.missingRequiredFields != null) {\n        this._addMissingRequiredFields(cachedSnapshot.missingRequiredFields);\n      }\n\n      if (cachedSnapshot.missingClientEdges != null) {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.missingClientEdges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var missing = _step.value;\n\n            this._missingClientEdges.push(missing);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (cachedSnapshot.missingLiveResolverFields != null) {\n        this._isMissingData = this._isMissingData || cachedSnapshot.missingLiveResolverFields.length > 0;\n\n        var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.missingLiveResolverFields),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var missingResolverField = _step2.value;\n\n            this._missingLiveResolverFields.push(missingResolverField);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.relayResolverErrors),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var error = _step3.value;\n\n          this._resolverErrors.push(error);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._isMissingData = this._isMissingData || cachedSnapshot.isMissingData;\n    }\n\n    if (resolverError) {\n      this._resolverErrors.push(resolverError);\n    }\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    if (suspenseID != null) {\n      this._isMissingData = true;\n\n      this._missingLiveResolverFields.push({\n        path: \"\".concat(this._fragmentName, \".\").concat(field.path),\n        liveStateID: suspenseID\n      });\n    }\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    data[applicationName] = result;\n    return result;\n  };\n\n  _proto._readClientEdge = function _readClientEdge(field, record, data) {\n    var _this2 = this;\n\n    var _backingField$alias;\n\n    var backingField = field.backingField; // Because ReaderClientExtension doesn't have `alias` or `name` and so I don't know\n    // how to get its applicationName or storageKey yet:\n\n    !(backingField.kind !== 'ClientExtension') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client extension client edges are not yet implemented.') : invariant(false) : void 0;\n    var applicationName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;\n    var backingFieldData = {};\n\n    this._traverseSelections([backingField], record, backingFieldData);\n\n    var destinationDataID = backingFieldData[applicationName];\n\n    if (destinationDataID == null) {\n      data[applicationName] = destinationDataID;\n      return;\n    }\n\n    if (field.linkedField.plural) {\n      !Array.isArray(destinationDataID) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected plural Client Edge Relay Resolver to return an array of IDs.') : invariant(false) : void 0;\n    } else {\n      !(typeof destinationDataID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected a Client Edge Relay Resolver to return an ID of type `string`.') : invariant(false) : void 0;\n    }\n\n    if (field.kind === CLIENT_EDGE_TO_CLIENT_OBJECT) {\n      // Client objects might use ids that are not gobally unique and instead are just\n      // local within their type. ResolverCache will derive a namespaced ID for us.\n      if (field.linkedField.plural) {\n        // $FlowFixMe[prop-missing]\n        destinationDataID = destinationDataID.map(function (id) {\n          return _this2._resolverCache.ensureClientRecord(id, field.concreteType);\n        });\n      } else {\n        destinationDataID = this._resolverCache.ensureClientRecord(destinationDataID, field.concreteType);\n      }\n\n      this._clientEdgeTraversalPath.push(null);\n    } else {\n      !!field.linkedField.plural ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected Client Edge to plural server type. This should be prevented by the compiler.') : invariant(false) : void 0; // Not wrapping the push/pop in a try/finally because if we throw, the\n      // Reader object is not usable after that anyway.\n\n      this._clientEdgeTraversalPath.push({\n        readerClientEdge: field,\n        clientEdgeDestinationID: destinationDataID\n      });\n    }\n\n    if (field.linkedField.plural) {\n      data[applicationName] = this._readLinkedIds(field.linkedField, // $FlowFixMe[incompatible-call]\n      destinationDataID, record, data);\n    } else {\n      var prevData = data[applicationName];\n      !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n      data[applicationName] = this._traverse(field.linkedField, destinationDataID, // $FlowFixMe[incompatible-variance]\n      prevData);\n    }\n\n    this._clientEdgeTraversalPath.pop();\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._markDataAsMissing();\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n    return this._readLinkedIds(field, linkedIDs, record, data);\n  };\n\n  _proto._readLinkedIds = function _readLinkedIds(field, linkedIDs, record, data) {\n    var _this3 = this;\n\n    var _field$alias6;\n\n    var applicationName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this3._markDataAsMissing();\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this3._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createAliasedFragmentSpread = function _createAliasedFragmentSpread(namedFragmentSpread, record) {\n    var abstractKey = namedFragmentSpread.abstractKey;\n\n    if (abstractKey == null) {\n      // concrete type refinement: only read data if the type exactly matches\n      var typeName = RelayModernRecord.getType(record);\n\n      if (typeName == null || typeName !== namedFragmentSpread.type) {\n        // This selection does not match the fragment spread. Do nothing.\n        return null;\n      }\n    } else {\n      var implementsInterface = this._implementsInterface(record, abstractKey);\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface, no data expected\n        return null;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._markDataAsMissing(); // Judgement call here. In some cases this will cause us to hide data that is actually valid.\n\n\n        return undefined;\n      }\n    }\n\n    var fieldData = {};\n\n    this._createFragmentPointer(namedFragmentSpread.fragment, record, fieldData);\n\n    return fieldData;\n  } // Has three possible return values:\n  // * null: The type condition did not match\n  // * undefined: We are missing data\n  // * false: The selection contained missing @required fields\n  // * data: The successfully populated SelectorData object\n  ;\n\n  _proto._readInlineFragment = function _readInlineFragment(inlineFragment, record, data) {\n    var abstractKey = inlineFragment.abstractKey;\n\n    if (abstractKey == null) {\n      // concrete type refinement: only read data if the type exactly matches\n      var typeName = RelayModernRecord.getType(record);\n\n      if (typeName == null || typeName !== inlineFragment.type) {\n        // This selection does not match the fragment spread. Do nothing.\n        return null;\n      } else {\n        var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);\n\n        if (!hasExpectedData) {\n          // Bubble up null due to a missing @required field\n          return false;\n        }\n      }\n    } else {\n      var implementsInterface = this._implementsInterface(record, abstractKey); // store flags to reset after reading\n\n\n      var parentIsMissingData = this._isMissingData;\n      var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n      this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false; // @required is not allowed within inline fragments on abstract types, so\n      // we can ignore the `hasMissingData` result of `_traverseSelections`.\n\n      this._traverseSelections(inlineFragment.selections, record, data); // Reset\n\n\n      this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface, no data expected\n        this._isMissingData = parentIsMissingData;\n        return undefined;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._markDataAsMissing();\n\n        return null;\n      }\n    }\n\n    return data;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {\n        data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2[\"default\"])(this._clientEdgeTraversalPath);\n      }\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n    var parentFragmentName = this._fragmentName;\n    this._fragmentName = fragmentSpreadOrFragment.name;\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);\n\n    this._fragmentName = parentFragmentName; // $FlowFixMe[cannot-write] - writing into read-only field\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  _proto._addMissingRequiredFields = function _addMissingRequiredFields(additional) {\n    if (this._missingRequiredFields == null) {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    if (this._missingRequiredFields.action === 'THROW') {\n      return;\n    }\n\n    if (additional.action === 'THROW') {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    this._missingRequiredFields = {\n      action: 'LOG',\n      fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), (0, _toConsumableArray2[\"default\"])(additional.fields))\n    };\n  };\n\n  _proto._implementsInterface = function _implementsInterface(record, abstractKey) {\n    var typeName = RelayModernRecord.getType(record);\n\n    var typeRecord = this._recordSource.get(generateTypeID(typeName));\n\n    var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null; // $FlowFixMe Casting record value\n\n    return implementsInterface;\n  };\n\n  return RelayReader;\n}();\n\nfunction getResolverValue(field, variables, fragmentKey, ownerName) {\n  // Support for languages that work (best) with ES6 modules, such as TypeScript.\n  var resolverFunction = typeof field.resolverModule === 'function' ? field.resolverModule : field.resolverModule[\"default\"];\n  var resolverResult = null;\n  var resolverError = null;\n\n  try {\n    var resolverFunctionArgs = [];\n\n    if (field.fragment != null) {\n      resolverFunctionArgs.push(fragmentKey);\n    }\n\n    var args = field.args ? getArgumentValues(field.args, variables) : undefined;\n    resolverFunctionArgs.push(args);\n    resolverResult = resolverFunction.apply(null, resolverFunctionArgs);\n  } catch (e) {\n    if (e === RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL) {\n      resolverResult = undefined;\n    } else {\n      var _field$path; // `field.path` is typed as nullable while we rollout compiler changes.\n\n\n      var path = (_field$path = field.path) !== null && _field$path !== void 0 ? _field$path : '[UNKNOWN]';\n      resolverError = {\n        field: {\n          path: path,\n          owner: ownerName\n        },\n        error: e\n      };\n    }\n  }\n\n  return [resolverResult, resolverError];\n}\n\nmodule.exports = {\n  read: read\n};","map":{"version":3,"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_defineProperty2","_toConsumableArray2","_require","ACTOR_CHANGE","ALIASED_FRAGMENT_SPREAD","ALIASED_INLINE_FRAGMENT_SPREAD","CLIENT_EDGE_TO_CLIENT_OBJECT","CLIENT_EDGE_TO_SERVER_OBJECT","CLIENT_EXTENSION","CONDITION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_DATA_FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","MODULE_IMPORT","RELAY_LIVE_RESOLVER","RELAY_RESOLVER","REQUIRED_FIELD","SCALAR_FIELD","STREAM","RelayFeatureFlags","ClientID","RelayModernRecord","_require2","getReactFlightClientResponse","_require3","CLIENT_EDGE_TRAVERSAL_PATH","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","FRAGMENTS_KEY","ID_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","MODULE_COMPONENT_KEY","ROOT_ID","getArgumentValues","getModuleComponentKey","getStorageKey","_require4","NoopResolverCache","_require5","RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL","withResolverContext","_require6","generateTypeID","invariant","read","recordSource","selector","resolverCache","reader","RelayReader","_selector$clientEdgeT","_clientEdgeTraversalPath","ENABLE_CLIENT_EDGES","clientEdgeTraversalPath","length","_missingClientEdges","_missingLiveResolverFields","_isMissingData","_isWithinUnmatchedTypeRefinement","_missingRequiredFields","_owner","owner","_recordSource","_seenRecords","Set","_selector","_variables","variables","_resolverCache","_resolverErrors","_fragmentName","node","name","_proto","prototype","_this$_selector","dataID","isWithinUnmatchedTypeRefinement","abstractKey","record","get","isDataExpectedToBePresent","recordType","getType","type","implementsInterface","_implementsInterface","data","_traverse","isMissingData","missingClientEdges","missingLiveResolverFields","seenRecords","missingRequiredFields","relayResolverErrors","_markDataAsMissing","top","push","request","readerClientEdge","operation","clientEdgeDestinationID","prevData","add","undefined","hadRequiredData","_traverseSelections","selections","_getVariableValue","hasOwnProperty","process","env","NODE_ENV","_maybeReportUnexpectedNull","fieldPath","action","_this$_missingRequire","field","path","fields","concat","i","selection","kind","fieldValue","_readRequiredField","_readScalar","plural","_readPluralLink","_readLink","conditionValue","Boolean","condition","passingValue","hasExpectedData","_readInlineFragment","ENABLE_RELAY_RESOLVERS","Error","_readResolverField","_createFragmentPointer","_createAliasedFragmentSpread","_fieldValue","fragment","_readModuleImport","_createInlineDataOrResolverFragmentPointer","alreadyMissingClientEdges","_hasExpectedData","pop","_hasExpectedData2","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_readFlightField","_readActorChange","_readClientEdge","_this","_field$alias","storageKey","resolverID","generateClientID","getDataID","snapshot","getDataForResolverFragment","singularReaderSelector","resolverContext","evaluate","key","__id","__fragmentOwner","__fragments","args","_getResolverValue","getResolverValue","resolverResult","resolverError","error","_getResolverValue2","_resolverError","_this$_resolverCache$","readFromCacheOrEvaluate","result","seenRecord","cachedSnapshot","suspenseID","_addMissingRequiredFields","_iterator","_step","s","n","done","missing","value","err","e","f","_iterator2","_step2","missingResolverField","_iterator3","_step3","liveStateID","applicationName","alias","_this2","_backingField$alias","backingField","backingFieldData","destinationDataID","linkedField","Array","isArray","map","id","ensureClientRecord","concreteType","_readLinkedIds","_field$alias2","reactFlightClientResponseRecordID","getLinkedRecordID","reactFlightClientResponseRecord","clientResponse","_field$alias3","getValue","_field$alias4","linkedID","_field$alias5","externalRef","getActorLinkedRecordID","actorIdentifier","fragmentRef","fragmentSpread","__fragmentRef","__viewer","linkedIDs","getLinkedRecordIDs","_this3","_field$alias6","linkedArray","forEach","nextIndex","prevItem","moduleImport","componentKey","documentName","component","fragmentName","fragmentPropName","namedFragmentSpread","typeName","fieldData","inlineFragment","parentIsMissingData","parentIsWithinUnmatchedTypeRefinement","fragmentPointers","fragmentSpreadOrFragment","inlineData","parentFragmentName","additional","typeRecord","fragmentKey","ownerName","resolverFunction","resolverModule","resolverFunctionArgs","apply","_field$path","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/RelayReader.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    ALIASED_FRAGMENT_SPREAD = _require.ALIASED_FRAGMENT_SPREAD,\n    ALIASED_INLINE_FRAGMENT_SPREAD = _require.ALIASED_INLINE_FRAGMENT_SPREAD,\n    CLIENT_EDGE_TO_CLIENT_OBJECT = _require.CLIENT_EDGE_TO_CLIENT_OBJECT,\n    CLIENT_EDGE_TO_SERVER_OBJECT = _require.CLIENT_EDGE_TO_SERVER_OBJECT,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar ClientID = require('./ClientID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    CLIENT_EDGE_TRAVERSAL_PATH = _require3.CLIENT_EDGE_TRAVERSAL_PATH,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getModuleComponentKey = _require3.getModuleComponentKey,\n    getStorageKey = _require3.getStorageKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL = _require5.RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL,\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nvar invariant = require('invariant');\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    var _selector$clientEdgeT;\n\n    this._clientEdgeTraversalPath = RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_selector$clientEdgeT = selector.clientEdgeTraversalPath) === null || _selector$clientEdgeT === void 0 ? void 0 : _selector$clientEdgeT.length) ? (0, _toConsumableArray2[\"default\"])(selector.clientEdgeTraversalPath) : [];\n    this._missingClientEdges = [];\n    this._missingLiveResolverFields = [];\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n    this._resolverErrors = [];\n    this._fragmentName = selector.node.name;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var implementsInterface = this._implementsInterface(record, abstractKey);\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      missingClientEdges: RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._missingClientEdges.length ? this._missingClientEdges : null,\n      missingLiveResolverFields: this._missingLiveResolverFields,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields,\n      relayResolverErrors: this._resolverErrors\n    };\n  };\n\n  _proto._markDataAsMissing = function _markDataAsMissing() {\n    this._isMissingData = true;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._clientEdgeTraversalPath.length) {\n      var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1]; // Top can be null if we've traversed past a client edge into an ordinary\n      // client extension field; we never want to fetch in response to missing\n      // data off of a client extension field.\n\n      if (top !== null) {\n        this._missingClientEdges.push({\n          request: top.readerClientEdge.operation,\n          clientEdgeDestinationID: top.clientEdgeDestinationID\n        });\n      }\n    }\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._fragmentName;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [{\n              path: fieldPath,\n              owner: owner\n            }]\n          };\n        } else {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), [{\n              path: fieldPath,\n              owner: owner\n            }])\n          };\n        }\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          {\n            var fieldValue = this._readRequiredField(selection, record, data);\n\n            if (fieldValue == null) {\n              var action = selection.action;\n\n              if (action !== 'NONE') {\n                this._maybeReportUnexpectedNull(selection.path, action, record);\n              } // We are going to throw, or our parent is going to get nulled out.\n              // Either way, sibling values are going to be ignored, so we can\n              // bail early here as an optimization.\n\n\n              return false;\n            }\n\n            break;\n          }\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            if (this._readInlineFragment(selection, record, data) === false) {\n              return false;\n            }\n\n            break;\n          }\n\n        case RELAY_LIVE_RESOLVER:\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case ALIASED_FRAGMENT_SPREAD:\n          data[selection.name] = this._createAliasedFragmentSpread(selection, record);\n          break;\n\n        case ALIASED_INLINE_FRAGMENT_SPREAD:\n          {\n            var _fieldValue = this._readInlineFragment(selection.fragment, record, {});\n\n            if (_fieldValue === false) {\n              _fieldValue = null;\n            }\n\n            data[selection.name] = _fieldValue;\n            break;\n          }\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n            var alreadyMissingClientEdges = this._missingClientEdges.length;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.push(null);\n            }\n\n            var _hasExpectedData = this._traverseSelections(selection.selections, record, data); // The only case where we want to suspend due to missing data off of\n            // a client extension is if we reached a client edge that we might be\n            // able to fetch:\n\n\n            this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.pop();\n            }\n\n            if (!_hasExpectedData) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        case CLIENT_EDGE_TO_CLIENT_OBJECT:\n        case CLIENT_EDGE_TO_SERVER_OBJECT:\n          if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n            this._readClientEdge(selection, record, data);\n          } else {\n            throw new Error('Client edges are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      case RELAY_LIVE_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var _field$alias;\n\n    var fragment = field.fragment;\n    var storageKey = getStorageKey(fragment !== null && fragment !== void 0 ? fragment : field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var snapshot;\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (snapshot != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return {\n          data: snapshot.data,\n          isMissingData: snapshot.isMissingData\n        };\n      }\n\n      snapshot = read(_this._recordSource, singularReaderSelector, _this._resolverCache);\n      return {\n        data: snapshot.data,\n        isMissingData: snapshot.isMissingData\n      };\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var evaluate = function evaluate() {\n      if (fragment != null) {\n        var key = {\n          __id: RelayModernRecord.getDataID(record),\n          __fragmentOwner: _this._owner,\n          __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, fragment.args ? getArgumentValues(fragment.args, _this._variables) : {})\n        };\n        return withResolverContext(resolverContext, function () {\n          var _getResolverValue = getResolverValue(field, _this._variables, key, _this._fragmentName),\n              resolverResult = _getResolverValue[0],\n              resolverError = _getResolverValue[1];\n\n          return {\n            resolverResult: resolverResult,\n            snapshot: snapshot,\n            resolverID: resolverID,\n            error: resolverError\n          };\n        });\n      } else {\n        var _getResolverValue2 = getResolverValue(field, _this._variables, null, _this._fragmentName),\n            resolverResult = _getResolverValue2[0],\n            _resolverError = _getResolverValue2[1];\n\n        return {\n          resolverResult: resolverResult,\n          snapshot: undefined,\n          resolverID: resolverID,\n          error: _resolverError\n        };\n      }\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, evaluate, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1],\n        resolverError = _this$_resolverCache$[2],\n        cachedSnapshot = _this$_resolverCache$[3],\n        suspenseID = _this$_resolverCache$[4];\n\n    if (cachedSnapshot != null) {\n      if (cachedSnapshot.missingRequiredFields != null) {\n        this._addMissingRequiredFields(cachedSnapshot.missingRequiredFields);\n      }\n\n      if (cachedSnapshot.missingClientEdges != null) {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.missingClientEdges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var missing = _step.value;\n\n            this._missingClientEdges.push(missing);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (cachedSnapshot.missingLiveResolverFields != null) {\n        this._isMissingData = this._isMissingData || cachedSnapshot.missingLiveResolverFields.length > 0;\n\n        var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.missingLiveResolverFields),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var missingResolverField = _step2.value;\n\n            this._missingLiveResolverFields.push(missingResolverField);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(cachedSnapshot.relayResolverErrors),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var error = _step3.value;\n\n          this._resolverErrors.push(error);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._isMissingData = this._isMissingData || cachedSnapshot.isMissingData;\n    }\n\n    if (resolverError) {\n      this._resolverErrors.push(resolverError);\n    }\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    if (suspenseID != null) {\n      this._isMissingData = true;\n\n      this._missingLiveResolverFields.push({\n        path: \"\".concat(this._fragmentName, \".\").concat(field.path),\n        liveStateID: suspenseID\n      });\n    }\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    data[applicationName] = result;\n    return result;\n  };\n\n  _proto._readClientEdge = function _readClientEdge(field, record, data) {\n    var _this2 = this;\n\n    var _backingField$alias;\n\n    var backingField = field.backingField; // Because ReaderClientExtension doesn't have `alias` or `name` and so I don't know\n    // how to get its applicationName or storageKey yet:\n\n    !(backingField.kind !== 'ClientExtension') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client extension client edges are not yet implemented.') : invariant(false) : void 0;\n    var applicationName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;\n    var backingFieldData = {};\n\n    this._traverseSelections([backingField], record, backingFieldData);\n\n    var destinationDataID = backingFieldData[applicationName];\n\n    if (destinationDataID == null) {\n      data[applicationName] = destinationDataID;\n      return;\n    }\n\n    if (field.linkedField.plural) {\n      !Array.isArray(destinationDataID) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected plural Client Edge Relay Resolver to return an array of IDs.') : invariant(false) : void 0;\n    } else {\n      !(typeof destinationDataID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected a Client Edge Relay Resolver to return an ID of type `string`.') : invariant(false) : void 0;\n    }\n\n    if (field.kind === CLIENT_EDGE_TO_CLIENT_OBJECT) {\n      // Client objects might use ids that are not gobally unique and instead are just\n      // local within their type. ResolverCache will derive a namespaced ID for us.\n      if (field.linkedField.plural) {\n        // $FlowFixMe[prop-missing]\n        destinationDataID = destinationDataID.map(function (id) {\n          return _this2._resolverCache.ensureClientRecord(id, field.concreteType);\n        });\n      } else {\n        destinationDataID = this._resolverCache.ensureClientRecord(destinationDataID, field.concreteType);\n      }\n\n      this._clientEdgeTraversalPath.push(null);\n    } else {\n      !!field.linkedField.plural ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected Client Edge to plural server type. This should be prevented by the compiler.') : invariant(false) : void 0; // Not wrapping the push/pop in a try/finally because if we throw, the\n      // Reader object is not usable after that anyway.\n\n      this._clientEdgeTraversalPath.push({\n        readerClientEdge: field,\n        clientEdgeDestinationID: destinationDataID\n      });\n    }\n\n    if (field.linkedField.plural) {\n      data[applicationName] = this._readLinkedIds(field.linkedField, // $FlowFixMe[incompatible-call]\n      destinationDataID, record, data);\n    } else {\n      var prevData = data[applicationName];\n      !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n      data[applicationName] = this._traverse(field.linkedField, destinationDataID, // $FlowFixMe[incompatible-variance]\n      prevData);\n    }\n\n    this._clientEdgeTraversalPath.pop();\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._markDataAsMissing();\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n    return this._readLinkedIds(field, linkedIDs, record, data);\n  };\n\n  _proto._readLinkedIds = function _readLinkedIds(field, linkedIDs, record, data) {\n    var _this3 = this;\n\n    var _field$alias6;\n\n    var applicationName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this3._markDataAsMissing();\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this3._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createAliasedFragmentSpread = function _createAliasedFragmentSpread(namedFragmentSpread, record) {\n    var abstractKey = namedFragmentSpread.abstractKey;\n\n    if (abstractKey == null) {\n      // concrete type refinement: only read data if the type exactly matches\n      var typeName = RelayModernRecord.getType(record);\n\n      if (typeName == null || typeName !== namedFragmentSpread.type) {\n        // This selection does not match the fragment spread. Do nothing.\n        return null;\n      }\n    } else {\n      var implementsInterface = this._implementsInterface(record, abstractKey);\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface, no data expected\n        return null;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._markDataAsMissing(); // Judgement call here. In some cases this will cause us to hide data that is actually valid.\n\n\n        return undefined;\n      }\n    }\n\n    var fieldData = {};\n\n    this._createFragmentPointer(namedFragmentSpread.fragment, record, fieldData);\n\n    return fieldData;\n  } // Has three possible return values:\n  // * null: The type condition did not match\n  // * undefined: We are missing data\n  // * false: The selection contained missing @required fields\n  // * data: The successfully populated SelectorData object\n  ;\n\n  _proto._readInlineFragment = function _readInlineFragment(inlineFragment, record, data) {\n    var abstractKey = inlineFragment.abstractKey;\n\n    if (abstractKey == null) {\n      // concrete type refinement: only read data if the type exactly matches\n      var typeName = RelayModernRecord.getType(record);\n\n      if (typeName == null || typeName !== inlineFragment.type) {\n        // This selection does not match the fragment spread. Do nothing.\n        return null;\n      } else {\n        var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);\n\n        if (!hasExpectedData) {\n          // Bubble up null due to a missing @required field\n          return false;\n        }\n      }\n    } else {\n      var implementsInterface = this._implementsInterface(record, abstractKey); // store flags to reset after reading\n\n\n      var parentIsMissingData = this._isMissingData;\n      var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n      this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false; // @required is not allowed within inline fragments on abstract types, so\n      // we can ignore the `hasMissingData` result of `_traverseSelections`.\n\n      this._traverseSelections(inlineFragment.selections, record, data); // Reset\n\n\n      this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface, no data expected\n        this._isMissingData = parentIsMissingData;\n        return undefined;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._markDataAsMissing();\n\n        return null;\n      }\n    }\n\n    return data;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {\n        data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2[\"default\"])(this._clientEdgeTraversalPath);\n      }\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n    var parentFragmentName = this._fragmentName;\n    this._fragmentName = fragmentSpreadOrFragment.name;\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);\n\n    this._fragmentName = parentFragmentName; // $FlowFixMe[cannot-write] - writing into read-only field\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  _proto._addMissingRequiredFields = function _addMissingRequiredFields(additional) {\n    if (this._missingRequiredFields == null) {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    if (this._missingRequiredFields.action === 'THROW') {\n      return;\n    }\n\n    if (additional.action === 'THROW') {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    this._missingRequiredFields = {\n      action: 'LOG',\n      fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), (0, _toConsumableArray2[\"default\"])(additional.fields))\n    };\n  };\n\n  _proto._implementsInterface = function _implementsInterface(record, abstractKey) {\n    var typeName = RelayModernRecord.getType(record);\n\n    var typeRecord = this._recordSource.get(generateTypeID(typeName));\n\n    var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null; // $FlowFixMe Casting record value\n\n    return implementsInterface;\n  };\n\n  return RelayReader;\n}();\n\nfunction getResolverValue(field, variables, fragmentKey, ownerName) {\n  // Support for languages that work (best) with ES6 modules, such as TypeScript.\n  var resolverFunction = typeof field.resolverModule === 'function' ? field.resolverModule : field.resolverModule[\"default\"];\n  var resolverResult = null;\n  var resolverError = null;\n\n  try {\n    var resolverFunctionArgs = [];\n\n    if (field.fragment != null) {\n      resolverFunctionArgs.push(fragmentKey);\n    }\n\n    var args = field.args ? getArgumentValues(field.args, variables) : undefined;\n    resolverFunctionArgs.push(args);\n    resolverResult = resolverFunction.apply(null, resolverFunctionArgs);\n  } catch (e) {\n    if (e === RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL) {\n      resolverResult = undefined;\n    } else {\n      var _field$path;\n\n      // `field.path` is typed as nullable while we rollout compiler changes.\n      var path = (_field$path = field.path) !== null && _field$path !== void 0 ? _field$path : '[UNKNOWN]';\n      resolverError = {\n        field: {\n          path: path,\n          owner: ownerName\n        },\n        error: e\n      };\n    }\n  }\n\n  return [resolverResult, resolverError];\n}\n\nmodule.exports = {\n  read: read\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}