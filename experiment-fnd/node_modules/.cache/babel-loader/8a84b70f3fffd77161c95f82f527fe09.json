{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar generateID = require('../util/generateID');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar withDuration = require('../util/withDuration');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector,\n    createReaderSelector = _require3.createReaderSelector;\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar _require4 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require4.ROOT_TYPE,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    getStorageKey = _require4.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref2) {\n    var _this = this;\n\n    var actorIdentifier = _ref2.actorIdentifier,\n        getDataID = _ref2.getDataID,\n        getPublishQueue = _ref2.getPublishQueue,\n        getStore = _ref2.getStore,\n        isClientPayload = _ref2.isClientPayload,\n        operation = _ref2.operation,\n        operationExecutions = _ref2.operationExecutions,\n        operationLoader = _ref2.operationLoader,\n        operationTracker = _ref2.operationTracker,\n        optimisticConfig = _ref2.optimisticConfig,\n        _reactFlightPayloadDeserializer = _ref2.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref2.reactFlightServerErrorHandler,\n        scheduler = _ref2.scheduler,\n        shouldProcessClientComponents = _ref2.shouldProcessClientComponents,\n        sink = _ref2.sink,\n        source = _ref2.source,\n        treatMissingFieldsAsNull = _ref2.treatMissingFieldsAsNull,\n        updater = _ref2.updater,\n        log = _ref2.log;\n    (0, _defineProperty2[\"default\"])(this, \"_deserializeReactFlightPayloadWithLogging\", function (tree) {\n      var reactFlightPayloadDeserializer = _this._reactFlightPayloadDeserializer;\n      !(typeof reactFlightPayloadDeserializer === 'function') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected reactFlightPayloadDeserializer to be available when calling _deserializeReactFlightPayloadWithLogging.') : invariant(false) : void 0;\n\n      var _withDuration = withDuration(function () {\n        return reactFlightPayloadDeserializer(tree);\n      }),\n          duration = _withDuration[0],\n          result = _withDuration[1];\n\n      _this._log({\n        name: 'execute.flight.payload_deserialize',\n        executeId: _this._executeId,\n        operationName: _this._operation.request.node.params.name,\n        duration: duration\n      });\n\n      return result;\n    });\n    this._actorIdentifier = actorIdentifier;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._log = log;\n    this._executeId = generateID();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._getPublishQueue = getPublishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._getStore = getStore;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = _reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    this._retainDisposables = new Map();\n    this._seenActors = new Set();\n    this._completeFns = [];\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        var _this$_operation$requ;\n\n        _this._start(id, subscription);\n\n        _this._log({\n          name: 'execute.start',\n          executeId: _this._executeId,\n          params: _this._operation.request.node.params,\n          variables: _this._operation.request.variables,\n          cacheConfig: (_this$_operation$requ = _this._operation.request.cacheConfig) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : {}\n        });\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._getPublishQueueAndSaveActor().revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._runPublishQueue();\n    }\n\n    this._incrementalResults.clear();\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      this._asyncStoreUpdateDisposable.dispose();\n\n      this._asyncStoreUpdateDisposable = null;\n    }\n\n    this._completeFns = [];\n\n    this._completeOperationTracker();\n\n    this._disposeRetainedData();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n\n      this._log({\n        name: 'execute.complete',\n        executeId: this._executeId\n      });\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n\n    this._log({\n      name: 'execute.error',\n      executeId: this._executeId,\n      error: error\n    });\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      var _withDuration2 = withDuration(function () {\n        _this4._handleNext(response);\n\n        _this4._maybeCompleteSubscriptionOperationTracking();\n      }),\n          duration = _withDuration2[0];\n\n      _this4._log({\n        name: 'execute.next',\n        executeId: _this4._executeId,\n        response: response,\n        duration: duration\n      });\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref3) {\n          var message = _ref3.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._seenActors.clear();\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      // For subscriptions, to avoid every new payload from overwriting existing\n      // data from previous payloads, assign a unique rootID for every new\n      // non-incremental payload.\n      if (this._isSubscriptionOperation) {\n        var nextID = generateUniqueClientID();\n        this._operation = {\n          request: this._operation.request,\n          fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n          root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n        };\n      }\n\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    } // OK: run once after each new payload\n    // If we have non-incremental responses, we passing `this._operation` to\n    // the publish queue here, which will later be passed to the store (via\n    // notify) to indicate that this operation caused the store to update\n\n\n    var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses ? this._operation : undefined);\n\n    if (hasNonIncrementalResponses) {\n      if (this._incrementalPayloadsPending) {\n        this._retainData();\n      }\n    }\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        actorIdentifier: this._actorIdentifier,\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          followupPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._getPublishQueueAndSaveActor().applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._runPublishQueue();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.followupPayloads && payload.followupPayloads.length) {\n      var followupPayloads = payload.followupPayloads;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(followupPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var followupPayload = _step.value;\n\n          switch (followupPayload.kind) {\n            case 'ModuleImportPayload':\n              var operationLoader = this._expectOperationLoader();\n\n              var operation = operationLoader.get(followupPayload.operationReference);\n\n              if (operation == null) {\n                this._processAsyncOptimisticModuleImport(followupPayload);\n              } else {\n                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);\n\n                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n              }\n\n              break;\n\n            case 'ActorPayload':\n              process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : void 0;\n              break;\n\n            default:\n              followupPayload;\n              !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : invariant(false) : void 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Normalize Data for @module payload, and actor-specific payload\n   */\n  ;\n\n  _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {\n    var variables;\n\n    if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {\n      variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);\n    } else {\n      variables = followupPayload.variables;\n    }\n\n    var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);\n    return normalizeResponse({\n      data: followupPayload.data\n    }, selector, followupPayload.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: followupPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {\n    var _this7 = this;\n\n    this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._getPublishQueueAndSaveActor().applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._runPublishQueue();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        _this8._getPublishQueueAndSaveActor().revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        actorIdentifier: _this8._actorIdentifier,\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer != null ? _this8._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          followupPayloads = payload.followupPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (followupPayloads && followupPayloads.length !== 0) {\n        followupPayloads.forEach(function (followupPayload) {\n          var _followupPayload$acto;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;\n\n          _this9._processFollowupPayload(followupPayload);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          var _incrementalPlacehold;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;\n\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {\n    var _this10 = this;\n\n    switch (followupPayload.kind) {\n      case 'ModuleImportPayload':\n        var operationLoader = this._expectOperationLoader();\n\n        var node = operationLoader.get(followupPayload.operationReference);\n\n        if (node != null) {\n          // If the operation module is available synchronously, normalize the\n          // data synchronously.\n          this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));\n        } else {\n          // Otherwise load the operation module and schedule a task to normalize\n          // the data when the module is available.\n          var _id3 = this._nextSubscriptionId++;\n\n          this._pendingModulePayloadsCount++;\n\n          var decrementPendingCount = function decrementPendingCount() {\n            _this10._pendingModulePayloadsCount--;\n\n            _this10._maybeCompleteSubscriptionOperationTracking();\n          }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n          // errors thrown by the load function, which is user-defined. Guard\n          // against that with Observable.from(new Promise(<work>)).\n\n\n          var networkObservable = RelayObservable.from(new Promise(function (resolve, reject) {\n            operationLoader.load(followupPayload.operationReference).then(resolve, reject);\n          }));\n          RelayObservable.create(function (sink) {\n            var cancellationToken;\n            var subscription = networkObservable.subscribe({\n              next: function next(loadedNode) {\n                if (loadedNode != null) {\n                  var publishModuleImportPayload = function publishModuleImportPayload() {\n                    try {\n                      var operation = getOperation(loadedNode);\n                      var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;\n                      var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;\n\n                      var _withDuration3 = withDuration(function () {\n                        _this10._handleFollowupPayload(followupPayload, operation); // OK: always have to run after an async module import resolves\n                        // OK: always have to run after an async module import resolves\n\n\n                        if (shouldScheduleAsyncStoreUpdate) {\n                          _this10._scheduleAsyncStoreUpdate( // $FlowFixMe[incompatible-call] `shouldScheduleAsyncStoreUpdate` check should cover `null` case\n                          batchAsyncModuleUpdatesFN, sink.complete);\n                        } else {\n                          var updatedOwners = _this10._runPublishQueue();\n\n                          _this10._updateOperationTracker(updatedOwners);\n                        }\n                      }),\n                          duration = _withDuration3[0];\n\n                      _this10._log({\n                        name: 'execute.async.module',\n                        executeId: _this10._executeId,\n                        operationName: operation.name,\n                        duration: duration\n                      });\n\n                      if (!shouldScheduleAsyncStoreUpdate) {\n                        sink.complete();\n                      }\n                    } catch (error) {\n                      sink.error(error);\n                    }\n                  };\n\n                  var scheduler = _this10._scheduler;\n\n                  if (scheduler == null) {\n                    publishModuleImportPayload();\n                  } else {\n                    cancellationToken = scheduler.schedule(publishModuleImportPayload);\n                  }\n                } else {\n                  sink.complete();\n                }\n              },\n              error: sink.error\n            });\n            return function () {\n              subscription.unsubscribe();\n\n              if (_this10._scheduler != null && cancellationToken != null) {\n                _this10._scheduler.cancel(cancellationToken);\n              }\n            };\n          }).subscribe({\n            complete: function complete() {\n              _this10._complete(_id3);\n\n              decrementPendingCount();\n            },\n            error: function error(_error4) {\n              _this10._error(_error4);\n\n              decrementPendingCount();\n            },\n            start: function start(subscription) {\n              return _this10._start(_id3, subscription);\n            }\n          });\n        }\n\n        break;\n\n      case 'ActorPayload':\n        this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);\n\n        break;\n\n      default:\n        followupPayload;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {\n    this._handleFollowupPayload(followupPayload, normalizationNode);\n\n    this._maybeCompleteSubscriptionOperationTracking();\n  };\n\n  _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {\n    var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa; // Update the label => path => placeholder map\n\n\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var _placeholder$actorIde;\n\n    var parentID = placeholder.selector.dataID;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables,\n        actorIdentifier = placeholder.actorIdentifier;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _ref, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = (_ref = (_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs === null || prevIDs === void 0 ? void 0 : prevIDs[itemIndex]) !== null && _ref !== void 0 ? _ref : // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {\n    var _this12 = this;\n\n    this._completeFns.push(completeFn);\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      return;\n    }\n\n    this._asyncStoreUpdateDisposable = scheduleFn(function () {\n      _this12._asyncStoreUpdateDisposable = null;\n\n      var updatedOwners = _this12._runPublishQueue();\n\n      _this12._updateOperationTracker(updatedOwners);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(_this12._completeFns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var complete = _step2.value;\n          complete();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      _this12._completeFns = [];\n    });\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {\n    this._seenActors.add(this._actorIdentifier);\n\n    return this._getPublishQueue(this._actorIdentifier);\n  };\n\n  _proto._getActorsToVisit = function _getActorsToVisit() {\n    if (this._seenActors.size === 0) {\n      return new Set([this._actorIdentifier]);\n    } else {\n      return this._seenActors;\n    }\n  };\n\n  _proto._runPublishQueue = function _runPublishQueue(operation) {\n    var updatedOwners = new Set();\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _actorIdentifier = _step3.value;\n\n        var owners = this._getPublishQueue(_actorIdentifier).run(operation);\n\n        owners.forEach(function (owner) {\n          return updatedOwners.add(owner);\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return Array.from(updatedOwners);\n  };\n\n  _proto._retainData = function _retainData() {\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _actorIdentifier2 = _step4.value;\n\n        if (!this._retainDisposables.has(_actorIdentifier2)) {\n          this._retainDisposables.set(_actorIdentifier2, this._getStore(_actorIdentifier2).retain(this._operation));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  _proto._disposeRetainedData = function _disposeRetainedData() {\n    var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(this._retainDisposables.values()),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var disposable = _step5.value;\n        disposable.dispose();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    this._retainDisposables.clear();\n  };\n\n  _proto._expectOperationLoader = function _expectOperationLoader() {\n    var operationLoader = this._operationLoader;\n    !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n    return operationLoader;\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","_createForOfIteratorHelper2","_defineProperty2","_toConsumableArray2","RelayObservable","generateID","getOperation","RelayError","RelayFeatureFlags","stableCopy","withDuration","_require","generateClientID","generateUniqueClientID","_require2","getLocalVariables","RelayModernRecord","_require3","createNormalizationSelector","createReaderSelector","RelayRecordSource","RelayResponseNormalizer","_require4","ROOT_TYPE","TYPENAME_KEY","getStorageKey","invariant","warning","execute","config","Executor","_ref2","_this","actorIdentifier","getDataID","getPublishQueue","getStore","isClientPayload","operation","operationExecutions","operationLoader","operationTracker","optimisticConfig","_reactFlightPayloadDeserializer","reactFlightPayloadDeserializer","reactFlightServerErrorHandler","scheduler","shouldProcessClientComponents","sink","source","treatMissingFieldsAsNull","updater","log","tree","process","env","NODE_ENV","_withDuration","duration","result","_log","name","executeId","_executeId","operationName","_operation","request","node","params","_actorIdentifier","_getDataID","_treatMissingFieldsAsNull","_incrementalPayloadsPending","_incrementalResults","Map","_nextSubscriptionId","_operationExecutions","_operationLoader","_operationTracker","_operationUpdateEpochs","_optimisticUpdates","_pendingModulePayloadsCount","_getPublishQueue","_scheduler","_sink","_source","_state","_getStore","_subscriptions","_updater","_isClientPayload","_reactFlightServerErrorHandler","_isSubscriptionOperation","operationKind","_shouldProcessClientComponents","_retainDisposables","_seenActors","Set","_completeFns","id","subscribe","complete","_complete","error","_error2","_error","next","response","_next","start","subscription","_this$_operation$requ","_start","variables","cacheConfig","_processOptimisticResponse","data","_proto","prototype","cancel","_this2","identifier","size","forEach","sub","unsubscribe","clear","optimisticUpdates","update","_getPublishQueueAndSaveActor","revertUpdate","_runPublishQueue","_asyncStoreUpdateDisposable","dispose","_completeOperationTracker","_disposeRetainedData","_updateActiveState","activeState","set","_schedule","task","_this3","_id2","create","cancellationToken","schedule","_error3","_id","_this4","_withDuration2","_handleNext","_maybeCompleteSubscriptionOperationTracking","_handleErrorResponse","responses","_this5","results","extensions","hasOwnProperty","errors","messages","map","_ref3","message","join","stack","responseWithData","push","_handleOptimisticResponses","_response$extensions","length","some","responsePart","_responsePart$extensi","isOptimistic","Array","isArray","responsesWithData","isFinal","x","_x$extensions","is_final","_partitionGraphQLResp","partitionGraphQLResponses","nonIncrementalResponses","incrementalResponses","hasNonIncrementalResponses","nextID","fragment","owner","root","payloadFollowups","_processResponses","_processPayloadFollowups","_payloadFollowups","_processIncrementalResponses","__relay_subscription_root_id","dataID","updatedOwners","undefined","_retainData","_updateOperationTracker","_this6","payload","normalizeResponse","path","_deserializeReactFlightPayloadWithLogging","validateOptimisticResponsePayload","_processOptimisticFollowups","fieldPayloads","incrementalPlaceholders","followupPayloads","applyUpdate","_iterator","_step","s","n","done","followupPayload","value","kind","_expectOperationLoader","get","operationReference","_processAsyncOptimisticModuleImport","moduleImportOptimisticUpdates","_processOptimisticModuleImport","apply","err","e","f","_normalizeFollowupPayload","normalizationNode","argumentDefinitions","args","selector","typeName","normalizationRootNode","moduleImportPayload","modulePayload","_this7","load","then","_this$_optimisticUpda","_this8","payloadPart","relayPayload","commitPayload","payloads","_this9","_followupPayload$acto","prevActorIdentifier","_processFollowupPayload","incrementalPlaceholder","_incrementalPlacehold","_processIncrementalPlaceholder","relayPayloads","placeholder","_processDeferResponse","label","_this10","_processFollowupPayloadWithNormalizationNode","_id3","decrementPendingCount","networkObservable","from","Promise","resolve","reject","loadedNode","publishModuleImportPayload","batchAsyncModuleUpdatesFN","BATCH_ASYNC_MODULE_UPDATES_FN","shouldScheduleAsyncStoreUpdate","_withDuration3","_handleFollowupPayload","_scheduleAsyncStoreUpdate","_error4","_relayPayload$fieldPa","pathKey","String","resultForLabel","resultForPath","pendingResponses","parentID","parentRecord","parentPayloads","filter","fieldPayload","fieldID","fieldKey","nextParentRecord","nextParentPayloads","previousParentEntry","record","handlePayloads","dedupePayload","key","stableStringify","values","_this11","incrementalResponse","indexOf","_pathKey","slice","_resultForPath","_placeholder","_processStreamResponse","_placeholder$actorIde","parentEntry","_response$extensions2","handleFieldsRelayPayload","field","selections","plural","_this$_normalizeStrea","_normalizeStreamItem","itemID","itemIndex","prevIDs","storageKey","store","currentParentRecord","currentItems","getLinkedRecords","currentItem","index","nextItems","setLinkedRecords","normalizationPath","_field$alias","_field$concreteType","_ref","_this$_getDataID","responseKey","alias","getLinkedRecordIDs","finalPathEntry","parseInt","concreteType","clone","nextIDs","setLinkedRecordIDs","concat","scheduleFn","completeFn","_this12","_iterator2","_step2","add","_getActorsToVisit","_iterator3","_step3","owners","run","_iterator4","_step4","_actorIdentifier2","has","retain","_iterator5","_step5","disposable","options","_response$extensions3","normalize","_JSON$stringify","JSON","stringify","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/OperationExecutor.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar generateID = require('../util/generateID');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar withDuration = require('../util/withDuration');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector,\n    createReaderSelector = _require3.createReaderSelector;\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar _require4 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require4.ROOT_TYPE,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    getStorageKey = _require4.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref2) {\n    var _this = this;\n\n    var actorIdentifier = _ref2.actorIdentifier,\n        getDataID = _ref2.getDataID,\n        getPublishQueue = _ref2.getPublishQueue,\n        getStore = _ref2.getStore,\n        isClientPayload = _ref2.isClientPayload,\n        operation = _ref2.operation,\n        operationExecutions = _ref2.operationExecutions,\n        operationLoader = _ref2.operationLoader,\n        operationTracker = _ref2.operationTracker,\n        optimisticConfig = _ref2.optimisticConfig,\n        _reactFlightPayloadDeserializer = _ref2.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref2.reactFlightServerErrorHandler,\n        scheduler = _ref2.scheduler,\n        shouldProcessClientComponents = _ref2.shouldProcessClientComponents,\n        sink = _ref2.sink,\n        source = _ref2.source,\n        treatMissingFieldsAsNull = _ref2.treatMissingFieldsAsNull,\n        updater = _ref2.updater,\n        log = _ref2.log;\n    (0, _defineProperty2[\"default\"])(this, \"_deserializeReactFlightPayloadWithLogging\", function (tree) {\n      var reactFlightPayloadDeserializer = _this._reactFlightPayloadDeserializer;\n      !(typeof reactFlightPayloadDeserializer === 'function') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected reactFlightPayloadDeserializer to be available when calling _deserializeReactFlightPayloadWithLogging.') : invariant(false) : void 0;\n\n      var _withDuration = withDuration(function () {\n        return reactFlightPayloadDeserializer(tree);\n      }),\n          duration = _withDuration[0],\n          result = _withDuration[1];\n\n      _this._log({\n        name: 'execute.flight.payload_deserialize',\n        executeId: _this._executeId,\n        operationName: _this._operation.request.node.params.name,\n        duration: duration\n      });\n\n      return result;\n    });\n    this._actorIdentifier = actorIdentifier;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._log = log;\n    this._executeId = generateID();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._getPublishQueue = getPublishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._getStore = getStore;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = _reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    this._retainDisposables = new Map();\n    this._seenActors = new Set();\n    this._completeFns = [];\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        var _this$_operation$requ;\n\n        _this._start(id, subscription);\n\n        _this._log({\n          name: 'execute.start',\n          executeId: _this._executeId,\n          params: _this._operation.request.node.params,\n          variables: _this._operation.request.variables,\n          cacheConfig: (_this$_operation$requ = _this._operation.request.cacheConfig) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : {}\n        });\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._getPublishQueueAndSaveActor().revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._runPublishQueue();\n    }\n\n    this._incrementalResults.clear();\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      this._asyncStoreUpdateDisposable.dispose();\n\n      this._asyncStoreUpdateDisposable = null;\n    }\n\n    this._completeFns = [];\n\n    this._completeOperationTracker();\n\n    this._disposeRetainedData();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n\n      this._log({\n        name: 'execute.complete',\n        executeId: this._executeId\n      });\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n\n    this._log({\n      name: 'execute.error',\n      executeId: this._executeId,\n      error: error\n    });\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      var _withDuration2 = withDuration(function () {\n        _this4._handleNext(response);\n\n        _this4._maybeCompleteSubscriptionOperationTracking();\n      }),\n          duration = _withDuration2[0];\n\n      _this4._log({\n        name: 'execute.next',\n        executeId: _this4._executeId,\n        response: response,\n        duration: duration\n      });\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref3) {\n          var message = _ref3.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._seenActors.clear();\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      // For subscriptions, to avoid every new payload from overwriting existing\n      // data from previous payloads, assign a unique rootID for every new\n      // non-incremental payload.\n      if (this._isSubscriptionOperation) {\n        var nextID = generateUniqueClientID();\n        this._operation = {\n          request: this._operation.request,\n          fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n          root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n        };\n      }\n\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    } // OK: run once after each new payload\n    // If we have non-incremental responses, we passing `this._operation` to\n    // the publish queue here, which will later be passed to the store (via\n    // notify) to indicate that this operation caused the store to update\n\n\n    var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses ? this._operation : undefined);\n\n    if (hasNonIncrementalResponses) {\n      if (this._incrementalPayloadsPending) {\n        this._retainData();\n      }\n    }\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        actorIdentifier: this._actorIdentifier,\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          followupPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._getPublishQueueAndSaveActor().applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._runPublishQueue();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.followupPayloads && payload.followupPayloads.length) {\n      var followupPayloads = payload.followupPayloads;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(followupPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var followupPayload = _step.value;\n\n          switch (followupPayload.kind) {\n            case 'ModuleImportPayload':\n              var operationLoader = this._expectOperationLoader();\n\n              var operation = operationLoader.get(followupPayload.operationReference);\n\n              if (operation == null) {\n                this._processAsyncOptimisticModuleImport(followupPayload);\n              } else {\n                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);\n\n                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n              }\n\n              break;\n\n            case 'ActorPayload':\n              process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : void 0;\n              break;\n\n            default:\n              followupPayload;\n              !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : invariant(false) : void 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Normalize Data for @module payload, and actor-specific payload\n   */\n  ;\n\n  _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {\n    var variables;\n\n    if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {\n      variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);\n    } else {\n      variables = followupPayload.variables;\n    }\n\n    var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);\n    return normalizeResponse({\n      data: followupPayload.data\n    }, selector, followupPayload.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: followupPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {\n    var _this7 = this;\n\n    this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._getPublishQueueAndSaveActor().applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._runPublishQueue();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        _this8._getPublishQueueAndSaveActor().revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        actorIdentifier: _this8._actorIdentifier,\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer != null ? _this8._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          followupPayloads = payload.followupPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (followupPayloads && followupPayloads.length !== 0) {\n        followupPayloads.forEach(function (followupPayload) {\n          var _followupPayload$acto;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;\n\n          _this9._processFollowupPayload(followupPayload);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          var _incrementalPlacehold;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;\n\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {\n    var _this10 = this;\n\n    switch (followupPayload.kind) {\n      case 'ModuleImportPayload':\n        var operationLoader = this._expectOperationLoader();\n\n        var node = operationLoader.get(followupPayload.operationReference);\n\n        if (node != null) {\n          // If the operation module is available synchronously, normalize the\n          // data synchronously.\n          this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));\n        } else {\n          // Otherwise load the operation module and schedule a task to normalize\n          // the data when the module is available.\n          var _id3 = this._nextSubscriptionId++;\n\n          this._pendingModulePayloadsCount++;\n\n          var decrementPendingCount = function decrementPendingCount() {\n            _this10._pendingModulePayloadsCount--;\n\n            _this10._maybeCompleteSubscriptionOperationTracking();\n          }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n          // errors thrown by the load function, which is user-defined. Guard\n          // against that with Observable.from(new Promise(<work>)).\n\n\n          var networkObservable = RelayObservable.from(new Promise(function (resolve, reject) {\n            operationLoader.load(followupPayload.operationReference).then(resolve, reject);\n          }));\n          RelayObservable.create(function (sink) {\n            var cancellationToken;\n            var subscription = networkObservable.subscribe({\n              next: function next(loadedNode) {\n                if (loadedNode != null) {\n                  var publishModuleImportPayload = function publishModuleImportPayload() {\n                    try {\n                      var operation = getOperation(loadedNode);\n                      var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;\n                      var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;\n\n                      var _withDuration3 = withDuration(function () {\n                        _this10._handleFollowupPayload(followupPayload, operation); // OK: always have to run after an async module import resolves\n\n\n                        // OK: always have to run after an async module import resolves\n                        if (shouldScheduleAsyncStoreUpdate) {\n                          _this10._scheduleAsyncStoreUpdate( // $FlowFixMe[incompatible-call] `shouldScheduleAsyncStoreUpdate` check should cover `null` case\n                          batchAsyncModuleUpdatesFN, sink.complete);\n                        } else {\n                          var updatedOwners = _this10._runPublishQueue();\n\n                          _this10._updateOperationTracker(updatedOwners);\n                        }\n                      }),\n                          duration = _withDuration3[0];\n\n                      _this10._log({\n                        name: 'execute.async.module',\n                        executeId: _this10._executeId,\n                        operationName: operation.name,\n                        duration: duration\n                      });\n\n                      if (!shouldScheduleAsyncStoreUpdate) {\n                        sink.complete();\n                      }\n                    } catch (error) {\n                      sink.error(error);\n                    }\n                  };\n\n                  var scheduler = _this10._scheduler;\n\n                  if (scheduler == null) {\n                    publishModuleImportPayload();\n                  } else {\n                    cancellationToken = scheduler.schedule(publishModuleImportPayload);\n                  }\n                } else {\n                  sink.complete();\n                }\n              },\n              error: sink.error\n            });\n            return function () {\n              subscription.unsubscribe();\n\n              if (_this10._scheduler != null && cancellationToken != null) {\n                _this10._scheduler.cancel(cancellationToken);\n              }\n            };\n          }).subscribe({\n            complete: function complete() {\n              _this10._complete(_id3);\n\n              decrementPendingCount();\n            },\n            error: function error(_error4) {\n              _this10._error(_error4);\n\n              decrementPendingCount();\n            },\n            start: function start(subscription) {\n              return _this10._start(_id3, subscription);\n            }\n          });\n        }\n\n        break;\n\n      case 'ActorPayload':\n        this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);\n\n        break;\n\n      default:\n        followupPayload;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {\n    this._handleFollowupPayload(followupPayload, normalizationNode);\n\n    this._maybeCompleteSubscriptionOperationTracking();\n  };\n\n  _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {\n    var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa;\n\n    // Update the label => path => placeholder map\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var _placeholder$actorIde;\n\n    var parentID = placeholder.selector.dataID;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables,\n        actorIdentifier = placeholder.actorIdentifier;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _ref, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = (_ref = (_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs === null || prevIDs === void 0 ? void 0 : prevIDs[itemIndex]) !== null && _ref !== void 0 ? _ref : // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {\n    var _this12 = this;\n\n    this._completeFns.push(completeFn);\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      return;\n    }\n\n    this._asyncStoreUpdateDisposable = scheduleFn(function () {\n      _this12._asyncStoreUpdateDisposable = null;\n\n      var updatedOwners = _this12._runPublishQueue();\n\n      _this12._updateOperationTracker(updatedOwners);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(_this12._completeFns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var complete = _step2.value;\n          complete();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      _this12._completeFns = [];\n    });\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {\n    this._seenActors.add(this._actorIdentifier);\n\n    return this._getPublishQueue(this._actorIdentifier);\n  };\n\n  _proto._getActorsToVisit = function _getActorsToVisit() {\n    if (this._seenActors.size === 0) {\n      return new Set([this._actorIdentifier]);\n    } else {\n      return this._seenActors;\n    }\n  };\n\n  _proto._runPublishQueue = function _runPublishQueue(operation) {\n    var updatedOwners = new Set();\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _actorIdentifier = _step3.value;\n\n        var owners = this._getPublishQueue(_actorIdentifier).run(operation);\n\n        owners.forEach(function (owner) {\n          return updatedOwners.add(owner);\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return Array.from(updatedOwners);\n  };\n\n  _proto._retainData = function _retainData() {\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _actorIdentifier2 = _step4.value;\n\n        if (!this._retainDisposables.has(_actorIdentifier2)) {\n          this._retainDisposables.set(_actorIdentifier2, this._getStore(_actorIdentifier2).retain(this._operation));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  _proto._disposeRetainedData = function _disposeRetainedData() {\n    var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(this._retainDisposables.values()),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var disposable = _step5.value;\n        disposable.dispose();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    this._retainDisposables.clear();\n  };\n\n  _proto._expectOperationLoader = function _expectOperationLoader() {\n    var operationLoader = this._operationLoader;\n    !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n    return operationLoader;\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}