{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('../../store/RelayStoreUtils'),\n    getStableStorageKey = _require2.getStableStorageKey;\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      // $FlowFixMe[incompatible-type]\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Given a record ID, the key of a connection field, and optional filters used\n * to identify the connection, returns the connection ID.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<user-id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *     edges {\n *       node {\n *         id\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The ID of the `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const connectionID = ConnectionHandler.getConnectionID('<user-id>', 'FriendsFragment_friends');\n * }\n * ```\n */\n\n\nfunction getConnectionID(recordID, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  var storageKey = getStableStorageKey(handleKey, filters);\n  return generateClientID(recordID, storageKey);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n\n  if (edge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    edge.setValue(null, 'cursor');\n  }\n\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n\n  if (connectionEdge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    connectionEdge.setValue(null, 'cursor');\n  }\n\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  getConnectionID: getConnectionID,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};","map":{"version":3,"names":["_require","require","generateClientID","_require2","getStableStorageKey","getRelayHandleKey","ConnectionInterface","invariant","warning","CONNECTION","NEXT_EDGE_INDEX","update","store","payload","record","get","dataID","_ConnectionInterface$","EDGES","END_CURSOR","HAS_NEXT_PAGE","HAS_PREV_PAGE","PAGE_INFO","PAGE_INFO_TYPE","START_CURSOR","serverConnection","getLinkedRecord","fieldKey","serverPageInfo","setValue","handleKey","clientConnectionID","getDataID","clientConnectionField","clientConnection","clientPageInfo","connection","create","getType","copyFieldsFrom","serverEdges","getLinkedRecords","map","edge","buildConnectionEdge","setLinkedRecords","setLinkedRecord","_connection","_serverEdges","prevEdges","prevPageInfo","nextEdges","args","after","getValue","nodeIDs","Set","mergeEdges","process","env","NODE_ENV","before","_nodeIDs","last","startCursor","first","endCursor","getConnection","key","filters","getConnectionID","recordID","storageKey","insertEdgeAfter","newEdge","cursor","_ConnectionInterface$2","CURSOR","edges","concat","foundCursor","ii","length","push","edgeCursor","createEdge","node","edgeType","_ConnectionInterface$3","NODE","edgeID","insertEdgeBefore","_ConnectionInterface$4","unshift","deleteNode","nodeID","_ConnectionInterface$5","undefined","slice","_ConnectionInterface$6","edgeIndex","connectionEdge","sourceEdges","targetEdges","_ConnectionInterface$7","has","add","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('../../store/RelayStoreUtils'),\n    getStableStorageKey = _require2.getStableStorageKey;\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      // $FlowFixMe[incompatible-type]\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Given a record ID, the key of a connection field, and optional filters used\n * to identify the connection, returns the connection ID.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<user-id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *     edges {\n *       node {\n *         id\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The ID of the `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const connectionID = ConnectionHandler.getConnectionID('<user-id>', 'FriendsFragment_friends');\n * }\n * ```\n */\n\n\nfunction getConnectionID(recordID, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  var storageKey = getStableStorageKey(handleKey, filters);\n  return generateClientID(recordID, storageKey);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n\n  if (edge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    edge.setValue(null, 'cursor');\n  }\n\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n\n  if (connectionEdge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    connectionEdge.setValue(null, 'cursor');\n  }\n\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  getConnectionID: getConnectionID,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}