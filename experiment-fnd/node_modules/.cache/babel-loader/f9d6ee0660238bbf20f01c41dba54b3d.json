{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./FragmentResource'),\n    getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\n\nvar ProfilerContext = require('./ProfilerContext');\n\nvar _require2 = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require2.getQueryResourceForEnvironment;\n\nvar useFragmentNode = require('./useFragmentNode');\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useQueryLoader = require('./useQueryLoader');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar invariant = require('invariant');\n\nvar _require3 = require('react'),\n    useCallback = _require3.useCallback,\n    useContext = _require3.useContext,\n    useReducer = _require3.useReducer;\n\nvar _require4 = require('relay-runtime'),\n    fetchQuery = _require4.__internal.fetchQuery,\n    createOperationDescriptor = _require4.createOperationDescriptor,\n    getFragmentIdentifier = _require4.getFragmentIdentifier,\n    getRefetchMetadata = _require4.getRefetchMetadata,\n    getSelector = _require4.getSelector,\n    getValueAtPath = _require4.getValueAtPath;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'refetch':\n      {\n        var _action$refetchEnviro;\n\n        return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, state), {}, {\n          fetchPolicy: action.fetchPolicy,\n          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,\n          onComplete: action.onComplete,\n          refetchEnvironment: action.refetchEnvironment,\n          refetchQuery: action.refetchQuery,\n          renderPolicy: action.renderPolicy\n        });\n      }\n\n    case 'reset':\n      {\n        return {\n          fetchPolicy: undefined,\n          mirroredEnvironment: action.environment,\n          mirroredFragmentIdentifier: action.fragmentIdentifier,\n          onComplete: undefined,\n          refetchQuery: null,\n          renderPolicy: undefined\n        };\n      }\n\n    default:\n      {\n        action.type;\n        throw new Error('useRefetchableFragmentNode: Unexpected action type');\n      }\n  }\n}\n\nfunction useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {\n  var parentEnvironment = useRelayEnvironment();\n\n  var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName),\n      refetchableRequest = _getRefetchMetadata.refetchableRequest,\n      fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,\n      identifierField = _getRefetchMetadata.identifierField;\n\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);\n\n  var _useReducer = useReducer(reducer, {\n    fetchPolicy: undefined,\n    mirroredEnvironment: parentEnvironment,\n    mirroredFragmentIdentifier: fragmentIdentifier,\n    onComplete: undefined,\n    refetchEnvironment: null,\n    refetchQuery: null,\n    renderPolicy: undefined\n  }),\n      refetchState = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var fetchPolicy = refetchState.fetchPolicy,\n      mirroredEnvironment = refetchState.mirroredEnvironment,\n      mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,\n      onComplete = refetchState.onComplete,\n      refetchEnvironment = refetchState.refetchEnvironment,\n      refetchQuery = refetchState.refetchQuery,\n      renderPolicy = refetchState.renderPolicy;\n  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var profilerContext = useContext(ProfilerContext);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n\n  var _useQueryLoader = useQueryLoader(refetchableRequest),\n      queryRef = _useQueryLoader[0],\n      loadQuery = _useQueryLoader[1],\n      disposeQuery = _useQueryLoader[2];\n\n  var fragmentRef = parentFragmentRef;\n\n  if (shouldReset) {\n    dispatch({\n      type: 'reset',\n      environment: environment,\n      fragmentIdentifier: fragmentIdentifier\n    });\n    disposeQuery();\n  } else if (refetchQuery != null && queryRef != null) {\n    // If refetch was called, we expect to have a refetchQuery and queryRef\n    // in state, since both state updates to set the refetchQuery and the\n    // queryRef occur simultaneously.\n    // In this case, we need to read the refetched query data (potentially\n    // suspending if it's in flight), and extract the new fragment ref\n    // from the query in order read the current @refetchable fragment\n    // with the updated fragment owner as the new refetchQuery.\n    // Before observing the refetch, record the current ID and typename\n    // so that, if we are refetching existing data on\n    // a field that implements Node, after refetching we\n    // can validate that the received data is consistent\n    var debugPreviousIDAndTypename;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);\n    }\n\n    var handleQueryCompleted = function handleQueryCompleted(maybeError) {\n      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);\n    }; // The queryRef.source obtained from useQueryLoader will be\n    // an observable we can consume /if/ a network request was\n    // started. Otherwise, given that QueryResource.prepare\n    // always expects an observable we fall back to a new network\n    // observable. Note however that if loadQuery did not make a network\n    // request, we don't expect to make one here, unless the state of\n    // the cache has changed between the call to refetch and this\n    // render.\n\n\n    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery); // Now wwe can we read the refetch query here using the\n    // queryRef provided from useQueryLoader. Note that the\n    // network request is started during the call to refetch,\n    // but if the refetch query is still in flight, we will suspend\n    // at this point:\n\n    var queryResult = profilerContext.wrapPrepareQueryResource(function () {\n      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {\n        error: handleQueryCompleted,\n        complete: function complete() {\n          // Validate that the type of the object we got back matches the type\n          // of the object already in the store\n          if (process.env.NODE_ENV !== \"production\") {\n            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);\n          }\n\n          handleQueryCompleted();\n        }\n      }, queryRef.fetchKey, profilerContext);\n    });\n    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;\n    !(queryData != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0; // After reading/fetching the refetch query, we extract from the\n    // refetch query response the new fragment ref we need to use to read\n    // the fragment. The new fragment ref will point to the refetch query\n    // as its fragment owner.\n\n    var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);\n    fragmentRef = refetchedFragmentRef;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Validate that the id of the object we got back matches the id\n      // we queried for in the variables.\n      // We do this during render instead of onComplete to make sure we are\n      // only validating the most recent refetch.\n      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);\n    }\n  } // We read and subscribe to the fragment using useFragmentNode.\n  // If refetch was called, we read the fragment using the new computed\n  // fragment ref from the refetch query response; otherwise, we use the\n  // fragment ref passed by the caller as normal.\n\n\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n      fragmentData = _useFragmentNode.data,\n      disableStoreUpdates = _useFragmentNode.disableStoreUpdates,\n      enableStoreUpdates = _useFragmentNode.enableStoreUpdates;\n\n  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);\n  return {\n    fragmentData: fragmentData,\n    fragmentRef: fragmentRef,\n    refetch: refetch,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\n\nfunction useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {\n  var isMountedRef = useIsMountedRef();\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  return useCallback(function (providedRefetchVariables, options) {\n    // Bail out and warn if we're trying to refetch after the component\n    // has unmounted\n    if (isMountedRef.current !== true) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    if (parentFragmentRef == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n\n    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;\n    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;\n    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);\n    var parentVariables;\n    var fragmentVariables;\n\n    if (fragmentSelector == null) {\n      parentVariables = {};\n      fragmentVariables = {};\n    } else if (fragmentSelector.kind === 'PluralReaderSelector') {\n      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;\n\n      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};\n      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};\n    } else {\n      parentVariables = fragmentSelector.owner.variables;\n      fragmentVariables = fragmentSelector.variables;\n    } // A user of `useRefetchableFragment()` may pass a subset of\n    // all variables required by the fragment when calling `refetch()`.\n    // We fill in any variables not passed by the call to `refetch()` with the\n    // variables from the original parent fragment owner.\n\n\n    var refetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables), providedRefetchVariables); // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n\n    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n\n      refetchVariables.id = identifierValue;\n    }\n\n    var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {\n      force: true\n    }); // We call loadQuery which will start a network request if necessary\n    // and update the querRef from useQueryLoader.\n    // Note the following:\n    // - loadQuery will dispose of any previously refetched queries.\n    // - We use the variables extracted off the OperationDescriptor\n    // so that they have been filtered out to include only the\n    // variables actually declared in the query.\n\n    loadQuery(refetchQuery.request.variables, {\n      fetchPolicy: fetchPolicy,\n      __environment: refetchEnvironment,\n      __nameForWarning: 'refetch'\n    });\n    dispatch({\n      type: 'refetch',\n      fetchPolicy: fetchPolicy,\n      onComplete: onComplete,\n      refetchEnvironment: refetchEnvironment,\n      refetchQuery: refetchQuery,\n      renderPolicy: renderPolicy\n    });\n    return {\n      dispose: disposeQuery\n    };\n  }, // NOTE: We disable react-hooks-deps warning because:\n  //   - We know fragmentRefPathInResponse is static, so it can be omitted from\n  //     deps\n  //   - We know fragmentNode is static, so it can be omitted from deps.\n  //   - fragmentNode and parentFragmentRef are also captured by including\n  //     fragmentIdentifier\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);\n}\n\nvar debugFunctions;\n\nif (process.env.NODE_ENV !== \"production\") {\n  debugFunctions = {\n    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {\n      var _require5 = require('relay-runtime'),\n          Record = _require5.Record;\n\n      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;\n\n      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {\n        return null;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(id);\n      var typename = record && Record.getType(record);\n\n      if (typename == null) {\n        return null;\n      }\n\n      return {\n        id: id,\n        typename: typename\n      };\n    },\n    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {\n      var _require6 = require('relay-runtime'),\n          Record = _require6.Record;\n\n      if (!previousIDAndType) {\n        return;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(previousIDAndType.id);\n      var typename = record && Record.getType(record);\n\n      if (typename !== previousIDAndType.typename) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    },\n    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {\n      if (previousIDAndTypename == null) {\n        return;\n      }\n\n      var _require7 = require('relay-runtime'),\n          ID_KEY = _require7.ID_KEY; // $FlowExpectedError[incompatible-use]\n\n\n      var resultID = refetchedFragmentRef[ID_KEY];\n\n      if (resultID != null && resultID !== previousIDAndTypename.id) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    }\n  };\n}\n\nmodule.exports = useRefetchableFragmentNode;","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","_require","getFragmentResourceForEnvironment","ProfilerContext","_require2","getQueryResourceForEnvironment","useFragmentNode","useIsMountedRef","useQueryLoader","useRelayEnvironment","invariant","_require3","useCallback","useContext","useReducer","_require4","fetchQuery","__internal","createOperationDescriptor","getFragmentIdentifier","getRefetchMetadata","getSelector","getValueAtPath","warning","reducer","state","action","type","_action$refetchEnviro","fetchPolicy","mirroredEnvironment","refetchEnvironment","onComplete","refetchQuery","renderPolicy","undefined","environment","mirroredFragmentIdentifier","fragmentIdentifier","Error","useRefetchableFragmentNode","fragmentNode","parentFragmentRef","componentDisplayName","parentEnvironment","_getRefetchMetadata","refetchableRequest","fragmentRefPathInResponse","identifierField","_useReducer","refetchState","dispatch","QueryResource","FragmentResource","profilerContext","shouldReset","_useQueryLoader","queryRef","loadQuery","disposeQuery","fragmentRef","debugPreviousIDAndTypename","process","env","NODE_ENV","debugFunctions","getInitialIDAndType","request","variables","handleQueryCompleted","maybeError","fetchObservable","source","queryResult","wrapPrepareQueryResource","prepare","error","complete","checkSameTypeAfterRefetch","fetchKey","queryData","read","data","refetchedFragmentRef","checkSameIDAfterRefetch","_useFragmentNode","fragmentData","disableStoreUpdates","enableStoreUpdates","refetch","useRefetchFunction","isMountedRef","identifierValue","providedRefetchVariables","options","current","name","dispose","__environment","UNSTABLE_renderPolicy","fragmentSelector","parentVariables","fragmentVariables","kind","_fragmentSelector$sel","_fragmentSelector$sel2","_fragmentSelector$sel3","_fragmentSelector$sel4","selectors","owner","refetchVariables","hasOwnProperty","id","force","__nameForWarning","memoRefetchVariables","_require5","Record","length","recordSource","getStore","getSource","record","get","typename","getType","previousIDAndType","_require6","previousIDAndTypename","_require7","ID_KEY","resultID","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentNode.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./FragmentResource'),\n    getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\n\nvar ProfilerContext = require('./ProfilerContext');\n\nvar _require2 = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require2.getQueryResourceForEnvironment;\n\nvar useFragmentNode = require('./useFragmentNode');\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useQueryLoader = require('./useQueryLoader');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar invariant = require('invariant');\n\nvar _require3 = require('react'),\n    useCallback = _require3.useCallback,\n    useContext = _require3.useContext,\n    useReducer = _require3.useReducer;\n\nvar _require4 = require('relay-runtime'),\n    fetchQuery = _require4.__internal.fetchQuery,\n    createOperationDescriptor = _require4.createOperationDescriptor,\n    getFragmentIdentifier = _require4.getFragmentIdentifier,\n    getRefetchMetadata = _require4.getRefetchMetadata,\n    getSelector = _require4.getSelector,\n    getValueAtPath = _require4.getValueAtPath;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'refetch':\n      {\n        var _action$refetchEnviro;\n\n        return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, state), {}, {\n          fetchPolicy: action.fetchPolicy,\n          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,\n          onComplete: action.onComplete,\n          refetchEnvironment: action.refetchEnvironment,\n          refetchQuery: action.refetchQuery,\n          renderPolicy: action.renderPolicy\n        });\n      }\n\n    case 'reset':\n      {\n        return {\n          fetchPolicy: undefined,\n          mirroredEnvironment: action.environment,\n          mirroredFragmentIdentifier: action.fragmentIdentifier,\n          onComplete: undefined,\n          refetchQuery: null,\n          renderPolicy: undefined\n        };\n      }\n\n    default:\n      {\n        action.type;\n        throw new Error('useRefetchableFragmentNode: Unexpected action type');\n      }\n  }\n}\n\nfunction useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {\n  var parentEnvironment = useRelayEnvironment();\n\n  var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName),\n      refetchableRequest = _getRefetchMetadata.refetchableRequest,\n      fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,\n      identifierField = _getRefetchMetadata.identifierField;\n\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);\n\n  var _useReducer = useReducer(reducer, {\n    fetchPolicy: undefined,\n    mirroredEnvironment: parentEnvironment,\n    mirroredFragmentIdentifier: fragmentIdentifier,\n    onComplete: undefined,\n    refetchEnvironment: null,\n    refetchQuery: null,\n    renderPolicy: undefined\n  }),\n      refetchState = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var fetchPolicy = refetchState.fetchPolicy,\n      mirroredEnvironment = refetchState.mirroredEnvironment,\n      mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,\n      onComplete = refetchState.onComplete,\n      refetchEnvironment = refetchState.refetchEnvironment,\n      refetchQuery = refetchState.refetchQuery,\n      renderPolicy = refetchState.renderPolicy;\n  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var profilerContext = useContext(ProfilerContext);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n\n  var _useQueryLoader = useQueryLoader(refetchableRequest),\n      queryRef = _useQueryLoader[0],\n      loadQuery = _useQueryLoader[1],\n      disposeQuery = _useQueryLoader[2];\n\n  var fragmentRef = parentFragmentRef;\n\n  if (shouldReset) {\n    dispatch({\n      type: 'reset',\n      environment: environment,\n      fragmentIdentifier: fragmentIdentifier\n    });\n    disposeQuery();\n  } else if (refetchQuery != null && queryRef != null) {\n    // If refetch was called, we expect to have a refetchQuery and queryRef\n    // in state, since both state updates to set the refetchQuery and the\n    // queryRef occur simultaneously.\n    // In this case, we need to read the refetched query data (potentially\n    // suspending if it's in flight), and extract the new fragment ref\n    // from the query in order read the current @refetchable fragment\n    // with the updated fragment owner as the new refetchQuery.\n    // Before observing the refetch, record the current ID and typename\n    // so that, if we are refetching existing data on\n    // a field that implements Node, after refetching we\n    // can validate that the received data is consistent\n    var debugPreviousIDAndTypename;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);\n    }\n\n    var handleQueryCompleted = function handleQueryCompleted(maybeError) {\n      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);\n    }; // The queryRef.source obtained from useQueryLoader will be\n    // an observable we can consume /if/ a network request was\n    // started. Otherwise, given that QueryResource.prepare\n    // always expects an observable we fall back to a new network\n    // observable. Note however that if loadQuery did not make a network\n    // request, we don't expect to make one here, unless the state of\n    // the cache has changed between the call to refetch and this\n    // render.\n\n\n    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery); // Now wwe can we read the refetch query here using the\n    // queryRef provided from useQueryLoader. Note that the\n    // network request is started during the call to refetch,\n    // but if the refetch query is still in flight, we will suspend\n    // at this point:\n\n    var queryResult = profilerContext.wrapPrepareQueryResource(function () {\n      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {\n        error: handleQueryCompleted,\n        complete: function complete() {\n          // Validate that the type of the object we got back matches the type\n          // of the object already in the store\n          if (process.env.NODE_ENV !== \"production\") {\n            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);\n          }\n\n          handleQueryCompleted();\n        }\n      }, queryRef.fetchKey, profilerContext);\n    });\n    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;\n    !(queryData != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0; // After reading/fetching the refetch query, we extract from the\n    // refetch query response the new fragment ref we need to use to read\n    // the fragment. The new fragment ref will point to the refetch query\n    // as its fragment owner.\n\n    var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);\n    fragmentRef = refetchedFragmentRef;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Validate that the id of the object we got back matches the id\n      // we queried for in the variables.\n      // We do this during render instead of onComplete to make sure we are\n      // only validating the most recent refetch.\n      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);\n    }\n  } // We read and subscribe to the fragment using useFragmentNode.\n  // If refetch was called, we read the fragment using the new computed\n  // fragment ref from the refetch query response; otherwise, we use the\n  // fragment ref passed by the caller as normal.\n\n\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n      fragmentData = _useFragmentNode.data,\n      disableStoreUpdates = _useFragmentNode.disableStoreUpdates,\n      enableStoreUpdates = _useFragmentNode.enableStoreUpdates;\n\n  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);\n  return {\n    fragmentData: fragmentData,\n    fragmentRef: fragmentRef,\n    refetch: refetch,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\n\nfunction useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {\n  var isMountedRef = useIsMountedRef();\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  return useCallback(function (providedRefetchVariables, options) {\n    // Bail out and warn if we're trying to refetch after the component\n    // has unmounted\n    if (isMountedRef.current !== true) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    if (parentFragmentRef == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n\n    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;\n    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;\n    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);\n    var parentVariables;\n    var fragmentVariables;\n\n    if (fragmentSelector == null) {\n      parentVariables = {};\n      fragmentVariables = {};\n    } else if (fragmentSelector.kind === 'PluralReaderSelector') {\n      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;\n\n      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};\n      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};\n    } else {\n      parentVariables = fragmentSelector.owner.variables;\n      fragmentVariables = fragmentSelector.variables;\n    } // A user of `useRefetchableFragment()` may pass a subset of\n    // all variables required by the fragment when calling `refetch()`.\n    // We fill in any variables not passed by the call to `refetch()` with the\n    // variables from the original parent fragment owner.\n\n\n    var refetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables), providedRefetchVariables); // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n\n    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n\n      refetchVariables.id = identifierValue;\n    }\n\n    var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {\n      force: true\n    }); // We call loadQuery which will start a network request if necessary\n    // and update the querRef from useQueryLoader.\n    // Note the following:\n    // - loadQuery will dispose of any previously refetched queries.\n    // - We use the variables extracted off the OperationDescriptor\n    // so that they have been filtered out to include only the\n    // variables actually declared in the query.\n\n    loadQuery(refetchQuery.request.variables, {\n      fetchPolicy: fetchPolicy,\n      __environment: refetchEnvironment,\n      __nameForWarning: 'refetch'\n    });\n    dispatch({\n      type: 'refetch',\n      fetchPolicy: fetchPolicy,\n      onComplete: onComplete,\n      refetchEnvironment: refetchEnvironment,\n      refetchQuery: refetchQuery,\n      renderPolicy: renderPolicy\n    });\n    return {\n      dispose: disposeQuery\n    };\n  }, // NOTE: We disable react-hooks-deps warning because:\n  //   - We know fragmentRefPathInResponse is static, so it can be omitted from\n  //     deps\n  //   - We know fragmentNode is static, so it can be omitted from deps.\n  //   - fragmentNode and parentFragmentRef are also captured by including\n  //     fragmentIdentifier\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);\n}\n\nvar debugFunctions;\n\nif (process.env.NODE_ENV !== \"production\") {\n  debugFunctions = {\n    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {\n      var _require5 = require('relay-runtime'),\n          Record = _require5.Record;\n\n      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;\n\n      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {\n        return null;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(id);\n      var typename = record && Record.getType(record);\n\n      if (typename == null) {\n        return null;\n      }\n\n      return {\n        id: id,\n        typename: typename\n      };\n    },\n    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {\n      var _require6 = require('relay-runtime'),\n          Record = _require6.Record;\n\n      if (!previousIDAndType) {\n        return;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(previousIDAndType.id);\n      var typename = record && Record.getType(record);\n\n      if (typename !== previousIDAndType.typename) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    },\n    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {\n      if (previousIDAndTypename == null) {\n        return;\n      }\n\n      var _require7 = require('relay-runtime'),\n          ID_KEY = _require7.ID_KEY; // $FlowExpectedError[incompatible-use]\n\n\n      var resultID = refetchedFragmentRef[ID_KEY];\n\n      if (resultID != null && resultID !== previousIDAndTypename.id) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    }\n  };\n}\n\nmodule.exports = useRefetchableFragmentNode;"],"mappings":"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"},"metadata":{},"sourceType":"script"}