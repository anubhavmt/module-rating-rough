{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _require = require('./loadQuery'),\n    loadQuery = _require.loadQuery,\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar _require3 = require('relay-runtime'),\n    getRequest = _require3.getRequest;\n\nvar initialNullQueryReferenceState = {\n  kind: 'NullQueryReference'\n};\n\nfunction requestIsLiveQuery(preloadableRequest) {\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    return preloadableRequest.params.metadata.live !== undefined;\n  }\n\n  var request = getRequest(preloadableRequest);\n  return request.params.metadata.live !== undefined;\n}\n\nfunction useQueryLoader(preloadableRequest, initialQueryReference) {\n  /**\n   * We want to always call `queryReference.dispose()` for every call to\n   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores\n   * will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each\n   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.\n   *\n   * Instead, we keep track of each call to `loadQuery` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded query references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * query references.\n   */\n  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;\n  var environment = useRelayEnvironment();\n  useTrackLoadQueryInRender();\n  var isMountedRef = useIsMountedRef();\n  var undisposedQueryReferencesRef = useRef(new Set([initialQueryReferenceInternal]));\n\n  var _useState = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      queryReference = _useState[0],\n      setQueryReference = _useState[1];\n\n  var _useState2 = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      previousInitialQueryReference = _useState2[0],\n      setPreviousInitialQueryReference = _useState2[1];\n\n  if (initialQueryReferenceInternal !== previousInitialQueryReference) {\n    // Rendering the query reference makes it \"managed\" by this hook, so\n    // we start keeping track of it so we can dispose it when it is no longer\n    // necessary here\n    // TODO(T78446637): Handle disposal of managed query references in\n    // components that were never mounted after rendering\n    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);\n    setPreviousInitialQueryReference(initialQueryReferenceInternal);\n    setQueryReference(initialQueryReferenceInternal);\n  }\n\n  var disposeQuery = useCallback(function () {\n    if (isMountedRef.current) {\n      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);\n      setQueryReference(initialNullQueryReferenceState);\n    }\n  }, [isMountedRef]);\n  var queryLoaderCallback = useCallback(function (variables, options) {\n    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {\n      fetchPolicy: options.fetchPolicy,\n      networkCacheConfig: options.networkCacheConfig,\n      __nameForWarning: options.__nameForWarning\n    } : options;\n\n    if (isMountedRef.current) {\n      var _options$__environmen;\n\n      var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);\n      undisposedQueryReferencesRef.current.add(updatedQueryReference);\n      setQueryReference(updatedQueryReference);\n    }\n  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current queryReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current queryReference disposed, we need to load the query again\n      // and force a re-render by calling queryLoaderCallback again,\n      // so that the queryReference is correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (queryReference.kind !== 'NullQueryReference') {\n        queryLoaderCallback(queryReference.variables, {\n          fetchPolicy: queryReference.fetchPolicy,\n          networkCacheConfig: queryReference.networkCacheConfig\n        });\n      }\n\n      return;\n    } // When a new queryReference is committed, we iterate over all\n    // query references in undisposedQueryReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling query references for the\n    // case that loadQuery is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedQueryReferences until we find queryReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find queryReference in the set, because if a\n    // state update results in a commit, no state updates initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with updates that were scheduled prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedQueryReferences = undisposedQueryReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedQueryReference = _step.value;\n\n          if (undisposedQueryReference === queryReference) {\n            break;\n          }\n\n          undisposedQueryReferences[\"delete\"](undisposedQueryReference);\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);\n  useEffect(function () {\n    return function disposeAllRemainingQueryReferences() {\n      // undisposedQueryReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var undisposedQueryReference = _step2.value;\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [preloadableRequest]);\n  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];\n}\n\nmodule.exports = useQueryLoader;","map":{"version":3,"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_require","loadQuery","useTrackLoadQueryInRender","useIsMountedRef","useRelayEnvironment","_require2","useCallback","useEffect","useRef","useState","_require3","getRequest","initialNullQueryReferenceState","kind","requestIsLiveQuery","preloadableRequest","params","metadata","live","undefined","request","useQueryLoader","initialQueryReference","initialQueryReferenceInternal","environment","isMountedRef","undisposedQueryReferencesRef","Set","_useState","queryReference","setQueryReference","_useState2","previousInitialQueryReference","setPreviousInitialQueryReference","current","add","disposeQuery","queryLoaderCallback","variables","options","mergedOptions","hasOwnProperty","fetchPolicy","networkCacheConfig","__nameForWarning","_options$__environmen","updatedQueryReference","__environment","maybeHiddenOrFastRefresh","undisposedQueryReferences","_iterator","_step","s","n","done","undisposedQueryReference","value","dispose","releaseQuery","err","e","f","disposeAllRemainingQueryReferences","_iterator2","_step2","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _require = require('./loadQuery'),\n    loadQuery = _require.loadQuery,\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar _require3 = require('relay-runtime'),\n    getRequest = _require3.getRequest;\n\nvar initialNullQueryReferenceState = {\n  kind: 'NullQueryReference'\n};\n\nfunction requestIsLiveQuery(preloadableRequest) {\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    return preloadableRequest.params.metadata.live !== undefined;\n  }\n\n  var request = getRequest(preloadableRequest);\n  return request.params.metadata.live !== undefined;\n}\n\nfunction useQueryLoader(preloadableRequest, initialQueryReference) {\n  /**\n   * We want to always call `queryReference.dispose()` for every call to\n   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores\n   * will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each\n   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.\n   *\n   * Instead, we keep track of each call to `loadQuery` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded query references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * query references.\n   */\n  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;\n  var environment = useRelayEnvironment();\n  useTrackLoadQueryInRender();\n  var isMountedRef = useIsMountedRef();\n  var undisposedQueryReferencesRef = useRef(new Set([initialQueryReferenceInternal]));\n\n  var _useState = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      queryReference = _useState[0],\n      setQueryReference = _useState[1];\n\n  var _useState2 = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      previousInitialQueryReference = _useState2[0],\n      setPreviousInitialQueryReference = _useState2[1];\n\n  if (initialQueryReferenceInternal !== previousInitialQueryReference) {\n    // Rendering the query reference makes it \"managed\" by this hook, so\n    // we start keeping track of it so we can dispose it when it is no longer\n    // necessary here\n    // TODO(T78446637): Handle disposal of managed query references in\n    // components that were never mounted after rendering\n    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);\n    setPreviousInitialQueryReference(initialQueryReferenceInternal);\n    setQueryReference(initialQueryReferenceInternal);\n  }\n\n  var disposeQuery = useCallback(function () {\n    if (isMountedRef.current) {\n      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);\n      setQueryReference(initialNullQueryReferenceState);\n    }\n  }, [isMountedRef]);\n  var queryLoaderCallback = useCallback(function (variables, options) {\n    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {\n      fetchPolicy: options.fetchPolicy,\n      networkCacheConfig: options.networkCacheConfig,\n      __nameForWarning: options.__nameForWarning\n    } : options;\n\n    if (isMountedRef.current) {\n      var _options$__environmen;\n\n      var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);\n      undisposedQueryReferencesRef.current.add(updatedQueryReference);\n      setQueryReference(updatedQueryReference);\n    }\n  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current queryReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current queryReference disposed, we need to load the query again\n      // and force a re-render by calling queryLoaderCallback again,\n      // so that the queryReference is correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (queryReference.kind !== 'NullQueryReference') {\n        queryLoaderCallback(queryReference.variables, {\n          fetchPolicy: queryReference.fetchPolicy,\n          networkCacheConfig: queryReference.networkCacheConfig\n        });\n      }\n\n      return;\n    } // When a new queryReference is committed, we iterate over all\n    // query references in undisposedQueryReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling query references for the\n    // case that loadQuery is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedQueryReferences until we find queryReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find queryReference in the set, because if a\n    // state update results in a commit, no state updates initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with updates that were scheduled prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedQueryReferences = undisposedQueryReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedQueryReference = _step.value;\n\n          if (undisposedQueryReference === queryReference) {\n            break;\n          }\n\n          undisposedQueryReferences[\"delete\"](undisposedQueryReference);\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);\n  useEffect(function () {\n    return function disposeAllRemainingQueryReferences() {\n      // undisposedQueryReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var undisposedQueryReference = _step2.value;\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [preloadableRequest]);\n  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];\n}\n\nmodule.exports = useQueryLoader;"],"mappings":"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"},"metadata":{},"sourceType":"script"}