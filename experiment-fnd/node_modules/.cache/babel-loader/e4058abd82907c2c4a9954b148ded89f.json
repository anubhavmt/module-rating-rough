{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar isPromise = require('../util/isPromise');\n/**\n * A Subscription object is returned from .subscribe(), which can be\n * unsubscribed or checked to see if the resulting subscription has closed.\n */\n\n\nvar hostReportError = swallowError;\n/**\n * Limited implementation of ESObservable, providing the limited set of behavior\n * Relay networking requires.\n *\n * Observables retain the benefit of callbacks which can be called\n * synchronously, avoiding any UI jitter, while providing a compositional API,\n * which simplifies logic and prevents mishandling of errors compared to\n * the direct use of callback functions.\n *\n * ESObservable: https://github.com/tc39/proposal-observable\n */\n\nvar RelayObservable = /*#__PURE__*/function () {\n  RelayObservable.create = function create(source) {\n    return new RelayObservable(source);\n  } // Use RelayObservable.create()\n  ;\n\n  function RelayObservable(source) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed sources.\n      if (!source || typeof source !== 'function') {\n        throw new Error('Source must be a Function: ' + String(source));\n      }\n    }\n\n    this._source = source;\n  }\n  /**\n   * When an emitted error event is not handled by an Observer, it is reported\n   * to the host environment (what the ESObservable spec refers to as\n   * \"HostReportErrors()\").\n   *\n   * The default implementation in development rethrows thrown errors, and\n   * logs emitted error events to the console, while in production does nothing\n   * (swallowing unhandled errors).\n   *\n   * Called during application initialization, this method allows\n   * application-specific handling of unhandled errors. Allowing, for example,\n   * integration with error logging or developer tools.\n   *\n   * A second parameter `isUncaughtThrownError` is true when the unhandled error\n   * was thrown within an Observer handler, and false when the unhandled error\n   * was an unhandled emitted event.\n   *\n   *  - Uncaught thrown errors typically represent avoidable errors thrown from\n   *    application code, which should be handled with a try/catch block, and\n   *    usually have useful stack traces.\n   *\n   *  - Unhandled emitted event errors typically represent unavoidable events in\n   *    application flow such as network failure, and may not have useful\n   *    stack traces.\n   */\n\n\n  RelayObservable.onUnhandledError = function onUnhandledError(callback) {\n    hostReportError = callback;\n  }\n  /**\n   * Accepts various kinds of data sources, and always returns a RelayObservable\n   * useful for accepting the result of a user-provided FetchFunction.\n   */\n  ;\n\n  RelayObservable.from = function from(obj) {\n    return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);\n  }\n  /**\n   * Similar to promise.catch(), observable.catch() handles error events, and\n   * provides an alternative observable to use in it's place.\n   *\n   * If the catch handler throws a new error, it will appear as an error event\n   * on the resulting Observable.\n   */\n  ;\n\n  var _proto = RelayObservable.prototype;\n\n  _proto[\"catch\"] = function _catch(fn) {\n    var _this = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n\n      _this.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: sink.next,\n        complete: sink.complete,\n        error: function error(_error2) {\n          try {\n            fn(_error2).subscribe({\n              start: function start(sub) {\n                subscription = sub;\n              },\n              next: sink.next,\n              complete: sink.complete,\n              error: sink.error\n            });\n          } catch (error2) {\n            sink.error(error2, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        return subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first yields values from this Observable,\n   * then yields values from the next Observable. This is useful for chaining\n   * together Observables of finite length.\n   */\n  ;\n\n  _proto.concat = function concat(next) {\n    var _this2 = this;\n\n    return RelayObservable.create(function (sink) {\n      var current;\n\n      _this2.subscribe({\n        start: function start(subscription) {\n          current = subscription;\n        },\n        next: sink.next,\n        error: sink.error,\n        complete: function complete() {\n          current = next.subscribe(sink);\n        }\n      });\n\n      return function () {\n        current && current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the provided Observer is called to perform a side-effects\n   * for all events emitted by the source.\n   *\n   * Any errors that are thrown in the side-effect Observer are unhandled, and\n   * do not affect the source Observable or its Observer.\n   *\n   * This is useful for when debugging your Observables or performing other\n   * side-effects such as logging or performance monitoring.\n   */\n  ;\n\n  _proto[\"do\"] = function _do(observer) {\n    var _this3 = this;\n\n    return RelayObservable.create(function (sink) {\n      var both = function both(action) {\n        return function () {\n          try {\n            observer[action] && observer[action].apply(observer, arguments);\n          } catch (error) {\n            hostReportError(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n\n          sink[action] && sink[action].apply(sink, arguments);\n        };\n      };\n\n      return _this3.subscribe({\n        start: both('start'),\n        next: both('next'),\n        error: both('error'),\n        complete: both('complete'),\n        unsubscribe: both('unsubscribe')\n      });\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the finally callback is performed after completion,\n   * whether normal or due to error or unsubscription.\n   *\n   * This is useful for cleanup such as resource finalization.\n   */\n  ;\n\n  _proto[\"finally\"] = function _finally(fn) {\n    var _this4 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this4.subscribe(sink);\n\n      return function () {\n        subscription.unsubscribe();\n        fn();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which is identical to this one, unless this\n   * Observable completes before yielding any values, in which case the new\n   * Observable will yield the values from the alternate Observable.\n   *\n   * If this Observable does yield values, the alternate is never subscribed to.\n   *\n   * This is useful for scenarios where values may come from multiple sources\n   * which should be tried in order, i.e. from a cache before a network.\n   */\n  ;\n\n  _proto.ifEmpty = function ifEmpty(alternate) {\n    var _this5 = this;\n\n    return RelayObservable.create(function (sink) {\n      var hasValue = false;\n\n      var current = _this5.subscribe({\n        next: function next(value) {\n          hasValue = true;\n          sink.next(value);\n        },\n        error: sink.error,\n        complete: function complete() {\n          if (hasValue) {\n            sink.complete();\n          } else {\n            current = alternate.subscribe(sink);\n          }\n        }\n      });\n\n      return function () {\n        current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Observable's primary API: returns an unsubscribable Subscription to the\n   * source of this Observable.\n   *\n   * Note: A sink may be passed directly to .subscribe() as its observer,\n   * allowing for easily composing Observables.\n   */\n  ;\n\n  _proto.subscribe = function subscribe(observer) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed observers.\n      if (!observer || typeof observer !== 'object') {\n        throw new Error('Observer must be an Object with callbacks: ' + String(observer));\n      }\n    }\n\n    return _subscribe(this._source, observer);\n  }\n  /**\n   * Returns a new Observerable where each value has been transformed by\n   * the mapping function.\n   */\n  ;\n\n  _proto.map = function map(fn) {\n    var _this6 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this6.subscribe({\n        complete: sink.complete,\n        error: sink.error,\n        next: function next(value) {\n          try {\n            var mapValue = fn(value);\n            sink.next(mapValue);\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable where each value is replaced with a new Observable\n   * by the mapping function, the results of which returned as a single\n   * merged Observable.\n   */\n  ;\n\n  _proto.mergeMap = function mergeMap(fn) {\n    var _this7 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscriptions = [];\n\n      function start(subscription) {\n        this._sub = subscription;\n        subscriptions.push(subscription);\n      }\n\n      function complete() {\n        subscriptions.splice(subscriptions.indexOf(this._sub), 1);\n\n        if (subscriptions.length === 0) {\n          sink.complete();\n        }\n      }\n\n      _this7.subscribe({\n        start: start,\n        next: function next(value) {\n          try {\n            if (!sink.closed) {\n              RelayObservable.from(fn(value)).subscribe({\n                start: start,\n                next: sink.next,\n                error: sink.error,\n                complete: complete\n              });\n            }\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        },\n        error: sink.error,\n        complete: complete\n      });\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n        subscriptions.length = 0;\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first mirrors this Observable, then when it\n   * completes, waits for `pollInterval` milliseconds before re-subscribing to\n   * this Observable again, looping in this manner until unsubscribed.\n   *\n   * The returned Observable never completes.\n   */\n  ;\n\n  _proto.poll = function poll(pollInterval) {\n    var _this8 = this;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof pollInterval !== 'number' || pollInterval <= 0) {\n        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);\n      }\n    }\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n      var timeout;\n\n      var poll = function poll() {\n        subscription = _this8.subscribe({\n          next: sink.next,\n          error: sink.error,\n          complete: function complete() {\n            timeout = setTimeout(poll, pollInterval);\n          }\n        });\n      };\n\n      poll();\n      return function () {\n        clearTimeout(timeout);\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a Promise which resolves when this Observable yields a first value\n   * or when it completes with no value.\n   *\n   * NOTE: The source Observable is *NOT* canceled when the returned Promise\n   * resolves. The Observable is always run to completion.\n   */\n  ;\n\n  _proto.toPromise = function toPromise() {\n    var _this9 = this;\n\n    return new Promise(function (resolve, reject) {\n      var resolved = false;\n\n      _this9.subscribe({\n        next: function next(val) {\n          if (!resolved) {\n            resolved = true;\n            resolve(val);\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  return RelayObservable;\n}(); // Use declarations to teach Flow how to check isObservable.\n\n\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';\n}\n\nfunction fromObservable(obj) {\n  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {\n    return obj.subscribe(sink);\n  });\n}\n\nfunction fromPromise(promise) {\n  return RelayObservable.create(function (sink) {\n    // Since sink methods do not throw, the resulting Promise can be ignored.\n    promise.then(function (value) {\n      sink.next(value);\n      sink.complete();\n    }, sink.error);\n  });\n}\n\nfunction fromValue(value) {\n  return RelayObservable.create(function (sink) {\n    sink.next(value);\n    sink.complete();\n  });\n}\n\nfunction _subscribe(source, observer) {\n  var closed = false;\n  var cleanup; // Ideally we would simply describe a `get closed()` method on the Sink and\n  // Subscription objects below, however not all flow environments we expect\n  // Relay to be used within will support property getters, and many minifier\n  // tools still do not support ES5 syntax. Instead, we can use defineProperty.\n\n  var withClosed = function withClosed(obj) {\n    return Object.defineProperty(obj, 'closed', {\n      get: function get() {\n        return closed;\n      }\n    });\n  };\n\n  function doCleanup() {\n    if (cleanup) {\n      if (cleanup.unsubscribe) {\n        cleanup.unsubscribe();\n      } else {\n        try {\n          cleanup();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n\n      cleanup = undefined;\n    }\n  } // Create a Subscription.\n\n\n  var subscription = withClosed({\n    unsubscribe: function unsubscribe() {\n      if (!closed) {\n        closed = true; // Tell Observer that unsubscribe was called.\n\n        try {\n          observer.unsubscribe && observer.unsubscribe(subscription);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // Tell Observer that observation is about to begin.\n\n  try {\n    observer.start && observer.start(subscription);\n  } catch (error) {\n    hostReportError(error, true\n    /* isUncaughtThrownError */\n    );\n  } // If closed already, don't bother creating a Sink.\n\n\n  if (closed) {\n    return subscription;\n  } // Create a Sink respecting subscription state and cleanup.\n\n\n  var sink = withClosed({\n    next: function next(value) {\n      if (!closed && observer.next) {\n        try {\n          observer.next(value);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n    },\n    error: function error(_error3, isUncaughtThrownError) {\n      if (closed || !observer.error) {\n        closed = true;\n        hostReportError(_error3, isUncaughtThrownError || false);\n        doCleanup();\n      } else {\n        closed = true;\n\n        try {\n          observer.error(_error3);\n        } catch (error2) {\n          hostReportError(error2, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    },\n    complete: function complete() {\n      if (!closed) {\n        closed = true;\n\n        try {\n          observer.complete && observer.complete();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // If anything goes wrong during observing the source, handle the error.\n\n  try {\n    cleanup = source(sink);\n  } catch (error) {\n    sink.error(error, true\n    /* isUncaughtThrownError */\n    );\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // Early runtime errors for ill-formed returned cleanup.\n    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {\n      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));\n    }\n  } // If closed before the source function existed, cleanup now.\n\n\n  if (closed) {\n    doCleanup();\n  }\n\n  return subscription;\n}\n\nfunction swallowError(_error, _isUncaughtThrownError) {// do nothing.\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  // Default implementation of HostReportErrors() in development builds.\n  // Can be replaced by the host application environment.\n  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {\n    if (typeof fail === 'function') {\n      // In test environments (Jest), fail() immediately fails the current test.\n      fail(String(error));\n    } else if (isUncaughtThrownError) {\n      // Rethrow uncaught thrown errors on the next frame to avoid breaking\n      // current logic.\n      setTimeout(function () {\n        throw error;\n      });\n    } else if (typeof console !== 'undefined') {\n      // Otherwise, log the unhandled error for visibility.\n      // eslint-disable-next-line no-console\n      console.error('RelayObservable: Unhandled Error', error);\n    }\n  });\n}\n\nmodule.exports = RelayObservable;","map":{"version":3,"names":["isPromise","require","hostReportError","swallowError","RelayObservable","create","source","process","env","NODE_ENV","Error","String","_source","onUnhandledError","callback","from","obj","isObservable","fromObservable","fromPromise","fromValue","_proto","prototype","_catch","fn","_this","sink","subscription","subscribe","start","sub","next","complete","error","_error2","error2","unsubscribe","concat","_this2","current","_do","observer","_this3","both","action","apply","arguments","_finally","_this4","ifEmpty","alternate","_this5","hasValue","value","_subscribe","map","_this6","mapValue","mergeMap","_this7","subscriptions","_sub","push","splice","indexOf","length","closed","forEach","poll","pollInterval","_this8","timeout","setTimeout","clearTimeout","toPromise","_this9","Promise","resolve","reject","resolved","val","promise","then","cleanup","withClosed","Object","defineProperty","get","doCleanup","undefined","_error3","isUncaughtThrownError","_error","_isUncaughtThrownError","fail","console","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/network/RelayObservable.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar isPromise = require('../util/isPromise');\n/**\n * A Subscription object is returned from .subscribe(), which can be\n * unsubscribed or checked to see if the resulting subscription has closed.\n */\n\n\nvar hostReportError = swallowError;\n/**\n * Limited implementation of ESObservable, providing the limited set of behavior\n * Relay networking requires.\n *\n * Observables retain the benefit of callbacks which can be called\n * synchronously, avoiding any UI jitter, while providing a compositional API,\n * which simplifies logic and prevents mishandling of errors compared to\n * the direct use of callback functions.\n *\n * ESObservable: https://github.com/tc39/proposal-observable\n */\n\nvar RelayObservable = /*#__PURE__*/function () {\n  RelayObservable.create = function create(source) {\n    return new RelayObservable(source);\n  } // Use RelayObservable.create()\n  ;\n\n  function RelayObservable(source) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed sources.\n      if (!source || typeof source !== 'function') {\n        throw new Error('Source must be a Function: ' + String(source));\n      }\n    }\n\n    this._source = source;\n  }\n  /**\n   * When an emitted error event is not handled by an Observer, it is reported\n   * to the host environment (what the ESObservable spec refers to as\n   * \"HostReportErrors()\").\n   *\n   * The default implementation in development rethrows thrown errors, and\n   * logs emitted error events to the console, while in production does nothing\n   * (swallowing unhandled errors).\n   *\n   * Called during application initialization, this method allows\n   * application-specific handling of unhandled errors. Allowing, for example,\n   * integration with error logging or developer tools.\n   *\n   * A second parameter `isUncaughtThrownError` is true when the unhandled error\n   * was thrown within an Observer handler, and false when the unhandled error\n   * was an unhandled emitted event.\n   *\n   *  - Uncaught thrown errors typically represent avoidable errors thrown from\n   *    application code, which should be handled with a try/catch block, and\n   *    usually have useful stack traces.\n   *\n   *  - Unhandled emitted event errors typically represent unavoidable events in\n   *    application flow such as network failure, and may not have useful\n   *    stack traces.\n   */\n\n\n  RelayObservable.onUnhandledError = function onUnhandledError(callback) {\n    hostReportError = callback;\n  }\n  /**\n   * Accepts various kinds of data sources, and always returns a RelayObservable\n   * useful for accepting the result of a user-provided FetchFunction.\n   */\n  ;\n\n  RelayObservable.from = function from(obj) {\n    return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);\n  }\n  /**\n   * Similar to promise.catch(), observable.catch() handles error events, and\n   * provides an alternative observable to use in it's place.\n   *\n   * If the catch handler throws a new error, it will appear as an error event\n   * on the resulting Observable.\n   */\n  ;\n\n  var _proto = RelayObservable.prototype;\n\n  _proto[\"catch\"] = function _catch(fn) {\n    var _this = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n\n      _this.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: sink.next,\n        complete: sink.complete,\n        error: function error(_error2) {\n          try {\n            fn(_error2).subscribe({\n              start: function start(sub) {\n                subscription = sub;\n              },\n              next: sink.next,\n              complete: sink.complete,\n              error: sink.error\n            });\n          } catch (error2) {\n            sink.error(error2, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        return subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first yields values from this Observable,\n   * then yields values from the next Observable. This is useful for chaining\n   * together Observables of finite length.\n   */\n  ;\n\n  _proto.concat = function concat(next) {\n    var _this2 = this;\n\n    return RelayObservable.create(function (sink) {\n      var current;\n\n      _this2.subscribe({\n        start: function start(subscription) {\n          current = subscription;\n        },\n        next: sink.next,\n        error: sink.error,\n        complete: function complete() {\n          current = next.subscribe(sink);\n        }\n      });\n\n      return function () {\n        current && current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the provided Observer is called to perform a side-effects\n   * for all events emitted by the source.\n   *\n   * Any errors that are thrown in the side-effect Observer are unhandled, and\n   * do not affect the source Observable or its Observer.\n   *\n   * This is useful for when debugging your Observables or performing other\n   * side-effects such as logging or performance monitoring.\n   */\n  ;\n\n  _proto[\"do\"] = function _do(observer) {\n    var _this3 = this;\n\n    return RelayObservable.create(function (sink) {\n      var both = function both(action) {\n        return function () {\n          try {\n            observer[action] && observer[action].apply(observer, arguments);\n          } catch (error) {\n            hostReportError(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n\n          sink[action] && sink[action].apply(sink, arguments);\n        };\n      };\n\n      return _this3.subscribe({\n        start: both('start'),\n        next: both('next'),\n        error: both('error'),\n        complete: both('complete'),\n        unsubscribe: both('unsubscribe')\n      });\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the finally callback is performed after completion,\n   * whether normal or due to error or unsubscription.\n   *\n   * This is useful for cleanup such as resource finalization.\n   */\n  ;\n\n  _proto[\"finally\"] = function _finally(fn) {\n    var _this4 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this4.subscribe(sink);\n\n      return function () {\n        subscription.unsubscribe();\n        fn();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which is identical to this one, unless this\n   * Observable completes before yielding any values, in which case the new\n   * Observable will yield the values from the alternate Observable.\n   *\n   * If this Observable does yield values, the alternate is never subscribed to.\n   *\n   * This is useful for scenarios where values may come from multiple sources\n   * which should be tried in order, i.e. from a cache before a network.\n   */\n  ;\n\n  _proto.ifEmpty = function ifEmpty(alternate) {\n    var _this5 = this;\n\n    return RelayObservable.create(function (sink) {\n      var hasValue = false;\n\n      var current = _this5.subscribe({\n        next: function next(value) {\n          hasValue = true;\n          sink.next(value);\n        },\n        error: sink.error,\n        complete: function complete() {\n          if (hasValue) {\n            sink.complete();\n          } else {\n            current = alternate.subscribe(sink);\n          }\n        }\n      });\n\n      return function () {\n        current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Observable's primary API: returns an unsubscribable Subscription to the\n   * source of this Observable.\n   *\n   * Note: A sink may be passed directly to .subscribe() as its observer,\n   * allowing for easily composing Observables.\n   */\n  ;\n\n  _proto.subscribe = function subscribe(observer) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed observers.\n      if (!observer || typeof observer !== 'object') {\n        throw new Error('Observer must be an Object with callbacks: ' + String(observer));\n      }\n    }\n\n    return _subscribe(this._source, observer);\n  }\n  /**\n   * Returns a new Observerable where each value has been transformed by\n   * the mapping function.\n   */\n  ;\n\n  _proto.map = function map(fn) {\n    var _this6 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this6.subscribe({\n        complete: sink.complete,\n        error: sink.error,\n        next: function next(value) {\n          try {\n            var mapValue = fn(value);\n            sink.next(mapValue);\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable where each value is replaced with a new Observable\n   * by the mapping function, the results of which returned as a single\n   * merged Observable.\n   */\n  ;\n\n  _proto.mergeMap = function mergeMap(fn) {\n    var _this7 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscriptions = [];\n\n      function start(subscription) {\n        this._sub = subscription;\n        subscriptions.push(subscription);\n      }\n\n      function complete() {\n        subscriptions.splice(subscriptions.indexOf(this._sub), 1);\n\n        if (subscriptions.length === 0) {\n          sink.complete();\n        }\n      }\n\n      _this7.subscribe({\n        start: start,\n        next: function next(value) {\n          try {\n            if (!sink.closed) {\n              RelayObservable.from(fn(value)).subscribe({\n                start: start,\n                next: sink.next,\n                error: sink.error,\n                complete: complete\n              });\n            }\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        },\n        error: sink.error,\n        complete: complete\n      });\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n        subscriptions.length = 0;\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first mirrors this Observable, then when it\n   * completes, waits for `pollInterval` milliseconds before re-subscribing to\n   * this Observable again, looping in this manner until unsubscribed.\n   *\n   * The returned Observable never completes.\n   */\n  ;\n\n  _proto.poll = function poll(pollInterval) {\n    var _this8 = this;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof pollInterval !== 'number' || pollInterval <= 0) {\n        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);\n      }\n    }\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n      var timeout;\n\n      var poll = function poll() {\n        subscription = _this8.subscribe({\n          next: sink.next,\n          error: sink.error,\n          complete: function complete() {\n            timeout = setTimeout(poll, pollInterval);\n          }\n        });\n      };\n\n      poll();\n      return function () {\n        clearTimeout(timeout);\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a Promise which resolves when this Observable yields a first value\n   * or when it completes with no value.\n   *\n   * NOTE: The source Observable is *NOT* canceled when the returned Promise\n   * resolves. The Observable is always run to completion.\n   */\n  ;\n\n  _proto.toPromise = function toPromise() {\n    var _this9 = this;\n\n    return new Promise(function (resolve, reject) {\n      var resolved = false;\n\n      _this9.subscribe({\n        next: function next(val) {\n          if (!resolved) {\n            resolved = true;\n            resolve(val);\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  return RelayObservable;\n}(); // Use declarations to teach Flow how to check isObservable.\n\n\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';\n}\n\nfunction fromObservable(obj) {\n  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {\n    return obj.subscribe(sink);\n  });\n}\n\nfunction fromPromise(promise) {\n  return RelayObservable.create(function (sink) {\n    // Since sink methods do not throw, the resulting Promise can be ignored.\n    promise.then(function (value) {\n      sink.next(value);\n      sink.complete();\n    }, sink.error);\n  });\n}\n\nfunction fromValue(value) {\n  return RelayObservable.create(function (sink) {\n    sink.next(value);\n    sink.complete();\n  });\n}\n\nfunction _subscribe(source, observer) {\n  var closed = false;\n  var cleanup; // Ideally we would simply describe a `get closed()` method on the Sink and\n  // Subscription objects below, however not all flow environments we expect\n  // Relay to be used within will support property getters, and many minifier\n  // tools still do not support ES5 syntax. Instead, we can use defineProperty.\n\n  var withClosed = function withClosed(obj) {\n    return Object.defineProperty(obj, 'closed', {\n      get: function get() {\n        return closed;\n      }\n    });\n  };\n\n  function doCleanup() {\n    if (cleanup) {\n      if (cleanup.unsubscribe) {\n        cleanup.unsubscribe();\n      } else {\n        try {\n          cleanup();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n\n      cleanup = undefined;\n    }\n  } // Create a Subscription.\n\n\n  var subscription = withClosed({\n    unsubscribe: function unsubscribe() {\n      if (!closed) {\n        closed = true; // Tell Observer that unsubscribe was called.\n\n        try {\n          observer.unsubscribe && observer.unsubscribe(subscription);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // Tell Observer that observation is about to begin.\n\n  try {\n    observer.start && observer.start(subscription);\n  } catch (error) {\n    hostReportError(error, true\n    /* isUncaughtThrownError */\n    );\n  } // If closed already, don't bother creating a Sink.\n\n\n  if (closed) {\n    return subscription;\n  } // Create a Sink respecting subscription state and cleanup.\n\n\n  var sink = withClosed({\n    next: function next(value) {\n      if (!closed && observer.next) {\n        try {\n          observer.next(value);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n    },\n    error: function error(_error3, isUncaughtThrownError) {\n      if (closed || !observer.error) {\n        closed = true;\n        hostReportError(_error3, isUncaughtThrownError || false);\n        doCleanup();\n      } else {\n        closed = true;\n\n        try {\n          observer.error(_error3);\n        } catch (error2) {\n          hostReportError(error2, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    },\n    complete: function complete() {\n      if (!closed) {\n        closed = true;\n\n        try {\n          observer.complete && observer.complete();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // If anything goes wrong during observing the source, handle the error.\n\n  try {\n    cleanup = source(sink);\n  } catch (error) {\n    sink.error(error, true\n    /* isUncaughtThrownError */\n    );\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // Early runtime errors for ill-formed returned cleanup.\n    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {\n      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));\n    }\n  } // If closed before the source function existed, cleanup now.\n\n\n  if (closed) {\n    doCleanup();\n  }\n\n  return subscription;\n}\n\nfunction swallowError(_error, _isUncaughtThrownError) {// do nothing.\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  // Default implementation of HostReportErrors() in development builds.\n  // Can be replaced by the host application environment.\n  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {\n    if (typeof fail === 'function') {\n      // In test environments (Jest), fail() immediately fails the current test.\n      fail(String(error));\n    } else if (isUncaughtThrownError) {\n      // Rethrow uncaught thrown errors on the next frame to avoid breaking\n      // current logic.\n      setTimeout(function () {\n        throw error;\n      });\n    } else if (typeof console !== 'undefined') {\n      // Otherwise, log the unhandled error for visibility.\n      // eslint-disable-next-line no-console\n      console.error('RelayObservable: Unhandled Error', error);\n    }\n  });\n}\n\nmodule.exports = RelayObservable;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,mBAAD,CAAvB;AACA;AACA;AACA;AACA;;;AAGA,IAAIC,eAAe,GAAGC,YAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,eAAe,GAAG,aAAa,YAAY;EAC7CA,eAAe,CAACC,MAAhB,GAAyB,SAASA,MAAT,CAAgBC,MAAhB,EAAwB;IAC/C,OAAO,IAAIF,eAAJ,CAAoBE,MAApB,CAAP;EACD,CAFD,CAEE;EAFF;;EAKA,SAASF,eAAT,CAAyBE,MAAzB,EAAiC;IAC/B,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC;MACA,IAAI,CAACH,MAAD,IAAW,OAAOA,MAAP,KAAkB,UAAjC,EAA6C;QAC3C,MAAM,IAAII,KAAJ,CAAU,gCAAgCC,MAAM,CAACL,MAAD,CAAhD,CAAN;MACD;IACF;;IAED,KAAKM,OAAL,GAAeN,MAAf;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEF,eAAe,CAACS,gBAAhB,GAAmC,SAASA,gBAAT,CAA0BC,QAA1B,EAAoC;IACrEZ,eAAe,GAAGY,QAAlB;EACD;EACD;AACF;AACA;AACA;EANE;;EASAV,eAAe,CAACW,IAAhB,GAAuB,SAASA,IAAT,CAAcC,GAAd,EAAmB;IACxC,OAAOC,YAAY,CAACD,GAAD,CAAZ,GAAoBE,cAAc,CAACF,GAAD,CAAlC,GAA0ChB,SAAS,CAACgB,GAAD,CAAT,GAAiBG,WAAW,CAACH,GAAD,CAA5B,GAAoCI,SAAS,CAACJ,GAAD,CAA9F;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EATE;;EAYA,IAAIK,MAAM,GAAGjB,eAAe,CAACkB,SAA7B;;EAEAD,MAAM,CAAC,OAAD,CAAN,GAAkB,SAASE,MAAT,CAAgBC,EAAhB,EAAoB;IACpC,IAAIC,KAAK,GAAG,IAAZ;;IAEA,OAAOrB,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIC,YAAJ;;MAEAF,KAAK,CAACG,SAAN,CAAgB;QACdC,KAAK,EAAE,SAASA,KAAT,CAAeC,GAAf,EAAoB;UACzBH,YAAY,GAAGG,GAAf;QACD,CAHa;QAIdC,IAAI,EAAEL,IAAI,CAACK,IAJG;QAKdC,QAAQ,EAAEN,IAAI,CAACM,QALD;QAMdC,KAAK,EAAE,SAASA,KAAT,CAAeC,OAAf,EAAwB;UAC7B,IAAI;YACFV,EAAE,CAACU,OAAD,CAAF,CAAYN,SAAZ,CAAsB;cACpBC,KAAK,EAAE,SAASA,KAAT,CAAeC,GAAf,EAAoB;gBACzBH,YAAY,GAAGG,GAAf;cACD,CAHmB;cAIpBC,IAAI,EAAEL,IAAI,CAACK,IAJS;cAKpBC,QAAQ,EAAEN,IAAI,CAACM,QALK;cAMpBC,KAAK,EAAEP,IAAI,CAACO;YANQ,CAAtB;UAQD,CATD,CASE,OAAOE,MAAP,EAAe;YACfT,IAAI,CAACO,KAAL,CAAWE,MAAX,EAAmB;YACnB;YADA;UAGD;QACF;MArBa,CAAhB;;MAwBA,OAAO,YAAY;QACjB,OAAOR,YAAY,CAACS,WAAb,EAAP;MACD,CAFD;IAGD,CA9BM,CAAP;EA+BD;EACD;AACF;AACA;AACA;AACA;EAvCE;;EA0CAf,MAAM,CAACgB,MAAP,GAAgB,SAASA,MAAT,CAAgBN,IAAhB,EAAsB;IACpC,IAAIO,MAAM,GAAG,IAAb;;IAEA,OAAOlC,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIa,OAAJ;;MAEAD,MAAM,CAACV,SAAP,CAAiB;QACfC,KAAK,EAAE,SAASA,KAAT,CAAeF,YAAf,EAA6B;UAClCY,OAAO,GAAGZ,YAAV;QACD,CAHc;QAIfI,IAAI,EAAEL,IAAI,CAACK,IAJI;QAKfE,KAAK,EAAEP,IAAI,CAACO,KALG;QAMfD,QAAQ,EAAE,SAASA,QAAT,GAAoB;UAC5BO,OAAO,GAAGR,IAAI,CAACH,SAAL,CAAeF,IAAf,CAAV;QACD;MARc,CAAjB;;MAWA,OAAO,YAAY;QACjBa,OAAO,IAAIA,OAAO,CAACH,WAAR,EAAX;MACD,CAFD;IAGD,CAjBM,CAAP;EAkBD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAhCE;;EAmCAf,MAAM,CAAC,IAAD,CAAN,GAAe,SAASmB,GAAT,CAAaC,QAAb,EAAuB;IACpC,IAAIC,MAAM,GAAG,IAAb;;IAEA,OAAOtC,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIiB,IAAI,GAAG,SAASA,IAAT,CAAcC,MAAd,EAAsB;QAC/B,OAAO,YAAY;UACjB,IAAI;YACFH,QAAQ,CAACG,MAAD,CAAR,IAAoBH,QAAQ,CAACG,MAAD,CAAR,CAAiBC,KAAjB,CAAuBJ,QAAvB,EAAiCK,SAAjC,CAApB;UACD,CAFD,CAEE,OAAOb,KAAP,EAAc;YACd/B,eAAe,CAAC+B,KAAD,EAAQ;YACvB;YADe,CAAf;UAGD;;UAEDP,IAAI,CAACkB,MAAD,CAAJ,IAAgBlB,IAAI,CAACkB,MAAD,CAAJ,CAAaC,KAAb,CAAmBnB,IAAnB,EAAyBoB,SAAzB,CAAhB;QACD,CAVD;MAWD,CAZD;;MAcA,OAAOJ,MAAM,CAACd,SAAP,CAAiB;QACtBC,KAAK,EAAEc,IAAI,CAAC,OAAD,CADW;QAEtBZ,IAAI,EAAEY,IAAI,CAAC,MAAD,CAFY;QAGtBV,KAAK,EAAEU,IAAI,CAAC,OAAD,CAHW;QAItBX,QAAQ,EAAEW,IAAI,CAAC,UAAD,CAJQ;QAKtBP,WAAW,EAAEO,IAAI,CAAC,aAAD;MALK,CAAjB,CAAP;IAOD,CAtBM,CAAP;EAuBD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EAjCE;;EAoCAtB,MAAM,CAAC,SAAD,CAAN,GAAoB,SAAS0B,QAAT,CAAkBvB,EAAlB,EAAsB;IACxC,IAAIwB,MAAM,GAAG,IAAb;;IAEA,OAAO5C,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIC,YAAY,GAAGqB,MAAM,CAACpB,SAAP,CAAiBF,IAAjB,CAAnB;;MAEA,OAAO,YAAY;QACjBC,YAAY,CAACS,WAAb;QACAZ,EAAE;MACH,CAHD;IAID,CAPM,CAAP;EAQD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EArBE;;EAwBAH,MAAM,CAAC4B,OAAP,GAAiB,SAASA,OAAT,CAAiBC,SAAjB,EAA4B;IAC3C,IAAIC,MAAM,GAAG,IAAb;;IAEA,OAAO/C,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAI0B,QAAQ,GAAG,KAAf;;MAEA,IAAIb,OAAO,GAAGY,MAAM,CAACvB,SAAP,CAAiB;QAC7BG,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;UACzBD,QAAQ,GAAG,IAAX;UACA1B,IAAI,CAACK,IAAL,CAAUsB,KAAV;QACD,CAJ4B;QAK7BpB,KAAK,EAAEP,IAAI,CAACO,KALiB;QAM7BD,QAAQ,EAAE,SAASA,QAAT,GAAoB;UAC5B,IAAIoB,QAAJ,EAAc;YACZ1B,IAAI,CAACM,QAAL;UACD,CAFD,MAEO;YACLO,OAAO,GAAGW,SAAS,CAACtB,SAAV,CAAoBF,IAApB,CAAV;UACD;QACF;MAZ4B,CAAjB,CAAd;;MAeA,OAAO,YAAY;QACjBa,OAAO,CAACH,WAAR;MACD,CAFD;IAGD,CArBM,CAAP;EAsBD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EAhCE;;EAmCAf,MAAM,CAACO,SAAP,GAAmB,SAASA,SAAT,CAAmBa,QAAnB,EAA6B;IAC9C,IAAIlC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC;MACA,IAAI,CAACgC,QAAD,IAAa,OAAOA,QAAP,KAAoB,QAArC,EAA+C;QAC7C,MAAM,IAAI/B,KAAJ,CAAU,gDAAgDC,MAAM,CAAC8B,QAAD,CAAhE,CAAN;MACD;IACF;;IAED,OAAOa,UAAU,CAAC,KAAK1C,OAAN,EAAe6B,QAAf,CAAjB;EACD;EACD;AACF;AACA;AACA;EAbE;;EAgBApB,MAAM,CAACkC,GAAP,GAAa,SAASA,GAAT,CAAa/B,EAAb,EAAiB;IAC5B,IAAIgC,MAAM,GAAG,IAAb;;IAEA,OAAOpD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIC,YAAY,GAAG6B,MAAM,CAAC5B,SAAP,CAAiB;QAClCI,QAAQ,EAAEN,IAAI,CAACM,QADmB;QAElCC,KAAK,EAAEP,IAAI,CAACO,KAFsB;QAGlCF,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;UACzB,IAAI;YACF,IAAII,QAAQ,GAAGjC,EAAE,CAAC6B,KAAD,CAAjB;YACA3B,IAAI,CAACK,IAAL,CAAU0B,QAAV;UACD,CAHD,CAGE,OAAOxB,KAAP,EAAc;YACdP,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;YAClB;YADA;UAGD;QACF;MAZiC,CAAjB,CAAnB;;MAeA,OAAO,YAAY;QACjBN,YAAY,CAACS,WAAb;MACD,CAFD;IAGD,CAnBM,CAAP;EAoBD;EACD;AACF;AACA;AACA;AACA;EA5BE;;EA+BAf,MAAM,CAACqC,QAAP,GAAkB,SAASA,QAAT,CAAkBlC,EAAlB,EAAsB;IACtC,IAAImC,MAAM,GAAG,IAAb;;IAEA,OAAOvD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIkC,aAAa,GAAG,EAApB;;MAEA,SAAS/B,KAAT,CAAeF,YAAf,EAA6B;QAC3B,KAAKkC,IAAL,GAAYlC,YAAZ;QACAiC,aAAa,CAACE,IAAd,CAAmBnC,YAAnB;MACD;;MAED,SAASK,QAAT,GAAoB;QAClB4B,aAAa,CAACG,MAAd,CAAqBH,aAAa,CAACI,OAAd,CAAsB,KAAKH,IAA3B,CAArB,EAAuD,CAAvD;;QAEA,IAAID,aAAa,CAACK,MAAd,KAAyB,CAA7B,EAAgC;UAC9BvC,IAAI,CAACM,QAAL;QACD;MACF;;MAED2B,MAAM,CAAC/B,SAAP,CAAiB;QACfC,KAAK,EAAEA,KADQ;QAEfE,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;UACzB,IAAI;YACF,IAAI,CAAC3B,IAAI,CAACwC,MAAV,EAAkB;cAChB9D,eAAe,CAACW,IAAhB,CAAqBS,EAAE,CAAC6B,KAAD,CAAvB,EAAgCzB,SAAhC,CAA0C;gBACxCC,KAAK,EAAEA,KADiC;gBAExCE,IAAI,EAAEL,IAAI,CAACK,IAF6B;gBAGxCE,KAAK,EAAEP,IAAI,CAACO,KAH4B;gBAIxCD,QAAQ,EAAEA;cAJ8B,CAA1C;YAMD;UACF,CATD,CASE,OAAOC,KAAP,EAAc;YACdP,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;YAClB;YADA;UAGD;QACF,CAjBc;QAkBfA,KAAK,EAAEP,IAAI,CAACO,KAlBG;QAmBfD,QAAQ,EAAEA;MAnBK,CAAjB;;MAsBA,OAAO,YAAY;QACjB4B,aAAa,CAACO,OAAd,CAAsB,UAAUrC,GAAV,EAAe;UACnC,OAAOA,GAAG,CAACM,WAAJ,EAAP;QACD,CAFD;QAGAwB,aAAa,CAACK,MAAd,GAAuB,CAAvB;MACD,CALD;IAMD,CA5CM,CAAP;EA6CD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EAvDE;;EA0DA5C,MAAM,CAAC+C,IAAP,GAAc,SAASA,IAAT,CAAcC,YAAd,EAA4B;IACxC,IAAIC,MAAM,GAAG,IAAb;;IAEA,IAAI/D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC,IAAI,OAAO4D,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,IAAI,CAAxD,EAA2D;QACzD,MAAM,IAAI3D,KAAJ,CAAU,iEAAiE2D,YAA3E,CAAN;MACD;IACF;;IAED,OAAOjE,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;MAC5C,IAAIC,YAAJ;MACA,IAAI4C,OAAJ;;MAEA,IAAIH,IAAI,GAAG,SAASA,IAAT,GAAgB;QACzBzC,YAAY,GAAG2C,MAAM,CAAC1C,SAAP,CAAiB;UAC9BG,IAAI,EAAEL,IAAI,CAACK,IADmB;UAE9BE,KAAK,EAAEP,IAAI,CAACO,KAFkB;UAG9BD,QAAQ,EAAE,SAASA,QAAT,GAAoB;YAC5BuC,OAAO,GAAGC,UAAU,CAACJ,IAAD,EAAOC,YAAP,CAApB;UACD;QAL6B,CAAjB,CAAf;MAOD,CARD;;MAUAD,IAAI;MACJ,OAAO,YAAY;QACjBK,YAAY,CAACF,OAAD,CAAZ;QACA5C,YAAY,CAACS,WAAb;MACD,CAHD;IAID,CAnBM,CAAP;EAoBD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EApCE;;EAuCAf,MAAM,CAACqD,SAAP,GAAmB,SAASA,SAAT,GAAqB;IACtC,IAAIC,MAAM,GAAG,IAAb;;IAEA,OAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;MAC5C,IAAIC,QAAQ,GAAG,KAAf;;MAEAJ,MAAM,CAAC/C,SAAP,CAAiB;QACfG,IAAI,EAAE,SAASA,IAAT,CAAciD,GAAd,EAAmB;UACvB,IAAI,CAACD,QAAL,EAAe;YACbA,QAAQ,GAAG,IAAX;YACAF,OAAO,CAACG,GAAD,CAAP;UACD;QACF,CANc;QAOf/C,KAAK,EAAE6C,MAPQ;QAQf9C,QAAQ,EAAE6C;MARK,CAAjB;IAUD,CAbM,CAAP;EAcD,CAjBD;;EAmBA,OAAOzE,eAAP;AACD,CAlZkC,EAAnC,C,CAkZK;;;AAGL,SAASa,YAAT,CAAsBD,GAAtB,EAA2B;EACzB,OAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,IAA2C,OAAOA,GAAG,CAACY,SAAX,KAAyB,UAA3E;AACD;;AAED,SAASV,cAAT,CAAwBF,GAAxB,EAA6B;EAC3B,OAAOA,GAAG,YAAYZ,eAAf,GAAiCY,GAAjC,GAAuCZ,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;IACnF,OAAOV,GAAG,CAACY,SAAJ,CAAcF,IAAd,CAAP;EACD,CAF6C,CAA9C;AAGD;;AAED,SAASP,WAAT,CAAqB8D,OAArB,EAA8B;EAC5B,OAAO7E,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;IAC5C;IACAuD,OAAO,CAACC,IAAR,CAAa,UAAU7B,KAAV,EAAiB;MAC5B3B,IAAI,CAACK,IAAL,CAAUsB,KAAV;MACA3B,IAAI,CAACM,QAAL;IACD,CAHD,EAGGN,IAAI,CAACO,KAHR;EAID,CANM,CAAP;AAOD;;AAED,SAASb,SAAT,CAAmBiC,KAAnB,EAA0B;EACxB,OAAOjD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;IAC5CA,IAAI,CAACK,IAAL,CAAUsB,KAAV;IACA3B,IAAI,CAACM,QAAL;EACD,CAHM,CAAP;AAID;;AAED,SAASsB,UAAT,CAAoBhD,MAApB,EAA4BmC,QAA5B,EAAsC;EACpC,IAAIyB,MAAM,GAAG,KAAb;EACA,IAAIiB,OAAJ,CAFoC,CAEvB;EACb;EACA;EACA;;EAEA,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBpE,GAApB,EAAyB;IACxC,OAAOqE,MAAM,CAACC,cAAP,CAAsBtE,GAAtB,EAA2B,QAA3B,EAAqC;MAC1CuE,GAAG,EAAE,SAASA,GAAT,GAAe;QAClB,OAAOrB,MAAP;MACD;IAHyC,CAArC,CAAP;EAKD,CAND;;EAQA,SAASsB,SAAT,GAAqB;IACnB,IAAIL,OAAJ,EAAa;MACX,IAAIA,OAAO,CAAC/C,WAAZ,EAAyB;QACvB+C,OAAO,CAAC/C,WAAR;MACD,CAFD,MAEO;QACL,IAAI;UACF+C,OAAO;QACR,CAFD,CAEE,OAAOlD,KAAP,EAAc;UACd/B,eAAe,CAAC+B,KAAD,EAAQ;UACvB;UADe,CAAf;QAGD;MACF;;MAEDkD,OAAO,GAAGM,SAAV;IACD;EACF,CA/BmC,CA+BlC;;;EAGF,IAAI9D,YAAY,GAAGyD,UAAU,CAAC;IAC5BhD,WAAW,EAAE,SAASA,WAAT,GAAuB;MAClC,IAAI,CAAC8B,MAAL,EAAa;QACXA,MAAM,GAAG,IAAT,CADW,CACI;;QAEf,IAAI;UACFzB,QAAQ,CAACL,WAAT,IAAwBK,QAAQ,CAACL,WAAT,CAAqBT,YAArB,CAAxB;QACD,CAFD,CAEE,OAAOM,KAAP,EAAc;UACd/B,eAAe,CAAC+B,KAAD,EAAQ;UACvB;UADe,CAAf;QAGD,CAND,SAMU;UACRuD,SAAS;QACV;MACF;IACF;EAf2B,CAAD,CAA7B,CAlCoC,CAkDhC;;EAEJ,IAAI;IACF/C,QAAQ,CAACZ,KAAT,IAAkBY,QAAQ,CAACZ,KAAT,CAAeF,YAAf,CAAlB;EACD,CAFD,CAEE,OAAOM,KAAP,EAAc;IACd/B,eAAe,CAAC+B,KAAD,EAAQ;IACvB;IADe,CAAf;EAGD,CA1DmC,CA0DlC;;;EAGF,IAAIiC,MAAJ,EAAY;IACV,OAAOvC,YAAP;EACD,CA/DmC,CA+DlC;;;EAGF,IAAID,IAAI,GAAG0D,UAAU,CAAC;IACpBrD,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;MACzB,IAAI,CAACa,MAAD,IAAWzB,QAAQ,CAACV,IAAxB,EAA8B;QAC5B,IAAI;UACFU,QAAQ,CAACV,IAAT,CAAcsB,KAAd;QACD,CAFD,CAEE,OAAOpB,KAAP,EAAc;UACd/B,eAAe,CAAC+B,KAAD,EAAQ;UACvB;UADe,CAAf;QAGD;MACF;IACF,CAXmB;IAYpBA,KAAK,EAAE,SAASA,KAAT,CAAeyD,OAAf,EAAwBC,qBAAxB,EAA+C;MACpD,IAAIzB,MAAM,IAAI,CAACzB,QAAQ,CAACR,KAAxB,EAA+B;QAC7BiC,MAAM,GAAG,IAAT;QACAhE,eAAe,CAACwF,OAAD,EAAUC,qBAAqB,IAAI,KAAnC,CAAf;QACAH,SAAS;MACV,CAJD,MAIO;QACLtB,MAAM,GAAG,IAAT;;QAEA,IAAI;UACFzB,QAAQ,CAACR,KAAT,CAAeyD,OAAf;QACD,CAFD,CAEE,OAAOvD,MAAP,EAAe;UACfjC,eAAe,CAACiC,MAAD,EAAS;UACxB;UADe,CAAf;QAGD,CAND,SAMU;UACRqD,SAAS;QACV;MACF;IACF,CA9BmB;IA+BpBxD,QAAQ,EAAE,SAASA,QAAT,GAAoB;MAC5B,IAAI,CAACkC,MAAL,EAAa;QACXA,MAAM,GAAG,IAAT;;QAEA,IAAI;UACFzB,QAAQ,CAACT,QAAT,IAAqBS,QAAQ,CAACT,QAAT,EAArB;QACD,CAFD,CAEE,OAAOC,KAAP,EAAc;UACd/B,eAAe,CAAC+B,KAAD,EAAQ;UACvB;UADe,CAAf;QAGD,CAND,SAMU;UACRuD,SAAS;QACV;MACF;IACF;EA7CmB,CAAD,CAArB,CAlEoC,CAgHhC;;EAEJ,IAAI;IACFL,OAAO,GAAG7E,MAAM,CAACoB,IAAD,CAAhB;EACD,CAFD,CAEE,OAAOO,KAAP,EAAc;IACdP,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;IAClB;IADA;EAGD;;EAED,IAAI1B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACA,IAAI0E,OAAO,KAAKM,SAAZ,IAAyB,OAAON,OAAP,KAAmB,UAA5C,KAA2D,CAACA,OAAD,IAAY,OAAOA,OAAO,CAAC/C,WAAf,KAA+B,UAAtG,CAAJ,EAAuH;MACrH,MAAM,IAAI1B,KAAJ,CAAU,uDAAuDC,MAAM,CAACwE,OAAD,CAAvE,CAAN;IACD;EACF,CA/HmC,CA+HlC;;;EAGF,IAAIjB,MAAJ,EAAY;IACVsB,SAAS;EACV;;EAED,OAAO7D,YAAP;AACD;;AAED,SAASxB,YAAT,CAAsByF,MAAtB,EAA8BC,sBAA9B,EAAsD,CAAC;AACtD;;AAED,IAAItF,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;EACzC;EACA;EACAL,eAAe,CAACS,gBAAhB,CAAiC,UAAUoB,KAAV,EAAiB0D,qBAAjB,EAAwC;IACvE,IAAI,OAAOG,IAAP,KAAgB,UAApB,EAAgC;MAC9B;MACAA,IAAI,CAACnF,MAAM,CAACsB,KAAD,CAAP,CAAJ;IACD,CAHD,MAGO,IAAI0D,qBAAJ,EAA2B;MAChC;MACA;MACAnB,UAAU,CAAC,YAAY;QACrB,MAAMvC,KAAN;MACD,CAFS,CAAV;IAGD,CANM,MAMA,IAAI,OAAO8D,OAAP,KAAmB,WAAvB,EAAoC;MACzC;MACA;MACAA,OAAO,CAAC9D,KAAR,CAAc,kCAAd,EAAkDA,KAAlD;IACD;EACF,CAfD;AAgBD;;AAED+D,MAAM,CAACC,OAAP,GAAiB7F,eAAjB"},"metadata":{},"sourceType":"script"}