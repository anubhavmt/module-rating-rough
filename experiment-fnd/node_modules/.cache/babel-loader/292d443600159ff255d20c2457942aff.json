{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _require = require('../multi-actor-environment/ActorIdentifier'),\n    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,\n    assertInternalActorIndentifier = _require.assertInternalActorIndentifier;\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar DataChecker = require('./DataChecker');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require2 = require('./RelayStoreUtils'),\n    ROOT_ID = _require2.ROOT_ID,\n    ROOT_TYPE = _require2.ROOT_TYPE;\n\nvar _require3 = require('./ResolverCache'),\n    RecordResolverCache = _require3.RecordResolverCache;\n\nvar invariant = require('invariant');\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    }); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._resolverCache = new RecordResolverCache(function () {\n      return _this._getMutableRecordSource();\n    });\n    this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto._getMutableRecordSource = function _getMutableRecordSource() {\n    var _this$_optimisticSour2;\n\n    return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;\n\n    var selector = operation.root;\n\n    var source = this._getMutableRecordSource();\n\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occurred.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector, this._resolverCache);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    if (RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n      // When a record is updated, we need to also handle records that depend on it,\n      // specifically Relay Resolver result records containing results based on the\n      // updated records. This both adds to updatedRecordIDs and invalidates any\n      // cached data as needed.\n      this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var target = this._getMutableRecordSource();\n\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  };\n\n  _proto.getEpoch = function getEpoch() {\n    return this._currentWriteEpoch;\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;","map":{"version":3,"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_defineProperty2","_require","INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE","assertInternalActorIndentifier","deepFreeze","RelayFeatureFlags","resolveImmediate","DataChecker","defaultGetDataID","RelayModernRecord","RelayOptimisticRecordSource","RelayReader","RelayReferenceMarker","RelayStoreReactFlightUtils","RelayStoreSubscriptions","RelayStoreUtils","_require2","ROOT_ID","ROOT_TYPE","_require3","RecordResolverCache","invariant","DEFAULT_RELEASE_BUFFER_SIZE","RelayModernStore","source","options","_this","_options$gcReleaseBuf","_options$gcScheduler","_options$getDataID","_options$log","_options$operationLoa","_gcRun","next","done","_gcScheduler","_gcStep","process","env","NODE_ENV","storeIDs","getRecordIDs","ii","length","record","get","freeze","_currentWriteEpoch","_gcHoldCounter","_gcReleaseBufferSize","gcReleaseBufferSize","gcScheduler","_getDataID","getDataID","_globalInvalidationEpoch","_invalidationSubscriptions","Set","_invalidatedRecordIDs","__log","log","_queryCacheExpirationTime","queryCacheExpirationTime","_operationLoader","operationLoader","_optimisticSource","_recordSource","_releaseBuffer","_roots","Map","_shouldScheduleGC","_resolverCache","_getMutableRecordSource","_storeSubscriptions","_updatedRecordIDs","_shouldProcessClientComponents","shouldProcessClientComponents","initializeRecordSource","_proto","prototype","getSource","_this$_optimisticSour","_this$_optimisticSour2","check","operation","_options$handlers","_options$getSourceFor","_options$getTargetFor","_options$defaultActor","selector","root","globalInvalidationEpoch","rootEntry","request","identifier","operationLastWrittenAt","epoch","status","handlers","getSourceForActor","actorIdentifier","getTargetForActor","operationAvailability","defaultActorIdentifier","getAvailabilityStatus","fetchTime","retain","_this2","id","disposed","dispose","refCount","rootEntryIsStale","Date","now","scheduleGC","push","_id","shift","filter","set","lookup","snapshot","read","notify","sourceOperation","invalidateStore","_this3","name","ENABLE_RELAY_RESOLVERS","invalidateDataIDs","updatedOwners","updateSubscriptions","forEach","subscription","_updateInvalidationSubscription","updatedRecordIDs","invalidatedRecordIDs","clear","node","params","operationKind","temporaryRootEntry","publish","idsMarkedForInvalidation","target","updateTargetFromSource","optimistic","subscribe","callback","holdGC","_this4","toJSON","getEpoch","__getUpdatedRecordIDs","lookupInvalidationState","dataIDs","_this5","invalidations","dataID","_RelayModernRecord$ge","getInvalidationEpoch","checkInvalidationState","prevInvalidationState","latestInvalidationState","currentInvalidations","prevInvalidations","_iterator","_step","s","n","value","err","e","f","subscribeToInvalidationState","invalidationState","_this6","add","invalidatedStore","_this7","isSubscribedToInvalidatedIDs","some","has","snapshotSubscriptions","create","restore","restoreSubscriptions","_collect","__gc","gcRun","top","startEpoch","references","_iterator2","values","_step2","mark","size","remove","rootRecord","currentWriteEpoch","targetRecord","sourceRecord","nextRecord","clone","setValue","INVALIDATED_AT_KEY","getType","REACT_FLIGHT_TYPE_NAME","update","operationFetchTime","mostRecentlyInvalidatedAt","isStale","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/RelayModernStore.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _require = require('../multi-actor-environment/ActorIdentifier'),\n    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,\n    assertInternalActorIndentifier = _require.assertInternalActorIndentifier;\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar DataChecker = require('./DataChecker');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require2 = require('./RelayStoreUtils'),\n    ROOT_ID = _require2.ROOT_ID,\n    ROOT_TYPE = _require2.ROOT_TYPE;\n\nvar _require3 = require('./ResolverCache'),\n    RecordResolverCache = _require3.RecordResolverCache;\n\nvar invariant = require('invariant');\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    });\n\n    // Prevent mutation of a record from outside the store.\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._resolverCache = new RecordResolverCache(function () {\n      return _this._getMutableRecordSource();\n    });\n    this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto._getMutableRecordSource = function _getMutableRecordSource() {\n    var _this$_optimisticSour2;\n\n    return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;\n\n    var selector = operation.root;\n\n    var source = this._getMutableRecordSource();\n\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occurred.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector, this._resolverCache);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    if (RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n      // When a record is updated, we need to also handle records that depend on it,\n      // specifically Relay Resolver result records containing results based on the\n      // updated records. This both adds to updatedRecordIDs and invalidates any\n      // cached data as needed.\n      this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var target = this._getMutableRecordSource();\n\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  };\n\n  _proto.getEpoch = function getEpoch() {\n    return this._currentWriteEpoch;\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;"],"mappings":"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"},"metadata":{},"sourceType":"script"}