{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var currentNetworkSubscription = networkSubscription;\n  var suspenseResource = new SuspenseResource(function (environment) {\n    var retention = environment.retain(operation);\n    return {\n      dispose: function dispose() {\n        // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n        if (isLiveQuery && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n\n        retention.dispose();\n        onDispose(cacheEntry);\n      }\n    };\n  });\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      return suspenseResource.temporaryRetain(environment);\n    },\n    permanentRetain: function permanentRetain(environment) {\n      return suspenseResource.permanentRetain(environment);\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      suspenseResource.releaseTemporaryRetain();\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender; // Different definitions for Promise in our repos can cause this variable\n    // to cause errors when synced elsewhere\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%s` returned an error: `%s`.', operation.fragment.node.name, String(_error.message)) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","LRUCache","SuspenseResource","invariant","_require","isPromise","warning","CACHE_CAPACITY","DEFAULT_FETCH_POLICY","WEAKMAP_SUPPORTED","WeakMap","operationIsLiveQuery","operation","request","node","params","metadata","live","undefined","getQueryCacheIdentifier","environment","maybeFetchPolicy","maybeRenderPolicy","cacheBreaker","fetchPolicy","renderPolicy","UNSTABLE_getDefaultRenderPolicy","cacheIdentifier","concat","identifier","getQueryResult","rootFragmentRef","__id","fragment","dataID","__fragments","name","variables","__fragmentOwner","fragmentNode","fragmentRef","nextID","createCacheEntry","operationAvailability","value","networkSubscription","onDispose","isLiveQuery","currentValue","currentNetworkSubscription","suspenseResource","retention","retain","dispose","unsubscribe","cacheEntry","id","processedPayloadsCount","getValue","setValue","val","setNetworkSubscription","subscription","temporaryRetain","permanentRetain","releaseTemporaryRetain","QueryResourceImpl","_this","_cache","_environment","create","_proto","prototype","prepare","fetchObservable","observer","profilerContext","prepareWithIdentifier","get","temporaryRetainDisposable","entryWasCached","_fetchAndSaveQuery","observerUnsubscribe","cachedValue","__log","isPromiseCached","queryAvailability","Error","queryResult","_getOrCreateCacheEntry","disposable","resourceID","TESTS_ONLY__getCacheEntry","_clearCacheEntry","set","_this2","check","queryStatus","status","hasFullQuery","canPartialRender","shouldFetch","shouldAllowRender","resolveNetworkPromise","_cacheEntry","_queryResult","subscribe","start","observerStart","subscriptionWithConditionalCancelation","next","observerNext","snapshot","lookup","error","_error","process","env","NODE_ENV","String","message","observerError","complete","observerComplete","_cacheEntry2","networkPromise","Promise","resolve","displayName","createQueryResource","dataResources","Map","getQueryResourceForEnvironment","cached","newDataResource","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/QueryResource.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var currentNetworkSubscription = networkSubscription;\n  var suspenseResource = new SuspenseResource(function (environment) {\n    var retention = environment.retain(operation);\n    return {\n      dispose: function dispose() {\n        // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n        if (isLiveQuery && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n\n        retention.dispose();\n        onDispose(cacheEntry);\n      }\n    };\n  });\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      return suspenseResource.temporaryRetain(environment);\n    },\n    permanentRetain: function permanentRetain(environment) {\n      return suspenseResource.permanentRetain(environment);\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      suspenseResource.releaseTemporaryRetain();\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender; // Different definitions for Promise in our repos can cause this variable\n    // to cause errors when synced elsewhere\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%s` returned an error: `%s`.', operation.fragment.node.name, String(_error.message)) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}