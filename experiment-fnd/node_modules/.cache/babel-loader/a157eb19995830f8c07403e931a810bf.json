{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('react'),\n    useCallback = _require.useCallback,\n    useEffect = _require.useEffect,\n    useRef = _require.useRef;\n/**\n * This hook returns a mutable React ref that holds the value of whether a\n * fetch request is in flight. The reason this is a mutable ref instead of\n * state is because we don't actually want to trigger an update when this\n * changes, but instead synchronously keep track of whether the network request\n * is in flight, for example in order to bail out of a request if one is\n * already in flight. If this was state, due to the nature of concurrent\n * updates, this value wouldn't be in sync with when the request is actually\n * in flight.\n * The additional functions returned by this Hook can be used to mutate\n * the ref.\n */\n\n\nfunction useFetchTrackingRef() {\n  var subscriptionRef = useRef(null);\n  var isFetchingRef = useRef(false);\n  var disposeFetch = useCallback(function () {\n    if (subscriptionRef.current != null) {\n      subscriptionRef.current.unsubscribe();\n      subscriptionRef.current = null;\n    }\n\n    isFetchingRef.current = false;\n  }, []);\n  var startFetch = useCallback(function (subscription) {\n    subscriptionRef.current = subscription;\n    isFetchingRef.current = true;\n  }, []);\n  var completeFetch = useCallback(function () {\n    subscriptionRef.current = null;\n    isFetchingRef.current = false;\n  }, []); // Dipose of ongoing fetch on unmount\n\n  useEffect(function () {\n    return disposeFetch;\n  }, [disposeFetch]);\n  return {\n    isFetchingRef: isFetchingRef,\n    startFetch: startFetch,\n    disposeFetch: disposeFetch,\n    completeFetch: completeFetch\n  };\n}\n\nmodule.exports = useFetchTrackingRef;","map":{"version":3,"names":["_require","require","useCallback","useEffect","useRef","useFetchTrackingRef","subscriptionRef","isFetchingRef","disposeFetch","current","unsubscribe","startFetch","subscription","completeFetch","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('react'),\n    useCallback = _require.useCallback,\n    useEffect = _require.useEffect,\n    useRef = _require.useRef;\n/**\n * This hook returns a mutable React ref that holds the value of whether a\n * fetch request is in flight. The reason this is a mutable ref instead of\n * state is because we don't actually want to trigger an update when this\n * changes, but instead synchronously keep track of whether the network request\n * is in flight, for example in order to bail out of a request if one is\n * already in flight. If this was state, due to the nature of concurrent\n * updates, this value wouldn't be in sync with when the request is actually\n * in flight.\n * The additional functions returned by this Hook can be used to mutate\n * the ref.\n */\n\n\nfunction useFetchTrackingRef() {\n  var subscriptionRef = useRef(null);\n  var isFetchingRef = useRef(false);\n  var disposeFetch = useCallback(function () {\n    if (subscriptionRef.current != null) {\n      subscriptionRef.current.unsubscribe();\n      subscriptionRef.current = null;\n    }\n\n    isFetchingRef.current = false;\n  }, []);\n  var startFetch = useCallback(function (subscription) {\n    subscriptionRef.current = subscription;\n    isFetchingRef.current = true;\n  }, []);\n  var completeFetch = useCallback(function () {\n    subscriptionRef.current = null;\n    isFetchingRef.current = false;\n  }, []); // Dipose of ongoing fetch on unmount\n\n  useEffect(function () {\n    return disposeFetch;\n  }, [disposeFetch]);\n  return {\n    isFetchingRef: isFetchingRef,\n    startFetch: startFetch,\n    disposeFetch: disposeFetch,\n    completeFetch: completeFetch\n  };\n}\n\nmodule.exports = useFetchTrackingRef;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,OAAD,CAAtB;AAAA,IACIC,WAAW,GAAGF,QAAQ,CAACE,WAD3B;AAAA,IAEIC,SAAS,GAAGH,QAAQ,CAACG,SAFzB;AAAA,IAGIC,MAAM,GAAGJ,QAAQ,CAACI,MAHtB;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,mBAAT,GAA+B;EAC7B,IAAIC,eAAe,GAAGF,MAAM,CAAC,IAAD,CAA5B;EACA,IAAIG,aAAa,GAAGH,MAAM,CAAC,KAAD,CAA1B;EACA,IAAII,YAAY,GAAGN,WAAW,CAAC,YAAY;IACzC,IAAII,eAAe,CAACG,OAAhB,IAA2B,IAA/B,EAAqC;MACnCH,eAAe,CAACG,OAAhB,CAAwBC,WAAxB;MACAJ,eAAe,CAACG,OAAhB,GAA0B,IAA1B;IACD;;IAEDF,aAAa,CAACE,OAAd,GAAwB,KAAxB;EACD,CAP6B,EAO3B,EAP2B,CAA9B;EAQA,IAAIE,UAAU,GAAGT,WAAW,CAAC,UAAUU,YAAV,EAAwB;IACnDN,eAAe,CAACG,OAAhB,GAA0BG,YAA1B;IACAL,aAAa,CAACE,OAAd,GAAwB,IAAxB;EACD,CAH2B,EAGzB,EAHyB,CAA5B;EAIA,IAAII,aAAa,GAAGX,WAAW,CAAC,YAAY;IAC1CI,eAAe,CAACG,OAAhB,GAA0B,IAA1B;IACAF,aAAa,CAACE,OAAd,GAAwB,KAAxB;EACD,CAH8B,EAG5B,EAH4B,CAA/B,CAf6B,CAkBrB;;EAERN,SAAS,CAAC,YAAY;IACpB,OAAOK,YAAP;EACD,CAFQ,EAEN,CAACA,YAAD,CAFM,CAAT;EAGA,OAAO;IACLD,aAAa,EAAEA,aADV;IAELI,UAAU,EAAEA,UAFP;IAGLH,YAAY,EAAEA,YAHT;IAILK,aAAa,EAAEA;EAJV,CAAP;AAMD;;AAEDC,MAAM,CAACC,OAAP,GAAiBV,mBAAjB"},"metadata":{},"sourceType":"script"}