{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar _require = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require2 = require('relay-runtime'),\n    RelayFeatureFlags = _require2.RelayFeatureFlags,\n    _require2$__internal = _require2.__internal,\n    fetchQuery = _require2$__internal.fetchQuery,\n    getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest,\n    createOperationDescriptor = _require2.createOperationDescriptor,\n    getFragmentIdentifier = _require2.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,\n    getSelector = _require2.getSelector,\n    getVariablesFromFragment = _require2.getVariablesFromFragment,\n    handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors,\n    isPromise = _require2.isPromise,\n    recycleNodesInto = _require2.recycleNodesInto;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function'; // TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\n\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction hasMissingClientEdges(snapshot) {\n  var _snapshot$missingClie, _snapshot$missingClie2;\n\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      var _s$missingClientEdges, _s$missingClientEdges2;\n\n      return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;\n    });\n  }\n\n  return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;\n}\n\nfunction missingLiveResolverFields(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.map(function (s) {\n      return s.missingLiveResolverFields;\n    }).filter(Boolean).flat();\n  }\n\n  return snapshot.missingLiveResolverFields;\n}\n\nfunction singularOrPluralForEach(snapshot, f) {\n  if (Array.isArray(snapshot)) {\n    snapshot.forEach(f);\n  } else {\n    f(snapshot);\n  }\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n/**\n * The purpose of this cache is to allow information to be passed from an\n * initial read which suspends through to the commit that follows a subsequent\n * successful read. Specifically, the QueryResource result for the data fetch\n * is passed through so that that query can be retained on commit.\n */\n\n\nvar ClientEdgeQueryResultsCache = /*#__PURE__*/function () {\n  function ClientEdgeQueryResultsCache(environment) {\n    (0, _defineProperty2[\"default\"])(this, \"_cache\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_retainCounts\", new Map());\n    this._environment = environment;\n  }\n\n  var _proto = ClientEdgeQueryResultsCache.prototype;\n\n  _proto.get = function get(fragmentIdentifier) {\n    var _this$_cache$get$, _this$_cache$get;\n\n    return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : undefined;\n  };\n\n  _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value) {\n    var _this = this;\n\n    var existing = this._cache.get(fragmentIdentifier);\n\n    if (!existing) {\n      var suspenseResource = new SuspenseResource(function () {\n        return _this._retain(fragmentIdentifier);\n      });\n\n      this._cache.set(fragmentIdentifier, [value, suspenseResource]);\n\n      suspenseResource.temporaryRetain(this._environment);\n    } else {\n      var existingResults = existing[0],\n          _suspenseResource = existing[1];\n      value.forEach(function (queryResult) {\n        existingResults.push(queryResult);\n      });\n\n      _suspenseResource.temporaryRetain(this._environment);\n    }\n  };\n\n  _proto._retain = function _retain(id) {\n    var _this2 = this;\n\n    var _this$_retainCounts$g;\n\n    var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;\n\n    this._retainCounts.set(id, retainCount);\n\n    return {\n      dispose: function dispose() {\n        var _this$_retainCounts$g2;\n\n        var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;\n\n        if (newRetainCount > 0) {\n          _this2._retainCounts.set(id, newRetainCount);\n        } else {\n          _this2._retainCounts[\"delete\"](id);\n\n          _this2._cache[\"delete\"](id);\n        }\n      }\n    };\n  };\n\n  return ClientEdgeQueryResultsCache;\n}();\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);\n    }\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto2 = FragmentResourceImpl.prototype;\n\n  _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _this3 = this;\n\n    var _fragmentNode$metadat, _fragmentNode$metadat2, _missingLiveResolverF2, _missingLiveResolverF3;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      var _missingLiveResolverF;\n\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot && !((_missingLiveResolverF = missingLiveResolverFields(cachedValue.result.snapshot)) === null || _missingLiveResolverF === void 0 ? void 0 : _missingLiveResolverF.length)) {\n        this._handlePotentialSnapshotErrorsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._handlePotentialSnapshotErrorsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, there's two cases where we should\n    // suspend to await the data: First if any client edges were traversed where\n    // the destination record was missing data; in that case we initiate a query\n    // here to fetch the missing data. Second, there may already be a request\n    // in flight for the fragment's parent query, or for another operation that\n    //  may affect the parent's query data, such as a mutation or subscription.\n    // For any of these cases we can get a promise, which we will cache and\n    // suspend on.\n    // First, initiate a query for any client edges that were missing data:\n\n\n    var clientEdgeRequests = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true && hasMissingClientEdges(snapshot)) {\n      clientEdgeRequests = [];\n      var queryResource = getQueryResourceForEnvironment(this._environment);\n      var queryResults = [];\n      singularOrPluralForEach(snapshot, function (snap) {\n        var _snap$missingClientEd;\n\n        (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function (_ref) {\n          var _clientEdgeRequests;\n\n          var request = _ref.request,\n              clientEdgeDestinationID = _ref.clientEdgeDestinationID;\n\n          var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID),\n              queryResult = _this3$_performClient.queryResult,\n              requestDescriptor = _this3$_performClient.requestDescriptor;\n\n          queryResults.push(queryResult);\n          (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);\n        });\n      }); // Store the query so that it can be retained when our own fragment is\n      // subscribed to. This merges with any existing query results:\n\n      !(this._clientEdgeQueryResultsCache != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.') : invariant(false) : void 0;\n\n      this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);\n    }\n\n    var clientEdgePromises = [];\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {\n      clientEdgePromises = clientEdgeRequests.map(function (request) {\n        return getPromiseForActiveRequest(_this3._environment, request);\n      }).filter(Boolean);\n    } // Finally look for operations in flight for our parent query:\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise; // for refinement\n\n    var missingResolverFieldPromises = (_missingLiveResolverF2 = (_missingLiveResolverF3 = missingLiveResolverFields(snapshot)) === null || _missingLiveResolverF3 === void 0 ? void 0 : _missingLiveResolverF3.map(function (_ref2) {\n      var liveStateID = _ref2.liveStateID;\n      var store = environment.getStore(); // $FlowFixMe[prop-missing] This is expected to be a LiveResolverStore\n\n      return store.getLiveResolverPromise(liveStateID);\n    })) !== null && _missingLiveResolverF2 !== void 0 ? _missingLiveResolverF2 : [];\n\n    if (clientEdgePromises.length || missingResolverFieldPromises.length || isPromise(parentQueryPromiseResultPromise)) {\n      var _parentQueryPromiseRe, _clientEdgeRequests2;\n\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        // TODO! Attach information here about missing live resolver fields\n        pendingOperations: [].concat((0, _toConsumableArray2[\"default\"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2[\"default\"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))\n      });\n\n      var promises = [];\n\n      if (clientEdgePromises.length > 0) {\n        promises = promises.concat(clientEdgePromises);\n      }\n\n      if (missingResolverFieldPromises.length > 0) {\n        promises = promises.concat(missingResolverFieldPromises);\n      }\n\n      if (promises.length > 0) {\n        if (parentQueryPromiseResultPromise) {\n          promises.push(parentQueryPromiseResultPromise);\n        }\n\n        throw Promise.all(promises);\n      } // Note: we are re-throwing the `parentQueryPromiseResultPromise` here,\n      // because some of our suspense-related code is relying on the instance equality\n      // of thrown promises. See FragmentResource-test.js\n\n\n      if (parentQueryPromiseResultPromise) {\n        throw parentQueryPromiseResultPromise;\n      }\n    }\n\n    this._handlePotentialSnapshotErrorsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {\n    var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);\n    var variables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, originalVariables), {}, {\n      id: clientEdgeDestinationID // TODO should be a reserved name\n\n    });\n    var operation = createOperationDescriptor(request, variables, {} //  TODO cacheConfig should probably inherent from parent operation\n    );\n    var fetchObservable = fetchQuery(this._environment, operation);\n    var queryResult = queryResource.prepare(operation, fetchObservable // TODO should inherent render policy etc. from parent operation\n    );\n    return {\n      requestDescriptor: operation.request,\n      queryResult: queryResult\n    };\n  };\n\n  _proto2._handlePotentialSnapshotErrorsInSnapshot = function _handlePotentialSnapshotErrorsInSnapshot(snapshot) {\n    var _this4 = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        handlePotentialSnapshotErrors(_this4._environment, s.missingRequiredFields, s.relayResolverErrors);\n      });\n    } else {\n      handlePotentialSnapshotErrors(this._environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors);\n    }\n  };\n\n  _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto2.subscribe = function subscribe(fragmentResult, callback) {\n    var _this5 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var disposables = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        disposables.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      disposables.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this5._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;\n\n      var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : undefined;\n\n      if (clientEdgeQueryResults === null || clientEdgeQueryResults === void 0 ? void 0 : clientEdgeQueryResults.length) {\n        var queryResource = getQueryResourceForEnvironment(this._environment);\n        clientEdgeQueryResults.forEach(function (queryResult) {\n          disposables.push(queryResource.retain(queryResult));\n        });\n      }\n    }\n\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (s) {\n          return s.dispose();\n        });\n\n        _this5._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this6 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this6.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      missingClientEdges: currentSnapshot.missingClientEdges,\n      missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields,\n      relayResolverErrors: currentSnapshot.relayResolverErrors\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this7 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this7.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this8 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this8._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this8._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","_toConsumableArray2","LRUCache","_require","getQueryResourceForEnvironment","SuspenseResource","invariant","_require2","RelayFeatureFlags","_require2$__internal","__internal","fetchQuery","getPromiseForActiveRequest","createOperationDescriptor","getFragmentIdentifier","getPendingOperationsForFragment","getSelector","getVariablesFromFragment","handlePotentialSnapshotErrors","isPromise","recycleNodesInto","WEAKMAP_SUPPORTED","WeakMap","CACHE_CAPACITY","CONSTANT_READONLY_EMPTY_ARRAY","Object","freeze","isMissingData","snapshot","Array","isArray","some","s","hasMissingClientEdges","_snapshot$missingClie","_snapshot$missingClie2","_s$missingClientEdges","_s$missingClientEdges2","missingClientEdges","length","missingLiveResolverFields","map","filter","Boolean","flat","singularOrPluralForEach","f","forEach","getFragmentResult","cacheKey","storeEpoch","data","ClientEdgeQueryResultsCache","environment","Map","_environment","_proto","prototype","get","fragmentIdentifier","_this$_cache$get$","_this$_cache$get","_cache","undefined","recordQueryResults","value","_this","existing","suspenseResource","_retain","set","temporaryRetain","existingResults","_suspenseResource","queryResult","push","id","_this2","_this$_retainCounts$g","retainCount","_retainCounts","dispose","_this$_retainCounts$g2","newRetainCount","FragmentResourceImpl","create","ENABLE_CLIENT_EDGES","_clientEdgeQueryResultsCache","_proto2","read","fragmentNode","fragmentRef","componentDisplayName","fragmentKey","readWithIdentifier","_this3","_fragmentNode$metadat","_fragmentNode$metadat2","_missingLiveResolverF2","_missingLiveResolverF3","getStore","getEpoch","metadata","plural","process","env","NODE_ENV","concat","name","cachedValue","_missingLiveResolverF","kind","promise","__log","result","fragment","isRelayHooks","isPromiseCached","pendingOperations","_handlePotentialSnapshotErrorsInSnapshot","fragmentSelector","selectors","lookup","fragmentResult","clientEdgeRequests","hasClientEdges","queryResource","queryResults","snap","_snap$missingClientEd","_ref","_clientEdgeRequests","request","clientEdgeDestinationID","_this3$_performClient","_performClientEdgeQuery","requestDescriptor","clientEdgePromises","fragmentOwner","owner","parentQueryPromiseResult","_getAndSavePromiseForFragmentRequestInFlight","parentQueryPromiseResultPromise","missingResolverFieldPromises","_ref2","liveStateID","store","getLiveResolverPromise","_parentQueryPromiseRe","_clientEdgeRequests2","promises","Promise","all","originalVariables","variables","operation","fetchObservable","prepare","_this4","missingRequiredFields","relayResolverErrors","readSpec","fragmentNodes","fragmentRefs","_key","subscribe","callback","_this5","renderedSnapshot","_this$checkMissedUpda","checkMissedUpdates","didMissUpdates","currentSnapshot","disposables","idx","latestSnapshot","_updatePluralSnapshot","_this$_clientEdgeQuer","_this$_clientEdgeQuer2","clientEdgeQueryResults","retain","subscribeSpec","fragmentResults","_this6","keys","key","disposable","currentSnapshots","selector","renderData","currentData","updatedData","updatedCurrentSnapshot","seenRecords","checkMissedUpdatesSpec","_this7","_this8","pendingOperationsResult","networkPromise","then","error","displayName","baseSnapshots","_currentFragmentResul","currentFragmentResult","reportInvalidCachedData","node","nextSnapshots","nodeName","createFragmentResource","dataResources","getFragmentResourceForEnvironment","cached","newDataResource","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/FragmentResource.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar _require = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require2 = require('relay-runtime'),\n    RelayFeatureFlags = _require2.RelayFeatureFlags,\n    _require2$__internal = _require2.__internal,\n    fetchQuery = _require2$__internal.fetchQuery,\n    getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest,\n    createOperationDescriptor = _require2.createOperationDescriptor,\n    getFragmentIdentifier = _require2.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,\n    getSelector = _require2.getSelector,\n    getVariablesFromFragment = _require2.getVariablesFromFragment,\n    handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors,\n    isPromise = _require2.isPromise,\n    recycleNodesInto = _require2.recycleNodesInto;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction hasMissingClientEdges(snapshot) {\n  var _snapshot$missingClie, _snapshot$missingClie2;\n\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      var _s$missingClientEdges, _s$missingClientEdges2;\n\n      return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;\n    });\n  }\n\n  return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;\n}\n\nfunction missingLiveResolverFields(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.map(function (s) {\n      return s.missingLiveResolverFields;\n    }).filter(Boolean).flat();\n  }\n\n  return snapshot.missingLiveResolverFields;\n}\n\nfunction singularOrPluralForEach(snapshot, f) {\n  if (Array.isArray(snapshot)) {\n    snapshot.forEach(f);\n  } else {\n    f(snapshot);\n  }\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n/**\n * The purpose of this cache is to allow information to be passed from an\n * initial read which suspends through to the commit that follows a subsequent\n * successful read. Specifically, the QueryResource result for the data fetch\n * is passed through so that that query can be retained on commit.\n */\n\n\nvar ClientEdgeQueryResultsCache = /*#__PURE__*/function () {\n  function ClientEdgeQueryResultsCache(environment) {\n    (0, _defineProperty2[\"default\"])(this, \"_cache\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_retainCounts\", new Map());\n    this._environment = environment;\n  }\n\n  var _proto = ClientEdgeQueryResultsCache.prototype;\n\n  _proto.get = function get(fragmentIdentifier) {\n    var _this$_cache$get$, _this$_cache$get;\n\n    return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : undefined;\n  };\n\n  _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value) {\n    var _this = this;\n\n    var existing = this._cache.get(fragmentIdentifier);\n\n    if (!existing) {\n      var suspenseResource = new SuspenseResource(function () {\n        return _this._retain(fragmentIdentifier);\n      });\n\n      this._cache.set(fragmentIdentifier, [value, suspenseResource]);\n\n      suspenseResource.temporaryRetain(this._environment);\n    } else {\n      var existingResults = existing[0],\n          _suspenseResource = existing[1];\n      value.forEach(function (queryResult) {\n        existingResults.push(queryResult);\n      });\n\n      _suspenseResource.temporaryRetain(this._environment);\n    }\n  };\n\n  _proto._retain = function _retain(id) {\n    var _this2 = this;\n\n    var _this$_retainCounts$g;\n\n    var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;\n\n    this._retainCounts.set(id, retainCount);\n\n    return {\n      dispose: function dispose() {\n        var _this$_retainCounts$g2;\n\n        var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;\n\n        if (newRetainCount > 0) {\n          _this2._retainCounts.set(id, newRetainCount);\n        } else {\n          _this2._retainCounts[\"delete\"](id);\n\n          _this2._cache[\"delete\"](id);\n        }\n      }\n    };\n  };\n\n  return ClientEdgeQueryResultsCache;\n}();\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);\n    }\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto2 = FragmentResourceImpl.prototype;\n\n  _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _this3 = this;\n\n    var _fragmentNode$metadat, _fragmentNode$metadat2, _missingLiveResolverF2, _missingLiveResolverF3;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      var _missingLiveResolverF;\n\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot && !((_missingLiveResolverF = missingLiveResolverFields(cachedValue.result.snapshot)) === null || _missingLiveResolverF === void 0 ? void 0 : _missingLiveResolverF.length)) {\n        this._handlePotentialSnapshotErrorsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._handlePotentialSnapshotErrorsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, there's two cases where we should\n    // suspend to await the data: First if any client edges were traversed where\n    // the destination record was missing data; in that case we initiate a query\n    // here to fetch the missing data. Second, there may already be a request\n    // in flight for the fragment's parent query, or for another operation that\n    //  may affect the parent's query data, such as a mutation or subscription.\n    // For any of these cases we can get a promise, which we will cache and\n    // suspend on.\n    // First, initiate a query for any client edges that were missing data:\n\n\n    var clientEdgeRequests = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true && hasMissingClientEdges(snapshot)) {\n      clientEdgeRequests = [];\n      var queryResource = getQueryResourceForEnvironment(this._environment);\n      var queryResults = [];\n      singularOrPluralForEach(snapshot, function (snap) {\n        var _snap$missingClientEd;\n\n        (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function (_ref) {\n          var _clientEdgeRequests;\n\n          var request = _ref.request,\n              clientEdgeDestinationID = _ref.clientEdgeDestinationID;\n\n          var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID),\n              queryResult = _this3$_performClient.queryResult,\n              requestDescriptor = _this3$_performClient.requestDescriptor;\n\n          queryResults.push(queryResult);\n          (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);\n        });\n      }); // Store the query so that it can be retained when our own fragment is\n      // subscribed to. This merges with any existing query results:\n\n      !(this._clientEdgeQueryResultsCache != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.') : invariant(false) : void 0;\n\n      this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);\n    }\n\n    var clientEdgePromises = [];\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {\n      clientEdgePromises = clientEdgeRequests.map(function (request) {\n        return getPromiseForActiveRequest(_this3._environment, request);\n      }).filter(Boolean);\n    } // Finally look for operations in flight for our parent query:\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise; // for refinement\n\n    var missingResolverFieldPromises = (_missingLiveResolverF2 = (_missingLiveResolverF3 = missingLiveResolverFields(snapshot)) === null || _missingLiveResolverF3 === void 0 ? void 0 : _missingLiveResolverF3.map(function (_ref2) {\n      var liveStateID = _ref2.liveStateID;\n      var store = environment.getStore(); // $FlowFixMe[prop-missing] This is expected to be a LiveResolverStore\n\n      return store.getLiveResolverPromise(liveStateID);\n    })) !== null && _missingLiveResolverF2 !== void 0 ? _missingLiveResolverF2 : [];\n\n    if (clientEdgePromises.length || missingResolverFieldPromises.length || isPromise(parentQueryPromiseResultPromise)) {\n      var _parentQueryPromiseRe, _clientEdgeRequests2;\n\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        // TODO! Attach information here about missing live resolver fields\n        pendingOperations: [].concat((0, _toConsumableArray2[\"default\"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2[\"default\"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))\n      });\n\n      var promises = [];\n\n      if (clientEdgePromises.length > 0) {\n        promises = promises.concat(clientEdgePromises);\n      }\n\n      if (missingResolverFieldPromises.length > 0) {\n        promises = promises.concat(missingResolverFieldPromises);\n      }\n\n      if (promises.length > 0) {\n        if (parentQueryPromiseResultPromise) {\n          promises.push(parentQueryPromiseResultPromise);\n        }\n\n        throw Promise.all(promises);\n      } // Note: we are re-throwing the `parentQueryPromiseResultPromise` here,\n      // because some of our suspense-related code is relying on the instance equality\n      // of thrown promises. See FragmentResource-test.js\n\n\n      if (parentQueryPromiseResultPromise) {\n        throw parentQueryPromiseResultPromise;\n      }\n    }\n\n    this._handlePotentialSnapshotErrorsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {\n    var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);\n    var variables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, originalVariables), {}, {\n      id: clientEdgeDestinationID // TODO should be a reserved name\n\n    });\n    var operation = createOperationDescriptor(request, variables, {} //  TODO cacheConfig should probably inherent from parent operation\n    );\n    var fetchObservable = fetchQuery(this._environment, operation);\n    var queryResult = queryResource.prepare(operation, fetchObservable // TODO should inherent render policy etc. from parent operation\n    );\n    return {\n      requestDescriptor: operation.request,\n      queryResult: queryResult\n    };\n  };\n\n  _proto2._handlePotentialSnapshotErrorsInSnapshot = function _handlePotentialSnapshotErrorsInSnapshot(snapshot) {\n    var _this4 = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        handlePotentialSnapshotErrors(_this4._environment, s.missingRequiredFields, s.relayResolverErrors);\n      });\n    } else {\n      handlePotentialSnapshotErrors(this._environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors);\n    }\n  };\n\n  _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto2.subscribe = function subscribe(fragmentResult, callback) {\n    var _this5 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var disposables = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        disposables.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      disposables.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this5._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;\n\n      var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : undefined;\n\n      if (clientEdgeQueryResults === null || clientEdgeQueryResults === void 0 ? void 0 : clientEdgeQueryResults.length) {\n        var queryResource = getQueryResourceForEnvironment(this._environment);\n        clientEdgeQueryResults.forEach(function (queryResult) {\n          disposables.push(queryResource.retain(queryResult));\n        });\n      }\n    }\n\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (s) {\n          return s.dispose();\n        });\n\n        _this5._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this6 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this6.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      missingClientEdges: currentSnapshot.missingClientEdges,\n      missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields,\n      relayResolverErrors: currentSnapshot.relayResolverErrors\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this7 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this7.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this8 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this8._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this8._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}