{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar Observable = require('../network/RelayObservable');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReplaySubject = require('../util/RelayReplaySubject');\n\nvar invariant = require('invariant');\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\nvar requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. subscribe() takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subscription) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will not retain any query data outside the scope of the\n * request, which means it is not guaranteed that it won't be garbage\n * collected after the request completes.\n * If you need to retain data, you can do so manually with environment.retain().\n *\n * Cancelling requests:\n * ====================\n * If the subscription returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const subscription = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * subscription.unsubscribe();\n * ```\n */\n\nfunction fetchQuery(environment, operation) {\n  return fetchQueryDeduped(environment, operation.request.identifier, function () {\n    return environment.execute({\n      operation: operation\n    });\n  });\n}\n/**\n * Low-level implementation details of `fetchQuery`.\n *\n * `fetchQueryDeduped` can also be used to share a single cache for\n * requests that aren't using `fetchQuery` directly (e.g. because they don't\n * have an `OperationDescriptor` when they are called).\n */\n\n\nfunction fetchQueryDeduped(environment, identifier, fetchFn) {\n  return Observable.create(function (sink) {\n    var requestCache = getRequestCache(environment);\n    var cachedRequest = requestCache.get(identifier);\n\n    if (!cachedRequest) {\n      fetchFn()[\"finally\"](function () {\n        return requestCache[\"delete\"](identifier);\n      }).subscribe({\n        start: function start(subscription) {\n          cachedRequest = {\n            identifier: identifier,\n            subject: new RelayReplaySubject(),\n            subjectForInFlightStatus: new RelayReplaySubject(),\n            subscription: subscription,\n            promise: null\n          };\n          requestCache.set(identifier, cachedRequest);\n        },\n        next: function next(response) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.next(response);\n          cachedReq.subjectForInFlightStatus.next(response);\n        },\n        error: function error(_error) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.error(_error);\n          cachedReq.subjectForInFlightStatus.error(_error);\n        },\n        complete: function complete() {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.complete();\n          cachedReq.subjectForInFlightStatus.complete();\n        },\n        unsubscribe: function unsubscribe(subscription) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.unsubscribe();\n          cachedReq.subjectForInFlightStatus.unsubscribe();\n        }\n      });\n    }\n\n    !(cachedRequest != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : invariant(false) : void 0;\n    return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getObservableForCachedRequest(requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subject.subscribe(sink);\n    return function () {\n      subscription.unsubscribe();\n      var cachedRequestInstance = requestCache.get(cachedRequest.identifier);\n\n      if (cachedRequestInstance) {\n        var requestSubscription = cachedRequestInstance.subscription;\n\n        if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {\n          requestSubscription.unsubscribe();\n          requestCache[\"delete\"](cachedRequest.identifier);\n        }\n      }\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subjectForInFlightStatus.subscribe({\n      error: sink.error,\n      next: function next(response) {\n        if (!environment.isRequestActive(cachedRequest.identifier)) {\n          sink.complete();\n          return;\n        }\n\n        sink.next();\n      },\n      complete: sink.complete,\n      unsubscribe: sink.complete\n    });\n    return function () {\n      subscription.unsubscribe();\n    };\n  });\n}\n/**\n * If a request is active for the given query, variables and environment,\n * this function will return a Promise that will resolve when that request\n * stops being active (receives a final payload), and the data has been saved\n * to the store.\n * If no request is active, null will be returned\n */\n\n\nfunction getPromiseForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  if (RelayFeatureFlags.USE_REACT_CACHE) {\n    var existing = cachedRequest.promise;\n\n    if (existing) {\n      return existing;\n    }\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var resolveOnNext = false;\n    getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({\n      complete: resolve,\n      error: reject,\n      next: function next(response) {\n        /*\n         * The underlying `RelayReplaySubject` will synchronously replay events\n         * as soon as we subscribe, but since we want the *next* asynchronous\n         * one, we'll ignore them until the replay finishes.\n         */\n        if (resolveOnNext) {\n          resolve(response);\n        }\n      }\n    });\n    resolveOnNext = true;\n  });\n\n  if (RelayFeatureFlags.USE_REACT_CACHE) {\n    cachedRequest.promise = promise;\n  }\n\n  return promise;\n}\n/**\n * If there is a pending request for the given query, returns an Observable of\n * *all* its responses. Existing responses are published synchronously and\n * subsequent responses are published asynchronously. Returns null if there is\n * no pending request. This is similar to fetchQuery() except that it will not\n * issue a fetch if there isn't already one pending.\n */\n\n\nfunction getObservableForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);\n}\n/**\n * @private\n */\n\n\nfunction getRequestCache(environment) {\n  var cached = requestCachesByEnvironment.get(environment);\n\n  if (cached != null) {\n    return cached;\n  }\n\n  var requestCache = new Map();\n  requestCachesByEnvironment.set(environment, requestCache);\n  return requestCache;\n}\n/**\n * @private\n */\n\n\nfunction getCachedRequest(requestCache, identifier) {\n  var cached = requestCache.get(identifier);\n  !(cached != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : invariant(false) : void 0;\n  return cached;\n}\n\nmodule.exports = {\n  fetchQuery: fetchQuery,\n  fetchQueryDeduped: fetchQueryDeduped,\n  getPromiseForActiveRequest: getPromiseForActiveRequest,\n  getObservableForActiveRequest: getObservableForActiveRequest\n};","map":{"version":3,"names":["Observable","require","RelayFeatureFlags","RelayReplaySubject","invariant","WEAKMAP_SUPPORTED","WeakMap","requestCachesByEnvironment","Map","fetchQuery","environment","operation","fetchQueryDeduped","request","identifier","execute","fetchFn","create","sink","requestCache","getRequestCache","cachedRequest","get","subscribe","start","subscription","subject","subjectForInFlightStatus","promise","set","next","response","cachedReq","getCachedRequest","error","_error","complete","unsubscribe","process","env","NODE_ENV","getObservableForCachedRequest","cachedRequestInstance","requestSubscription","getObserverCount","getActiveStatusObservableForCachedRequest","isRequestActive","getPromiseForActiveRequest","USE_REACT_CACHE","existing","Promise","resolve","reject","resolveOnNext","getObservableForActiveRequest","cached","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/query/fetchQueryInternal.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar Observable = require('../network/RelayObservable');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReplaySubject = require('../util/RelayReplaySubject');\n\nvar invariant = require('invariant');\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\nvar requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. subscribe() takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subscription) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will not retain any query data outside the scope of the\n * request, which means it is not guaranteed that it won't be garbage\n * collected after the request completes.\n * If you need to retain data, you can do so manually with environment.retain().\n *\n * Cancelling requests:\n * ====================\n * If the subscription returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const subscription = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * subscription.unsubscribe();\n * ```\n */\n\nfunction fetchQuery(environment, operation) {\n  return fetchQueryDeduped(environment, operation.request.identifier, function () {\n    return environment.execute({\n      operation: operation\n    });\n  });\n}\n/**\n * Low-level implementation details of `fetchQuery`.\n *\n * `fetchQueryDeduped` can also be used to share a single cache for\n * requests that aren't using `fetchQuery` directly (e.g. because they don't\n * have an `OperationDescriptor` when they are called).\n */\n\n\nfunction fetchQueryDeduped(environment, identifier, fetchFn) {\n  return Observable.create(function (sink) {\n    var requestCache = getRequestCache(environment);\n    var cachedRequest = requestCache.get(identifier);\n\n    if (!cachedRequest) {\n      fetchFn()[\"finally\"](function () {\n        return requestCache[\"delete\"](identifier);\n      }).subscribe({\n        start: function start(subscription) {\n          cachedRequest = {\n            identifier: identifier,\n            subject: new RelayReplaySubject(),\n            subjectForInFlightStatus: new RelayReplaySubject(),\n            subscription: subscription,\n            promise: null\n          };\n          requestCache.set(identifier, cachedRequest);\n        },\n        next: function next(response) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.next(response);\n          cachedReq.subjectForInFlightStatus.next(response);\n        },\n        error: function error(_error) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.error(_error);\n          cachedReq.subjectForInFlightStatus.error(_error);\n        },\n        complete: function complete() {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.complete();\n          cachedReq.subjectForInFlightStatus.complete();\n        },\n        unsubscribe: function unsubscribe(subscription) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.unsubscribe();\n          cachedReq.subjectForInFlightStatus.unsubscribe();\n        }\n      });\n    }\n\n    !(cachedRequest != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : invariant(false) : void 0;\n    return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getObservableForCachedRequest(requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subject.subscribe(sink);\n    return function () {\n      subscription.unsubscribe();\n      var cachedRequestInstance = requestCache.get(cachedRequest.identifier);\n\n      if (cachedRequestInstance) {\n        var requestSubscription = cachedRequestInstance.subscription;\n\n        if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {\n          requestSubscription.unsubscribe();\n          requestCache[\"delete\"](cachedRequest.identifier);\n        }\n      }\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subjectForInFlightStatus.subscribe({\n      error: sink.error,\n      next: function next(response) {\n        if (!environment.isRequestActive(cachedRequest.identifier)) {\n          sink.complete();\n          return;\n        }\n\n        sink.next();\n      },\n      complete: sink.complete,\n      unsubscribe: sink.complete\n    });\n    return function () {\n      subscription.unsubscribe();\n    };\n  });\n}\n/**\n * If a request is active for the given query, variables and environment,\n * this function will return a Promise that will resolve when that request\n * stops being active (receives a final payload), and the data has been saved\n * to the store.\n * If no request is active, null will be returned\n */\n\n\nfunction getPromiseForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  if (RelayFeatureFlags.USE_REACT_CACHE) {\n    var existing = cachedRequest.promise;\n\n    if (existing) {\n      return existing;\n    }\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var resolveOnNext = false;\n    getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({\n      complete: resolve,\n      error: reject,\n      next: function next(response) {\n        /*\n         * The underlying `RelayReplaySubject` will synchronously replay events\n         * as soon as we subscribe, but since we want the *next* asynchronous\n         * one, we'll ignore them until the replay finishes.\n         */\n        if (resolveOnNext) {\n          resolve(response);\n        }\n      }\n    });\n    resolveOnNext = true;\n  });\n\n  if (RelayFeatureFlags.USE_REACT_CACHE) {\n    cachedRequest.promise = promise;\n  }\n\n  return promise;\n}\n/**\n * If there is a pending request for the given query, returns an Observable of\n * *all* its responses. Existing responses are published synchronously and\n * subsequent responses are published asynchronously. Returns null if there is\n * no pending request. This is similar to fetchQuery() except that it will not\n * issue a fetch if there isn't already one pending.\n */\n\n\nfunction getObservableForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);\n}\n/**\n * @private\n */\n\n\nfunction getRequestCache(environment) {\n  var cached = requestCachesByEnvironment.get(environment);\n\n  if (cached != null) {\n    return cached;\n  }\n\n  var requestCache = new Map();\n  requestCachesByEnvironment.set(environment, requestCache);\n  return requestCache;\n}\n/**\n * @private\n */\n\n\nfunction getCachedRequest(requestCache, identifier) {\n  var cached = requestCache.get(identifier);\n  !(cached != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : invariant(false) : void 0;\n  return cached;\n}\n\nmodule.exports = {\n  fetchQuery: fetchQuery,\n  fetchQueryDeduped: fetchQueryDeduped,\n  getPromiseForActiveRequest: getPromiseForActiveRequest,\n  getObservableForActiveRequest: getObservableForActiveRequest\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}