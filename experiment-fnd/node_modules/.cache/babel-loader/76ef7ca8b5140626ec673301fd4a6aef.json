{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          missingClientEdges: backup.missingClientEdges,\n          missingLiveResolverFields: backup.missingLiveResolverFields,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields,\n          relayResolverErrors: backup.relayResolverErrors\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      missingClientEdges: nextSnapshot.missingClientEdges,\n      missingLiveResolverFields: nextSnapshot.missingLiveResolverFields,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields,\n      relayResolverErrors: nextSnapshot.relayResolverErrors\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;","map":{"version":3,"names":["deepFreeze","require","recycleNodesInto","RelayFeatureFlags","hasOverlappingIDs","RelayReader","RelayStoreSubscriptions","log","resolverCache","_subscriptions","Set","__log","_resolverCache","_proto","prototype","subscribe","snapshot","callback","_this","subscription","backup","stale","dispose","add","snapshotSubscriptions","source","_this2","forEach","read","selector","nextData","data","restoreSubscriptions","isMissingData","missingClientEdges","missingLiveResolverFields","seenRecords","missingRequiredFields","relayResolverErrors","updateSubscriptions","updatedRecordIDs","updatedOwners","sourceOperation","_this3","hasUpdatedRecords","size","owner","_updateSubscription","push","hasOverlappingUpdates","nextSnapshot","process","env","NODE_ENV","ENABLE_NOTIFY_SUBSCRIPTION","name","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          missingClientEdges: backup.missingClientEdges,\n          missingLiveResolverFields: backup.missingLiveResolverFields,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields,\n          relayResolverErrors: backup.relayResolverErrors\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      missingClientEdges: nextSnapshot.missingClientEdges,\n      missingLiveResolverFields: nextSnapshot.missingLiveResolverFields,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields,\n      relayResolverErrors: nextSnapshot.relayResolverErrors\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;"],"mappings":"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"},"metadata":{},"sourceType":"script"}