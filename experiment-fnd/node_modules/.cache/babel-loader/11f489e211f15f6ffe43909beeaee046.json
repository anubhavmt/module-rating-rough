{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require('invariant');\n/**\n * JS maps (both plain objects and Map) maintain key insertion\n * order, which means there is an easy way to simulate LRU behavior\n * that should also perform quite well:\n *\n * To insert a new value, first delete the key from the inner _map,\n * then _map.set(k, v). By deleting and reinserting, you ensure that the\n * map sees the key as the last inserted key.\n *\n * Get does the same: if the key is present, delete and reinsert it.\n */\n\n\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache(capacity) {\n    this._capacity = capacity;\n    !(this._capacity > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : invariant(false) : void 0;\n    this._map = new Map();\n  }\n\n  var _proto = LRUCache.prototype;\n\n  _proto.set = function set(key, value) {\n    this._map[\"delete\"](key);\n\n    this._map.set(key, value);\n\n    if (this._map.size > this._capacity) {\n      var firstKey = this._map.keys().next();\n\n      if (!firstKey.done) {\n        this._map[\"delete\"](firstKey.value);\n      }\n    }\n  };\n\n  _proto.get = function get(key) {\n    var value = this._map.get(key);\n\n    if (value != null) {\n      this._map[\"delete\"](key);\n\n      this._map.set(key, value);\n    }\n\n    return value;\n  };\n\n  _proto.has = function has(key) {\n    return this._map.has(key);\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    this._map[\"delete\"](key);\n  };\n\n  _proto.size = function size() {\n    return this._map.size;\n  };\n\n  _proto.capacity = function capacity() {\n    return this._capacity - this._map.size;\n  };\n\n  _proto.clear = function clear() {\n    this._map.clear();\n  };\n\n  return LRUCache;\n}();\n\nfunction create(capacity) {\n  return new LRUCache(capacity);\n}\n\nmodule.exports = {\n  create: create\n};","map":{"version":3,"names":["invariant","require","LRUCache","capacity","_capacity","process","env","NODE_ENV","_map","Map","_proto","prototype","set","key","value","size","firstKey","keys","next","done","get","has","_delete","clear","create","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/LRUCache.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require('invariant');\n\n/**\n * JS maps (both plain objects and Map) maintain key insertion\n * order, which means there is an easy way to simulate LRU behavior\n * that should also perform quite well:\n *\n * To insert a new value, first delete the key from the inner _map,\n * then _map.set(k, v). By deleting and reinserting, you ensure that the\n * map sees the key as the last inserted key.\n *\n * Get does the same: if the key is present, delete and reinsert it.\n */\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache(capacity) {\n    this._capacity = capacity;\n    !(this._capacity > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : invariant(false) : void 0;\n    this._map = new Map();\n  }\n\n  var _proto = LRUCache.prototype;\n\n  _proto.set = function set(key, value) {\n    this._map[\"delete\"](key);\n\n    this._map.set(key, value);\n\n    if (this._map.size > this._capacity) {\n      var firstKey = this._map.keys().next();\n\n      if (!firstKey.done) {\n        this._map[\"delete\"](firstKey.value);\n      }\n    }\n  };\n\n  _proto.get = function get(key) {\n    var value = this._map.get(key);\n\n    if (value != null) {\n      this._map[\"delete\"](key);\n\n      this._map.set(key, value);\n    }\n\n    return value;\n  };\n\n  _proto.has = function has(key) {\n    return this._map.has(key);\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    this._map[\"delete\"](key);\n  };\n\n  _proto.size = function size() {\n    return this._map.size;\n  };\n\n  _proto.capacity = function capacity() {\n    return this._capacity - this._map.size;\n  };\n\n  _proto.clear = function clear() {\n    this._map.clear();\n  };\n\n  return LRUCache;\n}();\n\nfunction create(capacity) {\n  return new LRUCache(capacity);\n}\n\nmodule.exports = {\n  create: create\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,QAAQ,GAAG,aAAa,YAAY;EACtC,SAASA,QAAT,CAAkBC,QAAlB,EAA4B;IAC1B,KAAKC,SAAL,GAAiBD,QAAjB;IACA,EAAE,KAAKC,SAAL,GAAiB,CAAnB,IAAwBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCP,SAAS,CAAC,KAAD,EAAQ,8EAAR,CAAjD,GAA2IA,SAAS,CAAC,KAAD,CAA5K,GAAsL,KAAK,CAA3L;IACA,KAAKQ,IAAL,GAAY,IAAIC,GAAJ,EAAZ;EACD;;EAED,IAAIC,MAAM,GAAGR,QAAQ,CAACS,SAAtB;;EAEAD,MAAM,CAACE,GAAP,GAAa,SAASA,GAAT,CAAaC,GAAb,EAAkBC,KAAlB,EAAyB;IACpC,KAAKN,IAAL,CAAU,QAAV,EAAoBK,GAApB;;IAEA,KAAKL,IAAL,CAAUI,GAAV,CAAcC,GAAd,EAAmBC,KAAnB;;IAEA,IAAI,KAAKN,IAAL,CAAUO,IAAV,GAAiB,KAAKX,SAA1B,EAAqC;MACnC,IAAIY,QAAQ,GAAG,KAAKR,IAAL,CAAUS,IAAV,GAAiBC,IAAjB,EAAf;;MAEA,IAAI,CAACF,QAAQ,CAACG,IAAd,EAAoB;QAClB,KAAKX,IAAL,CAAU,QAAV,EAAoBQ,QAAQ,CAACF,KAA7B;MACD;IACF;EACF,CAZD;;EAcAJ,MAAM,CAACU,GAAP,GAAa,SAASA,GAAT,CAAaP,GAAb,EAAkB;IAC7B,IAAIC,KAAK,GAAG,KAAKN,IAAL,CAAUY,GAAV,CAAcP,GAAd,CAAZ;;IAEA,IAAIC,KAAK,IAAI,IAAb,EAAmB;MACjB,KAAKN,IAAL,CAAU,QAAV,EAAoBK,GAApB;;MAEA,KAAKL,IAAL,CAAUI,GAAV,CAAcC,GAAd,EAAmBC,KAAnB;IACD;;IAED,OAAOA,KAAP;EACD,CAVD;;EAYAJ,MAAM,CAACW,GAAP,GAAa,SAASA,GAAT,CAAaR,GAAb,EAAkB;IAC7B,OAAO,KAAKL,IAAL,CAAUa,GAAV,CAAcR,GAAd,CAAP;EACD,CAFD;;EAIAH,MAAM,CAAC,QAAD,CAAN,GAAmB,SAASY,OAAT,CAAiBT,GAAjB,EAAsB;IACvC,KAAKL,IAAL,CAAU,QAAV,EAAoBK,GAApB;EACD,CAFD;;EAIAH,MAAM,CAACK,IAAP,GAAc,SAASA,IAAT,GAAgB;IAC5B,OAAO,KAAKP,IAAL,CAAUO,IAAjB;EACD,CAFD;;EAIAL,MAAM,CAACP,QAAP,GAAkB,SAASA,QAAT,GAAoB;IACpC,OAAO,KAAKC,SAAL,GAAiB,KAAKI,IAAL,CAAUO,IAAlC;EACD,CAFD;;EAIAL,MAAM,CAACa,KAAP,GAAe,SAASA,KAAT,GAAiB;IAC9B,KAAKf,IAAL,CAAUe,KAAV;EACD,CAFD;;EAIA,OAAOrB,QAAP;AACD,CAxD2B,EAA5B;;AA0DA,SAASsB,MAAT,CAAgBrB,QAAhB,EAA0B;EACxB,OAAO,IAAID,QAAJ,CAAaC,QAAb,CAAP;AACD;;AAEDsB,MAAM,CAACC,OAAP,GAAiB;EACfF,MAAM,EAAEA;AADO,CAAjB"},"metadata":{},"sourceType":"script"}