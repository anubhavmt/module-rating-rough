{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\n\n\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\n\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleDataChange\", function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    });\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this._maybeHiddenOrFastRefresh = false;\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      return resetQueryStateForUpdate(nextProps, prevState);\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (this._maybeHiddenOrFastRefresh === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, so that the query is re-evaluated\n      // (and potentially cause a refetch).\n      this._maybeHiddenOrFastRefresh = false; // eslint-disable-next-line react/no-did-mount-set-state\n\n      this.setState(function (prevState) {\n        return resetQueryStateForUpdate(_this2.props, prevState);\n      });\n      return;\n    }\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey; // We don't need to cache the request after the component commits\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = this._handleDataChange;\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {\n    // We don't need to cache the request after the component commits\n    var _this$state2 = this.state,\n        queryFetcher = _this$state2.queryFetcher,\n        requestCacheKey = _this$state2.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n\n    if (this.props.query && queryFetcher !== prevState.queryFetcher) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n    this._maybeHiddenOrFastRefresh = true;\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state3 = this.state,\n        renderProps = _this$state3.renderProps,\n        relayContext = _this$state3.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction resetQueryStateForUpdate(props, prevState) {\n  var query = props.query;\n  var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n  prevState.queryFetcher.disposeRequest();\n  var queryFetcher;\n\n  if (query) {\n    var request = getRequest(query);\n    var requestCacheKey = getRequestCacheKey(request.params, props.variables);\n    queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n  } else {\n    queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n  }\n\n  return (0, _objectSpread2[\"default\"])({\n    prevQuery: props.query,\n    prevPropsEnvironment: props.environment,\n    prevPropsVariables: props.variables,\n    queryFetcher: queryFetcher\n  }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n  // and we want the updated requestCacheKey, since variables may have changed\n  ));\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: null,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","_assertThisInitialized2","_inheritsLoose2","_defineProperty2","ReactRelayContext","ReactRelayQueryFetcher","ReactRelayQueryRendererContext","areEqual","React","_require","createOperationDescriptor","deepFreeze","getRequest","requestCache","queryRendererContext","rootIsQueryRenderer","ReactRelayQueryRenderer","_React$Component","props","_this","call","params","error","snapshot","setState","prevState","prevRequestCacheKey","requestCacheKey","renderProps","getRenderProps","queryFetcher","retryCallbacks","handleDataChange","handleRetryAfterError","query","request","getRequestCacheKey","variables","_maybeHiddenOrFastRefresh","state","prevPropsEnvironment","environment","prevPropsVariables","prevQuery","fetchQueryAndComputeStateFromProps","getDerivedStateFromProps","nextProps","resetQueryStateForUpdate","_proto","prototype","componentDidMount","_this2","_this$state","_handleDataChange","getLoadingRenderProps","setOnDataChange","componentDidUpdate","_prevProps","_this$state2","componentWillUnmount","dispose","shouldComponentUpdate","nextState","render","_this$state3","relayContext","process","env","NODE_ENV","createElement","Provider","value","Component","retry","getEmptyRenderProps","data","cacheConfigOverride","syncSnapshot","JSON","stringify","id","cacheID","prevSelectionReferences","getSelectionReferences","disposeRequest","cacheConfig","genericEnvironment","operation","storeSnapshot","lookupInStore","fetchPolicy","querySnapshot","fetch","onDataChange","_snapshot","_relayContext","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/ReactRelayQueryRenderer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleDataChange\", function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    });\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this._maybeHiddenOrFastRefresh = false;\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      return resetQueryStateForUpdate(nextProps, prevState);\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (this._maybeHiddenOrFastRefresh === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, so that the query is re-evaluated\n      // (and potentially cause a refetch).\n      this._maybeHiddenOrFastRefresh = false; // eslint-disable-next-line react/no-did-mount-set-state\n\n      this.setState(function (prevState) {\n        return resetQueryStateForUpdate(_this2.props, prevState);\n      });\n      return;\n    }\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey; // We don't need to cache the request after the component commits\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = this._handleDataChange;\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {\n    // We don't need to cache the request after the component commits\n    var _this$state2 = this.state,\n        queryFetcher = _this$state2.queryFetcher,\n        requestCacheKey = _this$state2.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n\n    if (this.props.query && queryFetcher !== prevState.queryFetcher) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n    this._maybeHiddenOrFastRefresh = true;\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state3 = this.state,\n        renderProps = _this$state3.renderProps,\n        relayContext = _this$state3.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction resetQueryStateForUpdate(props, prevState) {\n  var query = props.query;\n  var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n  prevState.queryFetcher.disposeRequest();\n  var queryFetcher;\n\n  if (query) {\n    var request = getRequest(query);\n    var requestCacheKey = getRequestCacheKey(request.params, props.variables);\n    queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n  } else {\n    queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n  }\n\n  return (0, _objectSpread2[\"default\"])({\n    prevQuery: props.query,\n    prevPropsEnvironment: props.environment,\n    prevPropsVariables: props.variables,\n    queryFetcher: queryFetcher\n  }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n  // and we want the updated requestCacheKey, since variables may have changed\n  ));\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: null,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;"],"mappings":"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"},"metadata":{},"sourceType":"script"}