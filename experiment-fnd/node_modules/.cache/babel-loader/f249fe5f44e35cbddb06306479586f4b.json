{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar _require = require('../util/RelayConcreteNode'),\n    RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;\n\nvar _require2 = require('./ClientID'),\n    generateClientID = _require2.generateClientID;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_ERROR_KEY = _require3.RELAY_RESOLVER_ERROR_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require3.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_SNAPSHOT_KEY = _require3.RELAY_RESOLVER_SNAPSHOT_KEY,\n    RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\"); // $FlowFixMe[unclear-type] - will always be empty\n\n\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    !(field.kind !== RELAY_LIVE_RESOLVER) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'This store does not support Live Resolvers') : invariant(false) : void 0;\n\n    var _evaluate = evaluate(),\n        resolverResult = _evaluate.resolverResult,\n        snapshot = _evaluate.snapshot,\n        error = _evaluate.error;\n\n    return [resolverResult, undefined, error, snapshot, undefined];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : invariant(false) : void 0;\n  };\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID, _evaluationResult$sna; // Cache miss; evaluate the selector and store the result in a new record:\n\n\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n      var seenRecordIds = (_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.seenRecords;\n\n      if (seenRecordIds != null) {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(seenRecordIds),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var seenRecordID = _step.value;\n            addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY]; // $FlowFixMe[incompatible-type] - casting mixed\n\n    var snapshot = linkedRecord[RELAY_RESOLVER_SNAPSHOT_KEY]; // $FlowFixMe[incompatible-type] - casting mixed\n\n    var error = linkedRecord[RELAY_RESOLVER_ERROR_KEY];\n    return [answer, linkedID, error, snapshot, undefined];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    } // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n\n    var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);\n    var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;\n    var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var _getDataForResolverFr = getDataForResolverFragment(readerSelector),\n        latestValues = _getDataForResolverFr.data;\n\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto2.ensureClientRecord = function ensureClientRecord(id, typename) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : invariant(false) : void 0;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};","map":{"version":3,"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","recycleNodesInto","_require","RELAY_LIVE_RESOLVER","_require2","generateClientID","RelayModernRecord","_require3","RELAY_RESOLVER_ERROR_KEY","RELAY_RESOLVER_INVALIDATION_KEY","RELAY_RESOLVER_SNAPSHOT_KEY","RELAY_RESOLVER_VALUE_KEY","getStorageKey","invariant","warning","emptySet","Set","NoopResolverCache","_proto","prototype","readFromCacheOrEvaluate","record","field","variables","evaluate","getDataForResolverFragment","kind","process","env","NODE_ENV","_evaluate","resolverResult","snapshot","error","undefined","invalidateDataIDs","updatedDataIDs","ensureClientRecord","id","typeName","addDependencyEdge","edges","from","to","set","get","add","RecordResolverCache","getRecordSource","_resolverIDToRecordIDs","Map","_recordIDToResolverIDs","_getRecordSource","_proto2","recordSource","recordID","getDataID","storageKey","linkedID","getLinkedRecordID","linkedRecord","_isInvalid","_linkedID","_evaluationResult$sna","create","evaluationResult","setValue","nextRecord","clone","setLinkedRecordID","resolverID","seenRecordIds","seenRecords","_iterator","_step","s","n","done","seenRecordID","value","err","e","f","answer","visited","recordsToVisit","Array","length","pop","_iterator2","_this$_recordIDToReso","_step2","fragment","has","_iterator3","_this$_resolverIDToRe","_step3","anotherRecordID","_markInvalidatedResolverRecord","push","dataID","getValue","originalInputs","data","readerSelector","selector","_getDataForResolverFr","latestValues","recycled","typename","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/ResolverCache.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar _require = require('../util/RelayConcreteNode'),\n    RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;\n\nvar _require2 = require('./ClientID'),\n    generateClientID = _require2.generateClientID;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_ERROR_KEY = _require3.RELAY_RESOLVER_ERROR_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require3.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_SNAPSHOT_KEY = _require3.RELAY_RESOLVER_SNAPSHOT_KEY,\n    RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\n// $FlowFixMe[unclear-type] - will always be empty\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    !(field.kind !== RELAY_LIVE_RESOLVER) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'This store does not support Live Resolvers') : invariant(false) : void 0;\n\n    var _evaluate = evaluate(),\n        resolverResult = _evaluate.resolverResult,\n        snapshot = _evaluate.snapshot,\n        error = _evaluate.error;\n\n    return [resolverResult, undefined, error, snapshot, undefined];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : invariant(false) : void 0;\n  };\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID, _evaluationResult$sna;\n\n      // Cache miss; evaluate the selector and store the result in a new record:\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n      var seenRecordIds = (_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.seenRecords;\n\n      if (seenRecordIds != null) {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(seenRecordIds),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var seenRecordID = _step.value;\n            addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY]; // $FlowFixMe[incompatible-type] - casting mixed\n\n    var snapshot = linkedRecord[RELAY_RESOLVER_SNAPSHOT_KEY]; // $FlowFixMe[incompatible-type] - casting mixed\n\n    var error = linkedRecord[RELAY_RESOLVER_ERROR_KEY];\n    return [answer, linkedID, error, snapshot, undefined];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    } // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n\n    var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);\n    var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;\n    var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var _getDataForResolverFr = getDataForResolverFragment(readerSelector),\n        latestValues = _getDataForResolverFr.data;\n\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto2.ensureClientRecord = function ensureClientRecord(id, typename) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : invariant(false) : void 0;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}