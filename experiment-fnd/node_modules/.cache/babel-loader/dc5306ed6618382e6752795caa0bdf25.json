{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar invariant = require('invariant');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = getArguments(field);\n  var name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a field the method returns an array of arguments.\n * For Relay resolver fields, we store arguments on the field and fragment\n * and this method return combined list of arguments.\n */\n\n\nfunction getArguments(field) {\n  if (field.kind === 'RelayResolver' || field.kind === 'RelayLiveResolver') {\n    var _field$fragment2;\n\n    if (field.args == null) {\n      var _field$fragment;\n\n      return (_field$fragment = field.fragment) === null || _field$fragment === void 0 ? void 0 : _field$fragment.args;\n    }\n\n    if (((_field$fragment2 = field.fragment) === null || _field$fragment2 === void 0 ? void 0 : _field$fragment2.args) == null) {\n      return field.args;\n    }\n\n    return field.args.concat(field.fragment.args);\n  }\n\n  var args = typeof field.args === 'undefined' ? undefined : field.args;\n  return args;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  ACTOR_IDENTIFIER_KEY: '__actorIdentifier',\n  CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  RELAY_RESOLVER_VALUE_KEY: '__resolverValue',\n  RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',\n  RELAY_RESOLVER_SNAPSHOT_KEY: '__resolverSnapshot',\n  RELAY_RESOLVER_ERROR_KEY: '__resolverError',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;","map":{"version":3,"names":["_interopRequireDefault","require","_toConsumableArray2","getRelayHandleKey","RelayConcreteNode","stableCopy","invariant","VARIABLE","LITERAL","OBJECT_VALUE","LIST_VALUE","MODULE_COMPONENT_KEY_PREFIX","MODULE_OPERATION_KEY_PREFIX","getArgumentValue","arg","variables","kind","getStableVariableValue","variableName","value","fields","forEach","field","name","_value","items","item","push","getArgumentValues","args","values","getHandleStorageKey","handleField","dynamicKey","handle","key","filters","handleName","filterArgs","length","filter","indexOf","concat","formatStorageKey","getStorageKey","storageKey","getArguments","_field$fragment2","_field$fragment","fragment","undefined","getStableStorageKey","argValues","argName","hasOwnProperty","_JSON$stringify","JSON","stringify","join","process","env","NODE_ENV","getModuleComponentKey","documentName","getModuleOperationKey","RelayStoreUtils","ACTOR_IDENTIFIER_KEY","CLIENT_EDGE_TRAVERSAL_PATH","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","MODULE_COMPONENT_KEY","ID_KEY","REF_KEY","REFS_KEY","ROOT_ID","ROOT_TYPE","TYPENAME_KEY","INVALIDATED_AT_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","RELAY_RESOLVER_VALUE_KEY","RELAY_RESOLVER_INVALIDATION_KEY","RELAY_RESOLVER_SNAPSHOT_KEY","RELAY_RESOLVER_ERROR_KEY","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/RelayStoreUtils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar invariant = require('invariant');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = getArguments(field);\n  var name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a field the method returns an array of arguments.\n * For Relay resolver fields, we store arguments on the field and fragment\n * and this method return combined list of arguments.\n */\n\n\nfunction getArguments(field) {\n  if (field.kind === 'RelayResolver' || field.kind === 'RelayLiveResolver') {\n    var _field$fragment2;\n\n    if (field.args == null) {\n      var _field$fragment;\n\n      return (_field$fragment = field.fragment) === null || _field$fragment === void 0 ? void 0 : _field$fragment.args;\n    }\n\n    if (((_field$fragment2 = field.fragment) === null || _field$fragment2 === void 0 ? void 0 : _field$fragment2.args) == null) {\n      return field.args;\n    }\n\n    return field.args.concat(field.fragment.args);\n  }\n\n  var args = typeof field.args === 'undefined' ? undefined : field.args;\n  return args;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  ACTOR_IDENTIFIER_KEY: '__actorIdentifier',\n  CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  RELAY_RESOLVER_VALUE_KEY: '__resolverValue',\n  RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',\n  RELAY_RESOLVER_SNAPSHOT_KEY: '__resolverSnapshot',\n  RELAY_RESOLVER_ERROR_KEY: '__resolverError',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;"],"mappings":"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"},"metadata":{},"sourceType":"script"}