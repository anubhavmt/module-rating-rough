{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectSpread3 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\n\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\n\nvar _require = require('./ReactRelayContainerUtils'),\n    getComponentName = _require.getComponentName,\n    getContainerName = _require.getContainerName;\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar _require2 = require('./RelayContext'),\n    assertRelayContext = _require2.assertRelayContext;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require3 = require('relay-runtime'),\n    ConnectionInterface = _require3.ConnectionInterface,\n    Observable = _require3.Observable,\n    RelayFeatureFlags = _require3.RelayFeatureFlags,\n    createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n    createOperationDescriptor = _require3.createOperationDescriptor,\n    getDataIDsFromObject = _require3.getDataIDsFromObject,\n    getRequest = _require3.getRequest,\n    getVariablesFromObject = _require3.getVariablesFromObject,\n    isScalarAndEqual = _require3.isScalarAndEqual;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar FORWARD = 'forward';\n/**\n * Extends the functionality of RelayFragmentContainer by providing a mechanism\n * to load more data from a connection.\n *\n * # Configuring a PaginationContainer\n *\n * PaginationContainer accepts the standard FragmentContainer arguments and an\n * additional `connectionConfig` argument:\n *\n * - `Component`: the component to be wrapped/rendered.\n * - `fragments`: an object whose values are `graphql` fragments. The object\n *   keys determine the prop names by which fragment data is available.\n * - `connectionConfig`: an object that determines how to load more connection\n *   data. Details below.\n *\n * # Loading More Data\n *\n * Use `props.relay.hasMore()` to determine if there are more items to load.\n *\n * ```\n * hasMore(): boolean\n * ```\n *\n * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`\n * is still pending. This is convenient for avoiding duplicate load calls.\n *\n * ```\n * isLoading(): boolean\n * ```\n *\n * Use `props.relay.loadMore()` to load more items. This will return null if\n * there are no more items to fetch, otherwise it will fetch more items and\n * return a Disposable that can be used to cancel the fetch.\n *\n * `pageSize` should be the number of *additional* items to fetch (not the\n * total).\n *\n * ```\n * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable\n * ```\n *\n * A complete example:\n *\n * ```\n * class Foo extends React.Component {\n *   ...\n *   _onEndReached() {\n *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n *       return;\n *     }\n *     this.props.relay.loadMore(10);\n *   }\n *   ...\n * }\n * ```\n *\n * # Connection Config\n *\n * Here's an example, followed by details of each config property:\n *\n * ```\n * ReactRelayPaginationContainer.createContainer(\n *   Component,\n *   {\n *     user: graphql`fragment FriendsFragment on User {\n *       friends(after: $afterCursor first: $count) @connection {\n *         edges { ... }\n *         pageInfo {\n *           startCursor\n *           endCursor\n *           hasNextPage\n *           hasPreviousPage\n *         }\n *       }\n *     }`,\n *   },\n *   {\n *     direction: 'forward',\n *     getConnectionFromProps(props) {\n *       return props.user && props.user.friends;\n *     },\n *     getFragmentVariables(vars, totalCount) {\n *       // The component presumably wants *all* edges, not just those after\n *       // the cursor, so notice that we don't set $afterCursor here.\n *       return {\n *         ...vars,\n *         count: totalCount,\n *       };\n *     },\n *     getVariables(props, {count, cursor}, fragmentVariables) {\n *       return {\n *         id: props.user.id,\n *         afterCursor: cursor,\n *         count,\n *       },\n *     },\n *     query: graphql`\n *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {\n *         node(id: $id) {\n *           ...FriendsFragment\n *         }\n *       }\n *     `,\n *   }\n * );\n * ```\n *\n * ## Config Properties\n *\n * - `direction`: Either \"forward\" to indicate forward pagination using\n *   after/first, or \"backward\" to indicate backward pagination using\n *   before/last.\n * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know\n *   which connection data you mean to fetch more of (a container might fetch\n *   multiple connections, but can only paginate one of them). This function is\n *   given the fragment props only (not full props), and should return the\n *   connection data. See the above example that returns the friends data via\n *   `props.user.friends`.\n * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables\n *   and the new total number of items, get the variables to use when reading\n *   your fragments. Typically this means setting whatever your local \"count\"\n *   variable is to the value of `totalCount`. See the example.\n * - `getVariables(props, {count, cursor})`: Get the variables to use when\n *   fetching the pagination `query`. You may determine the root object id from\n *   props (see the example that uses `props.user.id`) and may also set whatever\n *   variables you use for the after/first/before/last calls based on the count\n *   and cursor.\n * - `query`: A query to use when fetching more connection data. This should\n *   typically reference one of the container's fragment (as in the example)\n *   to ensure that all the necessary fields for sub-components are fetched.\n */\n\nfunction createGetConnectionFromProps(metadata) {\n  var path = metadata.path;\n  !path ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : invariant(false) : void 0;\n  return function (props) {\n    var data = props[metadata.fragmentName];\n\n    for (var i = 0; i < path.length; i++) {\n      if (!data || typeof data !== 'object') {\n        return null;\n      }\n\n      data = data[path[i]];\n    }\n\n    return data;\n  };\n}\n\nfunction createGetFragmentVariables(metadata) {\n  var countVariable = metadata.count;\n  !countVariable ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : invariant(false) : void 0;\n  return function (prevVars, totalCount) {\n    return (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, prevVars), {}, (0, _defineProperty2[\"default\"])({}, countVariable, totalCount));\n  };\n}\n\nfunction findConnectionMetadata(fragments) {\n  var foundConnectionMetadata = null;\n  var isRelayModern = false;\n\n  for (var fragmentName in fragments) {\n    var fragment = fragments[fragmentName];\n    var connectionMetadata = fragment.metadata && fragment.metadata.connection; // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n\n    if (fragment.metadata !== undefined) {\n      isRelayModern = true;\n    }\n\n    if (connectionMetadata) {\n      !(connectionMetadata.length === 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', fragmentName, connectionMetadata.length) : invariant(false) : void 0;\n      !!foundConnectionMetadata ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : invariant(false) : void 0;\n      foundConnectionMetadata = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, connectionMetadata[0]), {}, {\n        fragmentName: fragmentName\n      });\n    }\n  }\n\n  !(!isRelayModern || foundConnectionMetadata !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : invariant(false) : void 0;\n  return foundConnectionMetadata || {};\n}\n\nfunction toObserver(observerOrCallback) {\n  return typeof observerOrCallback === 'function' ? {\n    error: observerOrCallback,\n    complete: observerOrCallback,\n    unsubscribe: function unsubscribe(subscription) {\n      typeof observerOrCallback === 'function' && observerOrCallback();\n    }\n  } : observerOrCallback || {};\n}\n\nfunction createContainerWithFragments(Component, fragments, connectionConfig) {\n  var _class, _temp;\n\n  var componentName = getComponentName(Component);\n  var containerName = getContainerName(Component);\n  var metadata = findConnectionMetadata(fragments);\n  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);\n  var direction = connectionConfig.direction || metadata.direction;\n  !direction ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : invariant(false) : void 0;\n  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);\n  return _temp = _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n\n    function _class(props) {\n      var _props$__rootIsQueryR, _this;\n\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        _this.setState({\n          data: _this._resolver.resolve()\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_hasMore\", function () {\n        var connectionData = _this._getConnectionData();\n\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_isLoading\", function () {\n        return !!_this._refetchSubscription;\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetchConnection\", function (totalCount, observerOrCallback, refetchVariables) {\n        if (!_this._canFetchPage('refetchConnection')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        _this._refetchVariables = refetchVariables;\n        var paginatingVariables = {\n          count: totalCount,\n          cursor: null,\n          totalCount: totalCount\n        };\n\n        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {\n          force: true\n        });\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_loadMore\", function (pageSize, observerOrCallback, options) {\n        if (!_this._canFetchPage('loadMore')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        var observer = toObserver(observerOrCallback);\n\n        var connectionData = _this._getConnectionData();\n\n        if (!connectionData) {\n          Observable.create(function (sink) {\n            return sink.complete();\n          }).subscribe(observer);\n          return null;\n        }\n\n        var totalCount = connectionData.edgeCount + pageSize;\n\n        if (options && options.force) {\n          return _this._refetchConnection(totalCount, observerOrCallback);\n        }\n\n        var _ConnectionInterface$ = ConnectionInterface.get(),\n            END_CURSOR = _ConnectionInterface$.END_CURSOR,\n            START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n        var cursor = connectionData.cursor;\n        process.env.NODE_ENV !== \"production\" ? warning(cursor != null && cursor !== '', 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        var paginatingVariables = {\n          count: pageSize,\n          cursor: cursor,\n          totalCount: totalCount\n        };\n\n        var fetch = _this._fetchPage(paginatingVariables, observer, options);\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;\n      _this._isARequestInFlight = false;\n      _this._refetchSubscription = null;\n      _this._refetchVariables = null;\n\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);\n      } else {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);\n      }\n\n      _this.state = {\n        data: _this._resolver.resolve(),\n        prevContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: _this._buildRelayProp(relayContext),\n        resolverGeneration: 0\n      };\n      _this._isUnmounted = false;\n      _this._hasFetched = false;\n      return _this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      this._isUnmounted = false;\n\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n      }\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        if (prevState.resolverGeneration !== this.state.resolverGeneration) {\n          this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n        } else {\n          this._rerenderIfStoreHasChanged();\n        }\n      }\n    }\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */\n    ;\n\n    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      var _nextProps$__rootIsQu;\n\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;\n      var prevIDs = getDataIDsFromObject(fragments, this.props);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, this.props);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps); // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (relayContext.environment !== this.state.prevContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        this._cleanup(); // Child containers rely on context.relay being mutated (for gDSFP).\n\n\n        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);\n        } else {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);\n        }\n\n        this.setState(function (prevState) {\n          return {\n            prevContext: relayContext,\n            contextForChildren: relayContext,\n            relayProp: _this2._buildRelayProp(relayContext),\n            resolverGeneration: prevState.resolverGeneration + 1\n          };\n        });\n      } else if (!this._hasFetched) {\n        this._resolver.setProps(nextProps);\n      }\n\n      var data = this._resolver.resolve();\n\n      if (data !== this.state.data) {\n        this.setState({\n          data: data\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n\n      this._cleanup();\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp || nextState.resolverGeneration !== this.state.resolverGeneration) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === '__relayContext') {\n          if (nextState.prevContext.environment !== this.state.prevContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto._buildRelayProp = function _buildRelayProp(relayContext) {\n      return {\n        hasMore: this._hasMore,\n        isLoading: this._isLoading,\n        loadMore: this._loadMore,\n        refetchConnection: this._refetchConnection,\n        environment: relayContext.environment\n      };\n    };\n\n    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var data = this.state.data; // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = this._resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n\n    _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {\n      var data = this.state.data;\n\n      var maybeNewData = this._resolver.resolve(); // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n\n      this._resolver.setCallback(this.props, this._handleFragmentDataUpdate); // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n    /**\n     * Render new data for the existing props/context.\n     */\n    ;\n\n    _proto._getConnectionData = function _getConnectionData() {\n      // Extract connection data and verify there are more edges to fetch\n      var _this$props = this.props,\n          _ = _this$props.componentRef,\n          restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, [\"componentRef\"]);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var connectionData = getConnectionFromProps(props);\n\n      if (connectionData == null) {\n        return null;\n      }\n\n      var _ConnectionInterface$2 = ConnectionInterface.get(),\n          EDGES = _ConnectionInterface$2.EDGES,\n          PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,\n          HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,\n          HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,\n          END_CURSOR = _ConnectionInterface$2.END_CURSOR,\n          START_CURSOR = _ConnectionInterface$2.START_CURSOR;\n\n      !(typeof connectionData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : invariant(false) : void 0;\n      var edges = connectionData[EDGES];\n      var pageInfo = connectionData[PAGE_INFO];\n\n      if (edges == null || pageInfo == null) {\n        return null;\n      }\n\n      !Array.isArray(edges) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : invariant(false) : void 0;\n      !(typeof pageInfo === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : invariant(false) : void 0;\n      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n\n      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        return null;\n      }\n\n      return {\n        cursor: cursor,\n        edgeCount: edges.length,\n        hasMore: hasMore\n      };\n    };\n\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n\n      return this._queryFetcher;\n    };\n\n    _proto._canFetchPage = function _canFetchPage(method) {\n      if (this._isUnmounted) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : void 0;\n        return false;\n      }\n\n      return true;\n    };\n\n    _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {\n      var _this3 = this;\n\n      var _assertRelayContext = assertRelayContext(this.props.__relayContext),\n          environment = _assertRelayContext.environment;\n\n      var _this$props2 = this.props,\n          _ = _this$props2.componentRef,\n          __relayContext = _this$props2.__relayContext,\n          __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer,\n          restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props2, [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"]);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var fragmentVariables;\n      var rootVariables = getRootVariablesForFragments(fragments, restProps);\n      fragmentVariables = getVariablesFromObject(fragments, restProps);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, rootVariables), fragmentVariables), this._refetchVariables);\n      var fetchVariables = connectionConfig.getVariables(props, {\n        count: paginatingVariables.count,\n        cursor: paginatingVariables.cursor\n      }, fragmentVariables);\n      !(typeof fetchVariables === 'object' && fetchVariables !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : invariant(false) : void 0;\n      fetchVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), this._refetchVariables);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), fragmentVariables);\n      var cacheConfig = options ? {\n        force: !!options.force\n      } : undefined;\n\n      if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n        cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n      }\n\n      var request = getRequest(connectionConfig.query);\n      var operation = createOperationDescriptor(request, fetchVariables, cacheConfig);\n      var refetchSubscription = null;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n      }\n\n      this._hasFetched = true;\n\n      var onNext = function onNext(payload, complete) {\n        var prevData = _this3._resolver.resolve();\n\n        _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);\n\n        var nextData = _this3._resolver.resolve(); // Workaround slightly different handling for connection in different\n        // core implementations:\n        // - Classic core requires the count to be explicitly incremented\n        // - Modern core automatically appends new items, updating the count\n        //   isn't required to see new data.\n        //\n        // `setState` is only required if changing the variables would change the\n        // resolved data.\n        // TODO #14894725: remove PaginationContainer equal check\n\n\n        if (!areEqual(prevData, nextData)) {\n          _this3.setState({\n            data: nextData,\n            contextForChildren: {\n              environment: _this3.props.__relayContext.environment\n            }\n          }, complete);\n        } else {\n          complete();\n        }\n      };\n\n      var cleanup = function cleanup() {\n        if (_this3._refetchSubscription === refetchSubscription) {\n          _this3._refetchSubscription = null;\n          _this3._isARequestInFlight = false;\n        }\n      };\n\n      this._isARequestInFlight = true;\n      refetchSubscription = this._getQueryFetcher().execute({\n        environment: environment,\n        operation: operation,\n        preservePreviousReferences: true\n      }).mergeMap(function (payload) {\n        return Observable.create(function (sink) {\n          onNext(payload, function () {\n            sink.next(); // pass void to public observer's `next`\n\n            sink.complete();\n          });\n        });\n      }) // use do instead of finally so that observer's `complete` fires after cleanup\n      [\"do\"]({\n        error: cleanup,\n        complete: cleanup,\n        unsubscribe: cleanup\n      }).subscribe(observer || {});\n      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;\n      return refetchSubscription;\n    };\n\n    _proto._cleanup = function _cleanup() {\n      this._resolver.dispose();\n\n      this._refetchVariables = null;\n      this._hasFetched = false;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n\n        this._refetchSubscription = null;\n        this._isARequestInFlight = false;\n      }\n\n      if (this._queryFetcher) {\n        this._queryFetcher.dispose();\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props3 = this.props,\n          componentRef = _this$props3.componentRef,\n          __relayContext = _this$props3.__relayContext,\n          __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer,\n          props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props3, [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"]);\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: this.state.contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      })));\n    };\n\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _temp;\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, connectionConfig) {\n  // $FlowFixMe[incompatible-return]\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, connectionConfig);\n  });\n}\n\nmodule.exports = {\n  createContainer: createContainer\n};","map":{"version":3,"names":["_interopRequireDefault","require","_extends2","_objectWithoutPropertiesLoose2","_assertThisInitialized2","_inheritsLoose2","_defineProperty2","_objectSpread3","buildReactRelayContainer","getRootVariablesForFragments","_require","getComponentName","getContainerName","ReactRelayContext","ReactRelayQueryFetcher","_require2","assertRelayContext","areEqual","invariant","React","_require3","ConnectionInterface","Observable","RelayFeatureFlags","createFragmentSpecResolver","createOperationDescriptor","getDataIDsFromObject","getRequest","getVariablesFromObject","isScalarAndEqual","warning","FORWARD","createGetConnectionFromProps","metadata","path","process","env","NODE_ENV","props","data","fragmentName","i","length","createGetFragmentVariables","countVariable","count","prevVars","totalCount","findConnectionMetadata","fragments","foundConnectionMetadata","isRelayModern","fragment","connectionMetadata","connection","undefined","toObserver","observerOrCallback","error","complete","unsubscribe","subscription","createContainerWithFragments","Component","connectionConfig","_class","_temp","componentName","containerName","getConnectionFromProps","direction","getFragmentVariables","_React$Component","_props$__rootIsQueryR","_this","call","setState","_resolver","resolve","connectionData","_getConnectionData","hasMore","cursor","_refetchSubscription","refetchVariables","_canFetchPage","dispose","_refetchVariables","paginatingVariables","fetch","_fetchPage","force","pageSize","options","observer","create","sink","subscribe","edgeCount","_refetchConnection","_ConnectionInterface$","get","END_CURSOR","START_CURSOR","relayContext","__relayContext","rootIsQueryRenderer","__rootIsQueryRenderer","_isARequestInFlight","ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT","_handleFragmentDataUpdate","state","prevContext","contextForChildren","relayProp","_buildRelayProp","resolverGeneration","_isUnmounted","_hasFetched","_proto","prototype","componentDidMount","_subscribeToNewResolverAndRerenderIfStoreHasChanged","componentDidUpdate","prevProps","prevState","_rerenderIfStoreHasChanged","UNSAFE_componentWillReceiveProps","nextProps","_this2","_nextProps$__rootIsQu","prevIDs","nextIDs","prevRootVariables","nextRootVariables","environment","_cleanup","setProps","componentWillUnmount","shouldComponentUpdate","nextState","keys","Object","ii","_key","hasOwnProperty","_hasMore","isLoading","_isLoading","loadMore","_loadMore","refetchConnection","maybeNewData","setCallback","_this$props","_","componentRef","restProps","_ConnectionInterface$2","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","edges","pageInfo","Array","isArray","_getQueryFetcher","_queryFetcher","method","_this3","_assertRelayContext","_this$props2","fragmentVariables","rootVariables","fetchVariables","getVariables","cacheConfig","request","query","operation","refetchSubscription","onNext","payload","prevData","setVariables","node","nextData","cleanup","execute","preservePreviousReferences","mergeMap","next","render","_this$props3","createElement","Provider","value","ref","relay","createContainer","fragmentSpec","ComponentClass","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/ReactRelayPaginationContainer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectSpread3 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\n\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\n\nvar _require = require('./ReactRelayContainerUtils'),\n    getComponentName = _require.getComponentName,\n    getContainerName = _require.getContainerName;\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar _require2 = require('./RelayContext'),\n    assertRelayContext = _require2.assertRelayContext;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require3 = require('relay-runtime'),\n    ConnectionInterface = _require3.ConnectionInterface,\n    Observable = _require3.Observable,\n    RelayFeatureFlags = _require3.RelayFeatureFlags,\n    createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n    createOperationDescriptor = _require3.createOperationDescriptor,\n    getDataIDsFromObject = _require3.getDataIDsFromObject,\n    getRequest = _require3.getRequest,\n    getVariablesFromObject = _require3.getVariablesFromObject,\n    isScalarAndEqual = _require3.isScalarAndEqual;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar FORWARD = 'forward';\n\n/**\n * Extends the functionality of RelayFragmentContainer by providing a mechanism\n * to load more data from a connection.\n *\n * # Configuring a PaginationContainer\n *\n * PaginationContainer accepts the standard FragmentContainer arguments and an\n * additional `connectionConfig` argument:\n *\n * - `Component`: the component to be wrapped/rendered.\n * - `fragments`: an object whose values are `graphql` fragments. The object\n *   keys determine the prop names by which fragment data is available.\n * - `connectionConfig`: an object that determines how to load more connection\n *   data. Details below.\n *\n * # Loading More Data\n *\n * Use `props.relay.hasMore()` to determine if there are more items to load.\n *\n * ```\n * hasMore(): boolean\n * ```\n *\n * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`\n * is still pending. This is convenient for avoiding duplicate load calls.\n *\n * ```\n * isLoading(): boolean\n * ```\n *\n * Use `props.relay.loadMore()` to load more items. This will return null if\n * there are no more items to fetch, otherwise it will fetch more items and\n * return a Disposable that can be used to cancel the fetch.\n *\n * `pageSize` should be the number of *additional* items to fetch (not the\n * total).\n *\n * ```\n * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable\n * ```\n *\n * A complete example:\n *\n * ```\n * class Foo extends React.Component {\n *   ...\n *   _onEndReached() {\n *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n *       return;\n *     }\n *     this.props.relay.loadMore(10);\n *   }\n *   ...\n * }\n * ```\n *\n * # Connection Config\n *\n * Here's an example, followed by details of each config property:\n *\n * ```\n * ReactRelayPaginationContainer.createContainer(\n *   Component,\n *   {\n *     user: graphql`fragment FriendsFragment on User {\n *       friends(after: $afterCursor first: $count) @connection {\n *         edges { ... }\n *         pageInfo {\n *           startCursor\n *           endCursor\n *           hasNextPage\n *           hasPreviousPage\n *         }\n *       }\n *     }`,\n *   },\n *   {\n *     direction: 'forward',\n *     getConnectionFromProps(props) {\n *       return props.user && props.user.friends;\n *     },\n *     getFragmentVariables(vars, totalCount) {\n *       // The component presumably wants *all* edges, not just those after\n *       // the cursor, so notice that we don't set $afterCursor here.\n *       return {\n *         ...vars,\n *         count: totalCount,\n *       };\n *     },\n *     getVariables(props, {count, cursor}, fragmentVariables) {\n *       return {\n *         id: props.user.id,\n *         afterCursor: cursor,\n *         count,\n *       },\n *     },\n *     query: graphql`\n *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {\n *         node(id: $id) {\n *           ...FriendsFragment\n *         }\n *       }\n *     `,\n *   }\n * );\n * ```\n *\n * ## Config Properties\n *\n * - `direction`: Either \"forward\" to indicate forward pagination using\n *   after/first, or \"backward\" to indicate backward pagination using\n *   before/last.\n * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know\n *   which connection data you mean to fetch more of (a container might fetch\n *   multiple connections, but can only paginate one of them). This function is\n *   given the fragment props only (not full props), and should return the\n *   connection data. See the above example that returns the friends data via\n *   `props.user.friends`.\n * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables\n *   and the new total number of items, get the variables to use when reading\n *   your fragments. Typically this means setting whatever your local \"count\"\n *   variable is to the value of `totalCount`. See the example.\n * - `getVariables(props, {count, cursor})`: Get the variables to use when\n *   fetching the pagination `query`. You may determine the root object id from\n *   props (see the example that uses `props.user.id`) and may also set whatever\n *   variables you use for the after/first/before/last calls based on the count\n *   and cursor.\n * - `query`: A query to use when fetching more connection data. This should\n *   typically reference one of the container's fragment (as in the example)\n *   to ensure that all the necessary fields for sub-components are fetched.\n */\nfunction createGetConnectionFromProps(metadata) {\n  var path = metadata.path;\n  !path ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : invariant(false) : void 0;\n  return function (props) {\n    var data = props[metadata.fragmentName];\n\n    for (var i = 0; i < path.length; i++) {\n      if (!data || typeof data !== 'object') {\n        return null;\n      }\n\n      data = data[path[i]];\n    }\n\n    return data;\n  };\n}\n\nfunction createGetFragmentVariables(metadata) {\n  var countVariable = metadata.count;\n  !countVariable ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : invariant(false) : void 0;\n  return function (prevVars, totalCount) {\n    return (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, prevVars), {}, (0, _defineProperty2[\"default\"])({}, countVariable, totalCount));\n  };\n}\n\nfunction findConnectionMetadata(fragments) {\n  var foundConnectionMetadata = null;\n  var isRelayModern = false;\n\n  for (var fragmentName in fragments) {\n    var fragment = fragments[fragmentName];\n    var connectionMetadata = fragment.metadata && fragment.metadata.connection; // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n\n    if (fragment.metadata !== undefined) {\n      isRelayModern = true;\n    }\n\n    if (connectionMetadata) {\n      !(connectionMetadata.length === 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', fragmentName, connectionMetadata.length) : invariant(false) : void 0;\n      !!foundConnectionMetadata ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : invariant(false) : void 0;\n      foundConnectionMetadata = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, connectionMetadata[0]), {}, {\n        fragmentName: fragmentName\n      });\n    }\n  }\n\n  !(!isRelayModern || foundConnectionMetadata !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : invariant(false) : void 0;\n  return foundConnectionMetadata || {};\n}\n\nfunction toObserver(observerOrCallback) {\n  return typeof observerOrCallback === 'function' ? {\n    error: observerOrCallback,\n    complete: observerOrCallback,\n    unsubscribe: function unsubscribe(subscription) {\n      typeof observerOrCallback === 'function' && observerOrCallback();\n    }\n  } : observerOrCallback || {};\n}\n\nfunction createContainerWithFragments(Component, fragments, connectionConfig) {\n  var _class, _temp;\n\n  var componentName = getComponentName(Component);\n  var containerName = getContainerName(Component);\n  var metadata = findConnectionMetadata(fragments);\n  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);\n  var direction = connectionConfig.direction || metadata.direction;\n  !direction ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : invariant(false) : void 0;\n  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);\n  return _temp = _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n\n    function _class(props) {\n      var _props$__rootIsQueryR, _this;\n\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        _this.setState({\n          data: _this._resolver.resolve()\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_hasMore\", function () {\n        var connectionData = _this._getConnectionData();\n\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_isLoading\", function () {\n        return !!_this._refetchSubscription;\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetchConnection\", function (totalCount, observerOrCallback, refetchVariables) {\n        if (!_this._canFetchPage('refetchConnection')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        _this._refetchVariables = refetchVariables;\n        var paginatingVariables = {\n          count: totalCount,\n          cursor: null,\n          totalCount: totalCount\n        };\n\n        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {\n          force: true\n        });\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_loadMore\", function (pageSize, observerOrCallback, options) {\n        if (!_this._canFetchPage('loadMore')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        var observer = toObserver(observerOrCallback);\n\n        var connectionData = _this._getConnectionData();\n\n        if (!connectionData) {\n          Observable.create(function (sink) {\n            return sink.complete();\n          }).subscribe(observer);\n          return null;\n        }\n\n        var totalCount = connectionData.edgeCount + pageSize;\n\n        if (options && options.force) {\n          return _this._refetchConnection(totalCount, observerOrCallback);\n        }\n\n        var _ConnectionInterface$ = ConnectionInterface.get(),\n            END_CURSOR = _ConnectionInterface$.END_CURSOR,\n            START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n        var cursor = connectionData.cursor;\n        process.env.NODE_ENV !== \"production\" ? warning(cursor != null && cursor !== '', 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        var paginatingVariables = {\n          count: pageSize,\n          cursor: cursor,\n          totalCount: totalCount\n        };\n\n        var fetch = _this._fetchPage(paginatingVariables, observer, options);\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;\n      _this._isARequestInFlight = false;\n      _this._refetchSubscription = null;\n      _this._refetchVariables = null;\n\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);\n      } else {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);\n      }\n\n      _this.state = {\n        data: _this._resolver.resolve(),\n        prevContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: _this._buildRelayProp(relayContext),\n        resolverGeneration: 0\n      };\n      _this._isUnmounted = false;\n      _this._hasFetched = false;\n      return _this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      this._isUnmounted = false;\n\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n      }\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        if (prevState.resolverGeneration !== this.state.resolverGeneration) {\n          this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n        } else {\n          this._rerenderIfStoreHasChanged();\n        }\n      }\n    }\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */\n    ;\n\n    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      var _nextProps$__rootIsQu;\n\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;\n      var prevIDs = getDataIDsFromObject(fragments, this.props);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, this.props);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps); // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (relayContext.environment !== this.state.prevContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        this._cleanup(); // Child containers rely on context.relay being mutated (for gDSFP).\n\n\n        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);\n        } else {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);\n        }\n\n        this.setState(function (prevState) {\n          return {\n            prevContext: relayContext,\n            contextForChildren: relayContext,\n            relayProp: _this2._buildRelayProp(relayContext),\n            resolverGeneration: prevState.resolverGeneration + 1\n          };\n        });\n      } else if (!this._hasFetched) {\n        this._resolver.setProps(nextProps);\n      }\n\n      var data = this._resolver.resolve();\n\n      if (data !== this.state.data) {\n        this.setState({\n          data: data\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n\n      this._cleanup();\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp || nextState.resolverGeneration !== this.state.resolverGeneration) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === '__relayContext') {\n          if (nextState.prevContext.environment !== this.state.prevContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto._buildRelayProp = function _buildRelayProp(relayContext) {\n      return {\n        hasMore: this._hasMore,\n        isLoading: this._isLoading,\n        loadMore: this._loadMore,\n        refetchConnection: this._refetchConnection,\n        environment: relayContext.environment\n      };\n    };\n\n    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var data = this.state.data; // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = this._resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n\n    _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {\n      var data = this.state.data;\n\n      var maybeNewData = this._resolver.resolve(); // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n\n      this._resolver.setCallback(this.props, this._handleFragmentDataUpdate); // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n    /**\n     * Render new data for the existing props/context.\n     */\n    ;\n\n    _proto._getConnectionData = function _getConnectionData() {\n      // Extract connection data and verify there are more edges to fetch\n      var _this$props = this.props,\n          _ = _this$props.componentRef,\n          restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, [\"componentRef\"]);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var connectionData = getConnectionFromProps(props);\n\n      if (connectionData == null) {\n        return null;\n      }\n\n      var _ConnectionInterface$2 = ConnectionInterface.get(),\n          EDGES = _ConnectionInterface$2.EDGES,\n          PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,\n          HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,\n          HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,\n          END_CURSOR = _ConnectionInterface$2.END_CURSOR,\n          START_CURSOR = _ConnectionInterface$2.START_CURSOR;\n\n      !(typeof connectionData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : invariant(false) : void 0;\n      var edges = connectionData[EDGES];\n      var pageInfo = connectionData[PAGE_INFO];\n\n      if (edges == null || pageInfo == null) {\n        return null;\n      }\n\n      !Array.isArray(edges) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : invariant(false) : void 0;\n      !(typeof pageInfo === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : invariant(false) : void 0;\n      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n\n      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        return null;\n      }\n\n      return {\n        cursor: cursor,\n        edgeCount: edges.length,\n        hasMore: hasMore\n      };\n    };\n\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n\n      return this._queryFetcher;\n    };\n\n    _proto._canFetchPage = function _canFetchPage(method) {\n      if (this._isUnmounted) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : void 0;\n        return false;\n      }\n\n      return true;\n    };\n\n    _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {\n      var _this3 = this;\n\n      var _assertRelayContext = assertRelayContext(this.props.__relayContext),\n          environment = _assertRelayContext.environment;\n\n      var _this$props2 = this.props,\n          _ = _this$props2.componentRef,\n          __relayContext = _this$props2.__relayContext,\n          __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer,\n          restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props2, [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"]);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var fragmentVariables;\n      var rootVariables = getRootVariablesForFragments(fragments, restProps);\n      fragmentVariables = getVariablesFromObject(fragments, restProps);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, rootVariables), fragmentVariables), this._refetchVariables);\n      var fetchVariables = connectionConfig.getVariables(props, {\n        count: paginatingVariables.count,\n        cursor: paginatingVariables.cursor\n      }, fragmentVariables);\n      !(typeof fetchVariables === 'object' && fetchVariables !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : invariant(false) : void 0;\n      fetchVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), this._refetchVariables);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), fragmentVariables);\n      var cacheConfig = options ? {\n        force: !!options.force\n      } : undefined;\n\n      if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n        cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n      }\n\n      var request = getRequest(connectionConfig.query);\n      var operation = createOperationDescriptor(request, fetchVariables, cacheConfig);\n      var refetchSubscription = null;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n      }\n\n      this._hasFetched = true;\n\n      var onNext = function onNext(payload, complete) {\n        var prevData = _this3._resolver.resolve();\n\n        _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);\n\n        var nextData = _this3._resolver.resolve(); // Workaround slightly different handling for connection in different\n        // core implementations:\n        // - Classic core requires the count to be explicitly incremented\n        // - Modern core automatically appends new items, updating the count\n        //   isn't required to see new data.\n        //\n        // `setState` is only required if changing the variables would change the\n        // resolved data.\n        // TODO #14894725: remove PaginationContainer equal check\n\n\n        if (!areEqual(prevData, nextData)) {\n          _this3.setState({\n            data: nextData,\n            contextForChildren: {\n              environment: _this3.props.__relayContext.environment\n            }\n          }, complete);\n        } else {\n          complete();\n        }\n      };\n\n      var cleanup = function cleanup() {\n        if (_this3._refetchSubscription === refetchSubscription) {\n          _this3._refetchSubscription = null;\n          _this3._isARequestInFlight = false;\n        }\n      };\n\n      this._isARequestInFlight = true;\n      refetchSubscription = this._getQueryFetcher().execute({\n        environment: environment,\n        operation: operation,\n        preservePreviousReferences: true\n      }).mergeMap(function (payload) {\n        return Observable.create(function (sink) {\n          onNext(payload, function () {\n            sink.next(); // pass void to public observer's `next`\n\n            sink.complete();\n          });\n        });\n      }) // use do instead of finally so that observer's `complete` fires after cleanup\n      [\"do\"]({\n        error: cleanup,\n        complete: cleanup,\n        unsubscribe: cleanup\n      }).subscribe(observer || {});\n      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;\n      return refetchSubscription;\n    };\n\n    _proto._cleanup = function _cleanup() {\n      this._resolver.dispose();\n\n      this._refetchVariables = null;\n      this._hasFetched = false;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n\n        this._refetchSubscription = null;\n        this._isARequestInFlight = false;\n      }\n\n      if (this._queryFetcher) {\n        this._queryFetcher.dispose();\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props3 = this.props,\n          componentRef = _this$props3.componentRef,\n          __relayContext = _this$props3.__relayContext,\n          __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer,\n          props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props3, [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"]);\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: this.state.contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      })));\n    };\n\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _temp;\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, connectionConfig) {\n  // $FlowFixMe[incompatible-return]\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, connectionConfig);\n  });\n}\n\nmodule.exports = {\n  createContainer: createContainer\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,SAAS,GAAGF,sBAAsB,CAACC,OAAO,CAAC,gCAAD,CAAR,CAAtC;;AAEA,IAAIE,8BAA8B,GAAGH,sBAAsB,CAACC,OAAO,CAAC,qDAAD,CAAR,CAA3D;;AAEA,IAAIG,uBAAuB,GAAGJ,sBAAsB,CAACC,OAAO,CAAC,8CAAD,CAAR,CAApD;;AAEA,IAAII,eAAe,GAAGL,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA5C;;AAEA,IAAIK,gBAAgB,GAAGN,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIM,cAAc,GAAGP,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA3C;;AAEA,IAAIO,wBAAwB,GAAGP,OAAO,CAAC,4BAAD,CAAtC;;AAEA,IAAIQ,4BAA4B,GAAGR,OAAO,CAAC,gCAAD,CAA1C;;AAEA,IAAIS,QAAQ,GAAGT,OAAO,CAAC,4BAAD,CAAtB;AAAA,IACIU,gBAAgB,GAAGD,QAAQ,CAACC,gBADhC;AAAA,IAEIC,gBAAgB,GAAGF,QAAQ,CAACE,gBAFhC;;AAIA,IAAIC,iBAAiB,GAAGZ,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAIa,sBAAsB,GAAGb,OAAO,CAAC,0BAAD,CAApC;;AAEA,IAAIc,SAAS,GAAGd,OAAO,CAAC,gBAAD,CAAvB;AAAA,IACIe,kBAAkB,GAAGD,SAAS,CAACC,kBADnC;;AAGA,IAAIC,QAAQ,GAAGhB,OAAO,CAAC,mBAAD,CAAtB;;AAEA,IAAIiB,SAAS,GAAGjB,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAIkB,KAAK,GAAGlB,OAAO,CAAC,OAAD,CAAnB;;AAEA,IAAImB,SAAS,GAAGnB,OAAO,CAAC,eAAD,CAAvB;AAAA,IACIoB,mBAAmB,GAAGD,SAAS,CAACC,mBADpC;AAAA,IAEIC,UAAU,GAAGF,SAAS,CAACE,UAF3B;AAAA,IAGIC,iBAAiB,GAAGH,SAAS,CAACG,iBAHlC;AAAA,IAIIC,0BAA0B,GAAGJ,SAAS,CAACI,0BAJ3C;AAAA,IAKIC,yBAAyB,GAAGL,SAAS,CAACK,yBAL1C;AAAA,IAMIC,oBAAoB,GAAGN,SAAS,CAACM,oBANrC;AAAA,IAOIC,UAAU,GAAGP,SAAS,CAACO,UAP3B;AAAA,IAQIC,sBAAsB,GAAGR,SAAS,CAACQ,sBARvC;AAAA,IASIC,gBAAgB,GAAGT,SAAS,CAACS,gBATjC;;AAWA,IAAIC,OAAO,GAAG7B,OAAO,CAAC,kBAAD,CAArB;;AAEA,IAAI8B,OAAO,GAAG,SAAd;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,4BAAT,CAAsCC,QAAtC,EAAgD;EAC9C,IAAIC,IAAI,GAAGD,QAAQ,CAACC,IAApB;EACA,CAACA,IAAD,GAAQC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnB,SAAS,CAAC,KAAD,EAAQ,2DAA2D,kCAAnE,CAAjD,GAA0JA,SAAS,CAAC,KAAD,CAA3K,GAAqL,KAAK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"},"metadata":{},"sourceType":"script"}