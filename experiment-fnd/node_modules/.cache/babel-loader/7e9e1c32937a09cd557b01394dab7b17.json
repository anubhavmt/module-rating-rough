{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayRecordState'),\n    EXISTENT = _require3.EXISTENT,\n    UNKNOWN = _require3.UNKNOWN;\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require4 = require('./TypeID'),\n    generateTypeID = _require4.generateTypeID;\n\nvar invariant = require('invariant');\n\nvar ACTOR_CHANGE = RelayConcreteNode.ACTOR_CHANGE,\n    CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    this._getSourceForActor = getSourceForActor;\n    this._getTargetForActor = getTargetForActor;\n    this._getDataID = getDataID;\n    this._source = getSourceForActor(defaultActorIdentifier);\n    this._mutatorRecordSourceProxyCache = new Map();\n\n    var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier),\n        mutator = _this$_getMutatorAndR[0],\n        recordSourceProxy = _this$_getMutatorAndR[1];\n\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = recordSourceProxy;\n    this._recordWasMissing = false;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {\n    var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);\n\n    if (tuple == null) {\n      var target = this._getTargetForActor(actorIdentifier);\n\n      var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);\n      var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n      tuple = [mutator, recordSourceProxy];\n\n      this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);\n    }\n\n    return tuple;\n  };\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          _this2._checkActorChange(selection.linkedField, dataID);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(_this2._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var _abstractKey = selection.abstractKey;\n\n            if (_abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var _recordType = _this2._mutator.getType(dataID);\n\n              !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n              var _typeID = generateTypeID(_recordType);\n\n              var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n              if (_implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (_implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          var prevVariables = _this2._variables;\n          _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          _this2._variables = prevVariables;\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          var abstractKey = selection.abstractKey;\n\n          var recordType = _this2._mutator.getType(dataID);\n\n          !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n          var typeID = generateTypeID(recordType);\n\n          var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n          if (implementsInterface == null) {\n            // unsure if the type implements the interface: data is\n            // missing\n            _this2._handleMissing();\n          } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n      var prevVariables = this._variables;\n      this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);\n\n      this._traverse(operation, dataID);\n\n      this._variables = prevVariables;\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkActorChange = function _checkActorChange(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var record = this._source.get(dataID);\n\n    var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;\n\n    if (tuple == null) {\n      if (tuple === undefined) {\n        this._handleMissing();\n      }\n    } else {\n      var _actorIdentifier = tuple[0],\n          linkedID = tuple[1];\n      var prevSource = this._source;\n      var prevMutator = this._mutator;\n      var prevRecordSourceProxy = this._recordSourceProxy;\n\n      var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(_actorIdentifier),\n          mutator = _this$_getMutatorAndR2[0],\n          recordSourceProxy = _this$_getMutatorAndR2[1];\n\n      this._source = this._getSourceForActor(_actorIdentifier);\n      this._mutator = mutator;\n      this._recordSourceProxy = recordSourceProxy;\n\n      this._traverse(field, linkedID);\n\n      this._source = prevSource;\n      this._mutator = prevMutator;\n      this._recordSourceProxy = prevRecordSourceProxy;\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};","map":{"version":3,"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","RelayRecordSourceMutator","RelayRecordSourceProxy","getOperation","RelayConcreteNode","RelayFeatureFlags","_require","isClientID","cloneRelayHandleSourceField","cloneRelayScalarHandleSourceField","_require2","getLocalVariables","RelayModernRecord","_require3","EXISTENT","UNKNOWN","RelayStoreReactFlightUtils","RelayStoreUtils","_require4","generateTypeID","invariant","ACTOR_CHANGE","CONDITION","CLIENT_COMPONENT","CLIENT_EXTENSION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","LINKED_HANDLE","MODULE_IMPORT","SCALAR_FIELD","SCALAR_HANDLE","STREAM","TYPE_DISCRIMINATOR","ROOT_ID","getModuleOperationKey","getStorageKey","getArgumentValues","check","getSourceForActor","getTargetForActor","defaultActorIdentifier","selector","handlers","operationLoader","getDataID","shouldProcessClientComponents","dataID","node","variables","checker","DataChecker","_getSourceForActor","_getTargetForActor","_getDataID","_source","_mutatorRecordSourceProxyCache","Map","_this$_getMutatorAndR","_getMutatorAndRecordProxyForActor","mutator","recordSourceProxy","_mostRecentlyInvalidatedAt","_handlers","_mutator","_operationLoader","_recordSourceProxy","_recordWasMissing","_variables","_shouldProcessClientComponents","_proto","prototype","actorIdentifier","tuple","get","target","set","_traverse","status","mostRecentlyInvalidatedAt","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","_handleMissing","_getDataForHandlers","field","args","record","_handleMissingScalarField","alias","undefined","_this$_getDataForHand","_iterator","_step","s","n","done","handler","value","kind","newValue","handle","err","e","f","_handleMissingLinkField","_this$_getDataForHand2","_iterator2","_step2","getStatus","_handleMissingPluralLinkField","_this","_this$_getDataForHand3","_iterator3","_step3","allItemsKnown","every","linkedID","invalidatedAt","getInvalidationEpoch","Math","max","_traverseSelections","selections","_this2","forEach","selection","_checkScalar","plural","_checkPluralLink","_checkLink","_checkActorChange","linkedField","conditionValue","Boolean","condition","passingValue","_abstractKey","abstractKey","typeName","getType","type","_recordType","_typeID","_implementsInterface","getValue","handleField","_handleField","_checkModuleImport","prevVariables","fragment","argumentDefinitions","recordWasMissing","recordType","typeID","implementsInterface","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_checkFlightField","Error","moduleImport","operationKey","documentName","operationReference","normalizationRootNode","operation","storageKey","fieldValue","setValue","getLinkedRecordID","setLinkedRecordID","_this3","linkedIDs","getLinkedRecordIDs","setLinkedRecordIDs","getActorLinkedRecordID","_actorIdentifier","prevSource","prevMutator","prevRecordSourceProxy","_this$_getMutatorAndR2","tree","REACT_FLIGHT_TREE_STORAGE_KEY","reachableExecutableDefinitions","REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY","Array","isArray","_iterator4","_step4","definition","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/DataChecker.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayRecordState'),\n    EXISTENT = _require3.EXISTENT,\n    UNKNOWN = _require3.UNKNOWN;\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require4 = require('./TypeID'),\n    generateTypeID = _require4.generateTypeID;\n\nvar invariant = require('invariant');\n\nvar ACTOR_CHANGE = RelayConcreteNode.ACTOR_CHANGE,\n    CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    this._getSourceForActor = getSourceForActor;\n    this._getTargetForActor = getTargetForActor;\n    this._getDataID = getDataID;\n    this._source = getSourceForActor(defaultActorIdentifier);\n    this._mutatorRecordSourceProxyCache = new Map();\n\n    var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier),\n        mutator = _this$_getMutatorAndR[0],\n        recordSourceProxy = _this$_getMutatorAndR[1];\n\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = recordSourceProxy;\n    this._recordWasMissing = false;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {\n    var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);\n\n    if (tuple == null) {\n      var target = this._getTargetForActor(actorIdentifier);\n\n      var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);\n      var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n      tuple = [mutator, recordSourceProxy];\n\n      this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);\n    }\n\n    return tuple;\n  };\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          _this2._checkActorChange(selection.linkedField, dataID);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(_this2._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var _abstractKey = selection.abstractKey;\n\n            if (_abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var _recordType = _this2._mutator.getType(dataID);\n\n              !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n              var _typeID = generateTypeID(_recordType);\n\n              var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n              if (_implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (_implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          var prevVariables = _this2._variables;\n          _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          _this2._variables = prevVariables;\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          var abstractKey = selection.abstractKey;\n\n          var recordType = _this2._mutator.getType(dataID);\n\n          !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n          var typeID = generateTypeID(recordType);\n\n          var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n          if (implementsInterface == null) {\n            // unsure if the type implements the interface: data is\n            // missing\n            _this2._handleMissing();\n          } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n      var prevVariables = this._variables;\n      this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);\n\n      this._traverse(operation, dataID);\n\n      this._variables = prevVariables;\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkActorChange = function _checkActorChange(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var record = this._source.get(dataID);\n\n    var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;\n\n    if (tuple == null) {\n      if (tuple === undefined) {\n        this._handleMissing();\n      }\n    } else {\n      var _actorIdentifier = tuple[0],\n          linkedID = tuple[1];\n      var prevSource = this._source;\n      var prevMutator = this._mutator;\n      var prevRecordSourceProxy = this._recordSourceProxy;\n\n      var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(_actorIdentifier),\n          mutator = _this$_getMutatorAndR2[0],\n          recordSourceProxy = _this$_getMutatorAndR2[1];\n\n      this._source = this._getSourceForActor(_actorIdentifier);\n      this._mutator = mutator;\n      this._recordSourceProxy = recordSourceProxy;\n\n      this._traverse(field, linkedID);\n\n      this._source = prevSource;\n      this._mutator = prevMutator;\n      this._recordSourceProxy = prevRecordSourceProxy;\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}