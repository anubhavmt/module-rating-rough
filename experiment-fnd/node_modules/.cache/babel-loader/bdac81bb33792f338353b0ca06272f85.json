{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    Observable = _require.Observable,\n    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    ReplaySubject = _require.ReplaySubject,\n    fetchQueryDeduped = _require.__internal.fetchQueryDeduped,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    getRequest = _require.getRequest,\n    getRequestIdentifier = _require.getRequestIdentifier;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar RenderDispatcher = null;\nvar fetchKey = 100001;\n\nfunction useTrackLoadQueryInRender() {\n  if (RenderDispatcher === null) {\n    var _React$__SECRET_INTER, _React$__SECRET_INTER2; // Flow does not know of React internals (rightly so), but we need to\n    // ensure here that this function isn't called inside render.\n\n\n    RenderDispatcher = // $FlowFixMe[prop-missing]\n    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;\n  }\n}\n\nfunction loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {\n  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy; // This code ensures that we don't call loadQuery during render.\n\n\n  var CurrentDispatcher = // $FlowFixMe[prop-missing]\n  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;\n  process.env.NODE_ENV !== \"production\" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.\n  // This will ensure that every query reference that is created and\n  // passed to usePreloadedQuery is independently evaluated,\n  // even if they are for the same query/variables.\n  // Specifically, we want to avoid a case where we try to refetch a\n  // query by calling loadQuery a second time, and have the Suspense\n  // cache in usePreloadedQuery reuse the cached result instead of\n  // re-evaluating the new query ref and triggering a refetch if\n  // necessary.\n\n  fetchKey++;\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {\n    force: true\n  }); // executeWithNetworkSource will retain and execute an operation\n  // against the Relay store, given an Observable that would provide\n  // the network events for the operation.\n\n  var retainReference;\n  var didExecuteNetworkSource = false;\n\n  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {\n    didExecuteNetworkSource = true;\n    return environment.executeWithSource({\n      operation: operation,\n      source: networkObservable\n    });\n  }; // N.B. For loadQuery, we unconventionally want to return an Observable\n  // that isn't lazily executed, meaning that we don't want to wait\n  // until the returned Observable is subscribed to to actually start\n  // fetching and executing an operation; i.e. we want to execute the\n  // operation eagerly, when loadQuery is called.\n  // For this reason, we use an intermediate executionSubject which\n  // allows us to capture the events that occur during the eager execution\n  // of the operation, and then replay them to the Observable we\n  // ultimately return.\n\n\n  var executionSubject = new ReplaySubject();\n  var returnedObservable = Observable.create(function (sink) {\n    return executionSubject.subscribe(sink);\n  });\n  var unsubscribeFromNetworkRequest;\n  var networkError = null; // makeNetworkRequest will immediately start a raw network request if\n  // one isn't already in flight and return an Observable that when\n  // subscribed to will replay the network events that have occured so far,\n  // as well as subsequent events.\n\n  var didMakeNetworkRequest = false;\n\n  var makeNetworkRequest = function makeNetworkRequest(params) {\n    // N.B. this function is called synchronously or not at all\n    // didMakeNetworkRequest is safe to rely on in the returned value\n    // Even if the request gets deduped below, we still wan't to return an\n    // observable that provides the replayed network events for the query,\n    // so we set this to true before deduping, to guarantee that the\n    // `source` observable is returned.\n    didMakeNetworkRequest = true;\n    var observable;\n    var subject = new ReplaySubject();\n\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // Here, we are calling fetchQueryDeduped at the network layer level,\n      // which ensures that only a single network request is active for a given\n      // (environment, identifier) pair.\n      // Since network requests can be started /before/ we have the query ast\n      // necessary to process the results, we need to dedupe the raw requests\n      // separately from deduping the operation execution; specifically,\n      // if `loadQuery` is called multiple times before the query ast is available,\n      // we still want the network request to be deduped.\n      // - If a duplicate active network request is found, it will return an\n      // Observable that replays the events of the already active request.\n      // - If no duplicate active network request is found, it will call the fetchFn\n      // to start the request, and return an Observable that will replay\n      // the events from the network request.\n      // We provide an extra key to the identifier to distinguish deduping\n      // of raw network requests vs deduping of operation executions.\n      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);\n      observable = fetchQueryDeduped(environment, identifier, function () {\n        var network = environment.getNetwork();\n        return network.execute(params, variables, networkCacheConfig);\n      });\n    } else {\n      var network = environment.getNetwork();\n      observable = network.execute(params, variables, networkCacheConfig);\n    }\n\n    var _observable$subscribe = observable.subscribe({\n      error: function error(err) {\n        networkError = err;\n        subject.error(err);\n      },\n      next: function next(data) {\n        subject.next(data);\n      },\n      complete: function complete() {\n        subject.complete();\n      }\n    }),\n        unsubscribe = _observable$subscribe.unsubscribe;\n\n    unsubscribeFromNetworkRequest = unsubscribe;\n    return Observable.create(function (sink) {\n      var subjectSubscription = subject.subscribe(sink);\n      return function () {\n        subjectSubscription.unsubscribe();\n        unsubscribeFromNetworkRequest();\n      };\n    });\n  };\n\n  var unsubscribeFromExecution;\n\n  var executeDeduped = function executeDeduped(operation, fetchFn) {\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),\n      // we are guaranteed to have started a network request. We set this to\n      // true here as well since `makeNetworkRequest` might get skipped in the case\n      // where the query ast is already available and the query executions get deduped.\n      // Even if the execution gets deduped below, we still wan't to return\n      // an observable that provides the replayed network events for the query,\n      // so we set this to true before deduping, to guarantee that the `source`\n      // observable is returned.\n      didMakeNetworkRequest = true;\n    } // Here, we are calling fetchQueryDeduped, which ensures that only\n    // a single operation is active for a given (environment, identifier) pair,\n    // and also tracks the active state of the operation, which is necessary\n    // for our Suspense infra to later be able to suspend (or not) on\n    // active operations. Even though we already dedupe raw network requests,\n    // we also need to dedupe and keep track operation execution for our Suspense\n    // infra, and we also want to avoid processing responses more than once, for\n    // the cases where `loadQuery` might be called multiple times after the query ast\n    // is available.\n    // - If a duplicate active operation is found, it will return an\n    // Observable that replays the events of the already active operation.\n    // - If no duplicate active operation is found, it will call the fetchFn\n    // to execute the operation, and return an Observable that will provide\n    // the events for executing the operation.\n\n\n    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({\n      error: function error(err) {\n        executionSubject.error(err);\n      },\n      next: function next(data) {\n        executionSubject.next(data);\n      },\n      complete: function complete() {\n        executionSubject.complete();\n      }\n    });\n\n    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;\n  };\n\n  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {\n    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);\n    retainReference = environment.retain(operation);\n\n    if (fetchPolicy === 'store-only') {\n      return;\n    } // N.B. If the fetch policy allows fulfillment from the store but the\n    // environment already has the data for that operation cached in the store,\n    // then we do nothing.\n\n\n    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';\n\n    if (shouldFetch) {\n      executeDeduped(operation, function () {\n        // N.B. Since we have the operation synchronously available here,\n        // we can immediately fetch and execute the operation.\n        var networkObservable = makeNetworkRequest(concreteRequest.params);\n        var executeObservable = executeWithNetworkSource(operation, networkObservable);\n        return executeObservable;\n      });\n    }\n  };\n\n  var params;\n  var cancelOnLoadCallback;\n  var queryId;\n\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    var preloadableConcreteRequest = preloadableRequest;\n    params = preloadableConcreteRequest.params;\n    var _params = params;\n    queryId = _params.id;\n    !(queryId !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;\n\n    var _module = PreloadableQueryRegistry.get(queryId);\n\n    if (_module != null) {\n      checkAvailabilityAndExecute(_module);\n    } else {\n      // If the module isn't synchronously available, we launch the\n      // network request immediately if the fetchPolicy might produce\n      // a network fetch, regardless of the state of the store cache. We\n      // do this because we can't check if a query is cached without the\n      // ast, and we know that if we don't have the query ast\n      // available, then this query could've never been written to the\n      // store in the first place, so it couldn't have been cached.\n      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function (preloadedModule) {\n        cancelOnLoadCallback();\n        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);\n        retainReference = environment.retain(operation);\n\n        if (networkObservable != null) {\n          executeDeduped(operation, function () {\n            return executeWithNetworkSource(operation, networkObservable);\n          });\n        }\n      });\n\n      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;\n    }\n  } else {\n    var graphQlTaggedNode = preloadableRequest;\n    var request = getRequest(graphQlTaggedNode);\n    params = request.params;\n    queryId = params.cacheID != null ? params.cacheID : params.id;\n    checkAvailabilityAndExecute(request);\n  }\n\n  var isDisposed = false;\n  var isReleased = false;\n  var isNetworkRequestCancelled = false;\n\n  var releaseQuery = function releaseQuery() {\n    if (isReleased) {\n      return;\n    }\n\n    retainReference && retainReference.dispose();\n    isReleased = true;\n  };\n\n  var cancelNetworkRequest = function cancelNetworkRequest() {\n    if (isNetworkRequestCancelled) {\n      return;\n    }\n\n    if (didExecuteNetworkSource) {\n      unsubscribeFromExecution && unsubscribeFromExecution();\n    } else {\n      unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();\n    }\n\n    cancelOnLoadCallback && cancelOnLoadCallback();\n    isNetworkRequestCancelled = true;\n  };\n\n  return {\n    kind: 'PreloadedQuery',\n    environment: environment,\n    environmentProviderOptions: environmentProviderOptions,\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n\n      releaseQuery();\n      cancelNetworkRequest();\n      isDisposed = true;\n    },\n    releaseQuery: releaseQuery,\n    cancelNetworkRequest: cancelNetworkRequest,\n    fetchKey: fetchKey,\n    id: queryId,\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed || isReleased;\n    },\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get networkError() {\n      return networkError;\n    },\n\n    name: params.name,\n    networkCacheConfig: networkCacheConfig,\n    fetchPolicy: fetchPolicy,\n    source: didMakeNetworkRequest ? returnedObservable : undefined,\n    variables: variables\n  };\n}\n\nmodule.exports = {\n  loadQuery: loadQuery,\n  useTrackLoadQueryInRender: useTrackLoadQueryInRender\n};","map":{"version":3,"names":["_interopRequireDefault","require","_objectSpread2","invariant","React","_require","Observable","PreloadableQueryRegistry","RelayFeatureFlags","ReplaySubject","fetchQueryDeduped","__internal","createOperationDescriptor","getRequest","getRequestIdentifier","warning","RenderDispatcher","fetchKey","useTrackLoadQueryInRender","_React$__SECRET_INTER","_React$__SECRET_INTER2","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","current","loadQuery","environment","preloadableRequest","variables","options","environmentProviderOptions","_React$__SECRET_INTER3","_React$__SECRET_INTER4","_options$__nameForWar","_options$fetchPolicy","CurrentDispatcher","process","env","NODE_ENV","__nameForWarning","fetchPolicy","networkCacheConfig","force","retainReference","didExecuteNetworkSource","executeWithNetworkSource","operation","networkObservable","executeWithSource","source","executionSubject","returnedObservable","create","sink","subscribe","unsubscribeFromNetworkRequest","networkError","didMakeNetworkRequest","makeNetworkRequest","params","observable","subject","ENABLE_LOAD_QUERY_REQUEST_DEDUPING","identifier","network","getNetwork","execute","_observable$subscribe","error","err","next","data","complete","unsubscribe","subjectSubscription","unsubscribeFromExecution","executeDeduped","fetchFn","_fetchQueryDeduped$su","request","checkAvailabilityAndExecute","concreteRequest","retain","shouldFetch","check","status","executeObservable","cancelOnLoadCallback","queryId","kind","preloadableConcreteRequest","_params","id","name","_module","get","_PreloadableQueryRegi","onLoad","preloadedModule","dispose","graphQlTaggedNode","cacheID","isDisposed","isReleased","isNetworkRequestCancelled","releaseQuery","cancelNetworkRequest","undefined","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/react-relay/lib/relay-hooks/loadQuery.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    Observable = _require.Observable,\n    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    ReplaySubject = _require.ReplaySubject,\n    fetchQueryDeduped = _require.__internal.fetchQueryDeduped,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    getRequest = _require.getRequest,\n    getRequestIdentifier = _require.getRequestIdentifier;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar RenderDispatcher = null;\nvar fetchKey = 100001;\n\nfunction useTrackLoadQueryInRender() {\n  if (RenderDispatcher === null) {\n    var _React$__SECRET_INTER, _React$__SECRET_INTER2;\n\n    // Flow does not know of React internals (rightly so), but we need to\n    // ensure here that this function isn't called inside render.\n    RenderDispatcher = // $FlowFixMe[prop-missing]\n    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;\n  }\n}\n\nfunction loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {\n  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;\n\n  // This code ensures that we don't call loadQuery during render.\n  var CurrentDispatcher = // $FlowFixMe[prop-missing]\n  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;\n  process.env.NODE_ENV !== \"production\" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.\n  // This will ensure that every query reference that is created and\n  // passed to usePreloadedQuery is independently evaluated,\n  // even if they are for the same query/variables.\n  // Specifically, we want to avoid a case where we try to refetch a\n  // query by calling loadQuery a second time, and have the Suspense\n  // cache in usePreloadedQuery reuse the cached result instead of\n  // re-evaluating the new query ref and triggering a refetch if\n  // necessary.\n\n  fetchKey++;\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {\n    force: true\n  }); // executeWithNetworkSource will retain and execute an operation\n  // against the Relay store, given an Observable that would provide\n  // the network events for the operation.\n\n  var retainReference;\n  var didExecuteNetworkSource = false;\n\n  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {\n    didExecuteNetworkSource = true;\n    return environment.executeWithSource({\n      operation: operation,\n      source: networkObservable\n    });\n  }; // N.B. For loadQuery, we unconventionally want to return an Observable\n  // that isn't lazily executed, meaning that we don't want to wait\n  // until the returned Observable is subscribed to to actually start\n  // fetching and executing an operation; i.e. we want to execute the\n  // operation eagerly, when loadQuery is called.\n  // For this reason, we use an intermediate executionSubject which\n  // allows us to capture the events that occur during the eager execution\n  // of the operation, and then replay them to the Observable we\n  // ultimately return.\n\n\n  var executionSubject = new ReplaySubject();\n  var returnedObservable = Observable.create(function (sink) {\n    return executionSubject.subscribe(sink);\n  });\n  var unsubscribeFromNetworkRequest;\n  var networkError = null; // makeNetworkRequest will immediately start a raw network request if\n  // one isn't already in flight and return an Observable that when\n  // subscribed to will replay the network events that have occured so far,\n  // as well as subsequent events.\n\n  var didMakeNetworkRequest = false;\n\n  var makeNetworkRequest = function makeNetworkRequest(params) {\n    // N.B. this function is called synchronously or not at all\n    // didMakeNetworkRequest is safe to rely on in the returned value\n    // Even if the request gets deduped below, we still wan't to return an\n    // observable that provides the replayed network events for the query,\n    // so we set this to true before deduping, to guarantee that the\n    // `source` observable is returned.\n    didMakeNetworkRequest = true;\n    var observable;\n    var subject = new ReplaySubject();\n\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // Here, we are calling fetchQueryDeduped at the network layer level,\n      // which ensures that only a single network request is active for a given\n      // (environment, identifier) pair.\n      // Since network requests can be started /before/ we have the query ast\n      // necessary to process the results, we need to dedupe the raw requests\n      // separately from deduping the operation execution; specifically,\n      // if `loadQuery` is called multiple times before the query ast is available,\n      // we still want the network request to be deduped.\n      // - If a duplicate active network request is found, it will return an\n      // Observable that replays the events of the already active request.\n      // - If no duplicate active network request is found, it will call the fetchFn\n      // to start the request, and return an Observable that will replay\n      // the events from the network request.\n      // We provide an extra key to the identifier to distinguish deduping\n      // of raw network requests vs deduping of operation executions.\n      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);\n      observable = fetchQueryDeduped(environment, identifier, function () {\n        var network = environment.getNetwork();\n        return network.execute(params, variables, networkCacheConfig);\n      });\n    } else {\n      var network = environment.getNetwork();\n      observable = network.execute(params, variables, networkCacheConfig);\n    }\n\n    var _observable$subscribe = observable.subscribe({\n      error: function error(err) {\n        networkError = err;\n        subject.error(err);\n      },\n      next: function next(data) {\n        subject.next(data);\n      },\n      complete: function complete() {\n        subject.complete();\n      }\n    }),\n        unsubscribe = _observable$subscribe.unsubscribe;\n\n    unsubscribeFromNetworkRequest = unsubscribe;\n    return Observable.create(function (sink) {\n      var subjectSubscription = subject.subscribe(sink);\n      return function () {\n        subjectSubscription.unsubscribe();\n        unsubscribeFromNetworkRequest();\n      };\n    });\n  };\n\n  var unsubscribeFromExecution;\n\n  var executeDeduped = function executeDeduped(operation, fetchFn) {\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),\n      // we are guaranteed to have started a network request. We set this to\n      // true here as well since `makeNetworkRequest` might get skipped in the case\n      // where the query ast is already available and the query executions get deduped.\n      // Even if the execution gets deduped below, we still wan't to return\n      // an observable that provides the replayed network events for the query,\n      // so we set this to true before deduping, to guarantee that the `source`\n      // observable is returned.\n      didMakeNetworkRequest = true;\n    } // Here, we are calling fetchQueryDeduped, which ensures that only\n    // a single operation is active for a given (environment, identifier) pair,\n    // and also tracks the active state of the operation, which is necessary\n    // for our Suspense infra to later be able to suspend (or not) on\n    // active operations. Even though we already dedupe raw network requests,\n    // we also need to dedupe and keep track operation execution for our Suspense\n    // infra, and we also want to avoid processing responses more than once, for\n    // the cases where `loadQuery` might be called multiple times after the query ast\n    // is available.\n    // - If a duplicate active operation is found, it will return an\n    // Observable that replays the events of the already active operation.\n    // - If no duplicate active operation is found, it will call the fetchFn\n    // to execute the operation, and return an Observable that will provide\n    // the events for executing the operation.\n\n\n    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({\n      error: function error(err) {\n        executionSubject.error(err);\n      },\n      next: function next(data) {\n        executionSubject.next(data);\n      },\n      complete: function complete() {\n        executionSubject.complete();\n      }\n    });\n\n    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;\n  };\n\n  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {\n    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);\n    retainReference = environment.retain(operation);\n\n    if (fetchPolicy === 'store-only') {\n      return;\n    } // N.B. If the fetch policy allows fulfillment from the store but the\n    // environment already has the data for that operation cached in the store,\n    // then we do nothing.\n\n\n    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';\n\n    if (shouldFetch) {\n      executeDeduped(operation, function () {\n        // N.B. Since we have the operation synchronously available here,\n        // we can immediately fetch and execute the operation.\n        var networkObservable = makeNetworkRequest(concreteRequest.params);\n        var executeObservable = executeWithNetworkSource(operation, networkObservable);\n        return executeObservable;\n      });\n    }\n  };\n\n  var params;\n  var cancelOnLoadCallback;\n  var queryId;\n\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    var preloadableConcreteRequest = preloadableRequest;\n    params = preloadableConcreteRequest.params;\n    var _params = params;\n    queryId = _params.id;\n    !(queryId !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;\n\n    var _module = PreloadableQueryRegistry.get(queryId);\n\n    if (_module != null) {\n      checkAvailabilityAndExecute(_module);\n    } else {\n      // If the module isn't synchronously available, we launch the\n      // network request immediately if the fetchPolicy might produce\n      // a network fetch, regardless of the state of the store cache. We\n      // do this because we can't check if a query is cached without the\n      // ast, and we know that if we don't have the query ast\n      // available, then this query could've never been written to the\n      // store in the first place, so it couldn't have been cached.\n      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function (preloadedModule) {\n        cancelOnLoadCallback();\n        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);\n        retainReference = environment.retain(operation);\n\n        if (networkObservable != null) {\n          executeDeduped(operation, function () {\n            return executeWithNetworkSource(operation, networkObservable);\n          });\n        }\n      });\n\n      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;\n    }\n  } else {\n    var graphQlTaggedNode = preloadableRequest;\n    var request = getRequest(graphQlTaggedNode);\n    params = request.params;\n    queryId = params.cacheID != null ? params.cacheID : params.id;\n    checkAvailabilityAndExecute(request);\n  }\n\n  var isDisposed = false;\n  var isReleased = false;\n  var isNetworkRequestCancelled = false;\n\n  var releaseQuery = function releaseQuery() {\n    if (isReleased) {\n      return;\n    }\n\n    retainReference && retainReference.dispose();\n    isReleased = true;\n  };\n\n  var cancelNetworkRequest = function cancelNetworkRequest() {\n    if (isNetworkRequestCancelled) {\n      return;\n    }\n\n    if (didExecuteNetworkSource) {\n      unsubscribeFromExecution && unsubscribeFromExecution();\n    } else {\n      unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();\n    }\n\n    cancelOnLoadCallback && cancelOnLoadCallback();\n    isNetworkRequestCancelled = true;\n  };\n\n  return {\n    kind: 'PreloadedQuery',\n    environment: environment,\n    environmentProviderOptions: environmentProviderOptions,\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n\n      releaseQuery();\n      cancelNetworkRequest();\n      isDisposed = true;\n    },\n    releaseQuery: releaseQuery,\n    cancelNetworkRequest: cancelNetworkRequest,\n    fetchKey: fetchKey,\n    id: queryId,\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed || isReleased;\n    },\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get networkError() {\n      return networkError;\n    },\n\n    name: params.name,\n    networkCacheConfig: networkCacheConfig,\n    fetchPolicy: fetchPolicy,\n    source: didMakeNetworkRequest ? returnedObservable : undefined,\n    variables: variables\n  };\n}\n\nmodule.exports = {\n  loadQuery: loadQuery,\n  useTrackLoadQueryInRender: useTrackLoadQueryInRender\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}