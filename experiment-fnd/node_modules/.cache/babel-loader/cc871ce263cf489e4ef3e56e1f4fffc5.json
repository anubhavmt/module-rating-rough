{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _global$ErrorUtils$ap, _global$ErrorUtils;\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayRecordSourceSelectorProxy = require('../mutations/RelayRecordSourceSelectorProxy');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : undefined;\n\nvar applyWithGuard = (_global$ErrorUtils$ap = _global === null || _global === void 0 ? void 0 : (_global$ErrorUtils = _global.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function (callback, context, args, onError, name) {\n  return callback.apply(context, args);\n};\n/**\n * Coordinates the concurrent modification of a `Store` due to optimistic and\n * non-revertable client updates and server payloads:\n * - Applies optimistic updates.\n * - Reverts optimistic updates, rebasing any subsequent updates.\n * - Commits client updates (typically for client schema extensions).\n * - Commits server updates:\n *   - Normalizes query/mutation/subscription responses.\n *   - Executes handlers for \"handle\" fields.\n *   - Reverts and reapplies pending optimistic updates.\n */\n\nvar RelayPublishQueue = /*#__PURE__*/function () {\n  // True if the next `run()` should apply the backup and rerun all optimistic\n  // updates performing a rebase.\n  // Payloads to apply or Sources to publish to the store with the next `run()`.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // Optimistic updaters to add with the next `run()`.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // Optimistic updaters that are already added and might be rerun in order to\n  // rebase them.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // For _pendingOptimisticUpdates, _appliedOptimisticUpdates, and _pendingData,\n  // we want to parametrize by \"any\" since the type is effectively\n  // \"the union of all T's that PublishQueue's methods were called with\".\n  // Garbage collection hold, should rerun gc on dispose\n  function RelayPublishQueue(store, handlerProvider, getDataID) {\n    this._hasStoreSnapshot = false;\n    this._handlerProvider = handlerProvider || null;\n    this._pendingBackupRebase = false;\n    this._pendingData = new Set();\n    this._pendingOptimisticUpdates = new Set();\n    this._store = store;\n    this._appliedOptimisticUpdates = new Set();\n    this._gcHold = null;\n    this._getDataID = getDataID;\n  }\n  /**\n   * Schedule applying an optimistic updates on the next `run()`.\n   */\n\n\n  var _proto = RelayPublishQueue.prototype;\n\n  _proto.applyUpdate = function applyUpdate(updater) {\n    !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : invariant(false) : void 0;\n\n    this._pendingOptimisticUpdates.add(updater);\n  }\n  /**\n   * Schedule reverting an optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertUpdate = function revertUpdate(updater) {\n    if (this._pendingOptimisticUpdates.has(updater)) {\n      // Reverted before it was applied\n      this._pendingOptimisticUpdates[\"delete\"](updater);\n    } else if (this._appliedOptimisticUpdates.has(updater)) {\n      this._pendingBackupRebase = true;\n\n      this._appliedOptimisticUpdates[\"delete\"](updater);\n    }\n  }\n  /**\n   * Schedule a revert of all optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertAll = function revertAll() {\n    this._pendingBackupRebase = true;\n\n    this._pendingOptimisticUpdates.clear();\n\n    this._appliedOptimisticUpdates.clear();\n  }\n  /**\n   * Schedule applying a payload to the store on the next `run()`.\n   */\n  ;\n\n  _proto.commitPayload = function commitPayload(operation, payload, updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'payload',\n      operation: operation,\n      payload: payload,\n      updater: updater\n    });\n  }\n  /**\n   * Schedule an updater to mutate the store on the next `run()` typically to\n   * update client schema fields.\n   */\n  ;\n\n  _proto.commitUpdate = function commitUpdate(updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'updater',\n      updater: updater\n    });\n  }\n  /**\n   * Schedule a publish to the store from the provided source on the next\n   * `run()`. As an example, to update the store with substituted fields that\n   * are missing in the store.\n   */\n  ;\n\n  _proto.commitSource = function commitSource(source) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'source',\n      source: source\n    });\n  }\n  /**\n   * Execute all queued up operations from the other public methods.\n   */\n  ;\n\n  _proto.run = function run(sourceOperation) {\n    var runWillClearGcHold = // $FlowFixMe[incompatible-type]\n    this._appliedOptimisticUpdates === 0 && !!this._gcHold;\n    var runIsANoop = // this._pendingBackupRebase is true if an applied optimistic\n    // update has potentially been reverted or if this._pendingData is not empty.\n    !this._pendingBackupRebase && this._pendingOptimisticUpdates.size === 0 && !runWillClearGcHold;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(!runIsANoop, 'RelayPublishQueue.run was called, but the call would have been a noop.') : void 0;\n      process.env.NODE_ENV !== \"production\" ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + \"make sure new store updates aren't being executed within an \" + 'updater function for a different update.') : void 0;\n      this._isRunning = true;\n    }\n\n    if (runIsANoop) {\n      if (process.env.NODE_ENV !== \"production\") {\n        this._isRunning = false;\n      }\n\n      return [];\n    }\n\n    if (this._pendingBackupRebase) {\n      if (this._hasStoreSnapshot) {\n        this._store.restore();\n\n        this._hasStoreSnapshot = false;\n      }\n    }\n\n    var invalidatedStore = this._commitData();\n\n    if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      if (!this._hasStoreSnapshot) {\n        this._store.snapshot();\n\n        this._hasStoreSnapshot = true;\n      }\n\n      this._applyUpdates();\n    }\n\n    this._pendingBackupRebase = false;\n\n    if (this._appliedOptimisticUpdates.size > 0) {\n      if (!this._gcHold) {\n        this._gcHold = this._store.holdGC();\n      }\n    } else {\n      if (this._gcHold) {\n        this._gcHold.dispose();\n\n        this._gcHold = null;\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._isRunning = false;\n    }\n\n    return this._store.notify(sourceOperation, invalidatedStore);\n  }\n  /**\n   * _publishSourceFromPayload will return a boolean indicating if the\n   * publish caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {\n    var _this = this;\n\n    var payload = pendingPayload.payload,\n        operation = pendingPayload.operation,\n        updater = pendingPayload.updater;\n    var source = payload.source,\n        fieldPayloads = payload.fieldPayloads;\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n\n    if (fieldPayloads && fieldPayloads.length) {\n      fieldPayloads.forEach(function (fieldPayload) {\n        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);\n\n        !handler ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : invariant(false) : void 0;\n        handler.update(recordSourceProxy, fieldPayload);\n      });\n    }\n\n    if (updater) {\n      var selector = operation.fragment;\n      !(selector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : invariant(false) : void 0;\n      var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector);\n      var selectorData = lookupSelector(source, selector);\n      updater(recordSourceSelectorProxy, selectorData);\n    }\n\n    var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n    this._store.publish(source, idsMarkedForInvalidation);\n\n    return recordSourceProxy.isStoreMarkedForInvalidation();\n  }\n  /**\n   * _commitData will return a boolean indicating if any of\n   * the pending commits caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._commitData = function _commitData() {\n    var _this2 = this;\n\n    if (!this._pendingData.size) {\n      return false;\n    }\n\n    var invalidatedStore = false;\n\n    this._pendingData.forEach(function (data) {\n      if (data.kind === 'payload') {\n        var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);\n\n        invalidatedStore = invalidatedStore || payloadInvalidatedStore;\n      } else if (data.kind === 'source') {\n        var source = data.source;\n\n        _this2._store.publish(source);\n      } else {\n        var updater = data.updater;\n        var sink = RelayRecordSource.create();\n        var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);\n        var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID);\n        applyWithGuard(updater, null, [recordSourceProxy], null, 'RelayPublishQueue:commitData');\n        invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();\n        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n        _this2._store.publish(sink, idsMarkedForInvalidation);\n      }\n    });\n\n    this._pendingData.clear();\n\n    return invalidatedStore;\n  }\n  /**\n   * Note that unlike _commitData, _applyUpdates will NOT return a boolean\n   * indicating if the store was globally invalidated, since invalidating the\n   * store during an optimistic update is a no-op.\n   */\n  ;\n\n  _proto._applyUpdates = function _applyUpdates() {\n    var _this3 = this;\n\n    var sink = RelayRecordSource.create();\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider); // $FlowFixMe[unclear-type] see explanation above.\n\n    var processUpdate = function processUpdate(optimisticUpdate) {\n      if (optimisticUpdate.storeUpdater) {\n        var storeUpdater = optimisticUpdate.storeUpdater;\n        applyWithGuard(storeUpdater, null, [recordSourceProxy], null, 'RelayPublishQueue:applyUpdates');\n      } else {\n        var operation = optimisticUpdate.operation,\n            payload = optimisticUpdate.payload,\n            updater = optimisticUpdate.updater;\n        var source = payload.source,\n            fieldPayloads = payload.fieldPayloads;\n\n        if (source) {\n          recordSourceProxy.publishSource(source, fieldPayloads);\n        }\n\n        if (updater) {\n          var selectorData;\n\n          if (source) {\n            selectorData = lookupSelector(source, operation.fragment);\n          }\n\n          var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment);\n          applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, 'RelayPublishQueue:applyUpdates');\n        }\n      }\n    }; // rerun all updaters in case we are running a rebase\n\n\n    if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      this._appliedOptimisticUpdates.forEach(processUpdate);\n    } // apply any new updaters\n\n\n    if (this._pendingOptimisticUpdates.size) {\n      this._pendingOptimisticUpdates.forEach(function (optimisticUpdate) {\n        processUpdate(optimisticUpdate);\n\n        _this3._appliedOptimisticUpdates.add(optimisticUpdate);\n      });\n\n      this._pendingOptimisticUpdates.clear();\n    }\n\n    this._store.publish(sink);\n  };\n\n  return RelayPublishQueue;\n}();\n\nfunction lookupSelector(source, selector) {\n  var selectorData = RelayReader.read(source, selector).data;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var deepFreeze = require('../util/deepFreeze');\n\n    if (selectorData) {\n      deepFreeze(selectorData);\n    }\n  }\n\n  return selectorData;\n}\n\nmodule.exports = RelayPublishQueue;","map":{"version":3,"names":["_global$ErrorUtils$ap","_global$ErrorUtils","RelayRecordSourceMutator","require","RelayRecordSourceProxy","RelayRecordSourceSelectorProxy","RelayReader","RelayRecordSource","invariant","warning","_global","global","window","undefined","applyWithGuard","ErrorUtils","callback","context","args","onError","name","apply","RelayPublishQueue","store","handlerProvider","getDataID","_hasStoreSnapshot","_handlerProvider","_pendingBackupRebase","_pendingData","Set","_pendingOptimisticUpdates","_store","_appliedOptimisticUpdates","_gcHold","_getDataID","_proto","prototype","applyUpdate","updater","has","process","env","NODE_ENV","add","revertUpdate","revertAll","clear","commitPayload","operation","payload","kind","commitUpdate","commitSource","source","run","sourceOperation","runWillClearGcHold","runIsANoop","size","_isRunning","restore","invalidatedStore","_commitData","snapshot","_applyUpdates","holdGC","dispose","notify","_publishSourceFromPayload","pendingPayload","_this","fieldPayloads","mutator","getSource","recordSourceProxy","length","forEach","fieldPayload","handler","handle","update","selector","fragment","recordSourceSelectorProxy","selectorData","lookupSelector","idsMarkedForInvalidation","getIDsMarkedForInvalidation","publish","isStoreMarkedForInvalidation","_this2","data","payloadInvalidatedStore","sink","create","_this3","processUpdate","optimisticUpdate","storeUpdater","publishSource","read","deepFreeze","module","exports"],"sources":["/Users/anubhavgupta/Documents/react_learning/experiment_schema_ratings/rating-frontent-with-gql/module-rating-rough/experiment-fnd/node_modules/relay-runtime/lib/store/RelayPublishQueue.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _global$ErrorUtils$ap, _global$ErrorUtils;\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayRecordSourceSelectorProxy = require('../mutations/RelayRecordSourceSelectorProxy');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : undefined;\n\nvar applyWithGuard = (_global$ErrorUtils$ap = _global === null || _global === void 0 ? void 0 : (_global$ErrorUtils = _global.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function (callback, context, args, onError, name) {\n  return callback.apply(context, args);\n};\n/**\n * Coordinates the concurrent modification of a `Store` due to optimistic and\n * non-revertable client updates and server payloads:\n * - Applies optimistic updates.\n * - Reverts optimistic updates, rebasing any subsequent updates.\n * - Commits client updates (typically for client schema extensions).\n * - Commits server updates:\n *   - Normalizes query/mutation/subscription responses.\n *   - Executes handlers for \"handle\" fields.\n *   - Reverts and reapplies pending optimistic updates.\n */\n\nvar RelayPublishQueue = /*#__PURE__*/function () {\n  // True if the next `run()` should apply the backup and rerun all optimistic\n  // updates performing a rebase.\n  // Payloads to apply or Sources to publish to the store with the next `run()`.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // Optimistic updaters to add with the next `run()`.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // Optimistic updaters that are already added and might be rerun in order to\n  // rebase them.\n  // $FlowFixMe[unclear-type] See explanation below.\n  // For _pendingOptimisticUpdates, _appliedOptimisticUpdates, and _pendingData,\n  // we want to parametrize by \"any\" since the type is effectively\n  // \"the union of all T's that PublishQueue's methods were called with\".\n  // Garbage collection hold, should rerun gc on dispose\n  function RelayPublishQueue(store, handlerProvider, getDataID) {\n    this._hasStoreSnapshot = false;\n    this._handlerProvider = handlerProvider || null;\n    this._pendingBackupRebase = false;\n    this._pendingData = new Set();\n    this._pendingOptimisticUpdates = new Set();\n    this._store = store;\n    this._appliedOptimisticUpdates = new Set();\n    this._gcHold = null;\n    this._getDataID = getDataID;\n  }\n  /**\n   * Schedule applying an optimistic updates on the next `run()`.\n   */\n\n\n  var _proto = RelayPublishQueue.prototype;\n\n  _proto.applyUpdate = function applyUpdate(updater) {\n    !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : invariant(false) : void 0;\n\n    this._pendingOptimisticUpdates.add(updater);\n  }\n  /**\n   * Schedule reverting an optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertUpdate = function revertUpdate(updater) {\n    if (this._pendingOptimisticUpdates.has(updater)) {\n      // Reverted before it was applied\n      this._pendingOptimisticUpdates[\"delete\"](updater);\n    } else if (this._appliedOptimisticUpdates.has(updater)) {\n      this._pendingBackupRebase = true;\n\n      this._appliedOptimisticUpdates[\"delete\"](updater);\n    }\n  }\n  /**\n   * Schedule a revert of all optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertAll = function revertAll() {\n    this._pendingBackupRebase = true;\n\n    this._pendingOptimisticUpdates.clear();\n\n    this._appliedOptimisticUpdates.clear();\n  }\n  /**\n   * Schedule applying a payload to the store on the next `run()`.\n   */\n  ;\n\n  _proto.commitPayload = function commitPayload(operation, payload, updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'payload',\n      operation: operation,\n      payload: payload,\n      updater: updater\n    });\n  }\n  /**\n   * Schedule an updater to mutate the store on the next `run()` typically to\n   * update client schema fields.\n   */\n  ;\n\n  _proto.commitUpdate = function commitUpdate(updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'updater',\n      updater: updater\n    });\n  }\n  /**\n   * Schedule a publish to the store from the provided source on the next\n   * `run()`. As an example, to update the store with substituted fields that\n   * are missing in the store.\n   */\n  ;\n\n  _proto.commitSource = function commitSource(source) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'source',\n      source: source\n    });\n  }\n  /**\n   * Execute all queued up operations from the other public methods.\n   */\n  ;\n\n  _proto.run = function run(sourceOperation) {\n    var runWillClearGcHold = // $FlowFixMe[incompatible-type]\n    this._appliedOptimisticUpdates === 0 && !!this._gcHold;\n    var runIsANoop = // this._pendingBackupRebase is true if an applied optimistic\n    // update has potentially been reverted or if this._pendingData is not empty.\n    !this._pendingBackupRebase && this._pendingOptimisticUpdates.size === 0 && !runWillClearGcHold;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(!runIsANoop, 'RelayPublishQueue.run was called, but the call would have been a noop.') : void 0;\n      process.env.NODE_ENV !== \"production\" ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + \"make sure new store updates aren't being executed within an \" + 'updater function for a different update.') : void 0;\n      this._isRunning = true;\n    }\n\n    if (runIsANoop) {\n      if (process.env.NODE_ENV !== \"production\") {\n        this._isRunning = false;\n      }\n\n      return [];\n    }\n\n    if (this._pendingBackupRebase) {\n      if (this._hasStoreSnapshot) {\n        this._store.restore();\n\n        this._hasStoreSnapshot = false;\n      }\n    }\n\n    var invalidatedStore = this._commitData();\n\n    if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      if (!this._hasStoreSnapshot) {\n        this._store.snapshot();\n\n        this._hasStoreSnapshot = true;\n      }\n\n      this._applyUpdates();\n    }\n\n    this._pendingBackupRebase = false;\n\n    if (this._appliedOptimisticUpdates.size > 0) {\n      if (!this._gcHold) {\n        this._gcHold = this._store.holdGC();\n      }\n    } else {\n      if (this._gcHold) {\n        this._gcHold.dispose();\n\n        this._gcHold = null;\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._isRunning = false;\n    }\n\n    return this._store.notify(sourceOperation, invalidatedStore);\n  }\n  /**\n   * _publishSourceFromPayload will return a boolean indicating if the\n   * publish caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {\n    var _this = this;\n\n    var payload = pendingPayload.payload,\n        operation = pendingPayload.operation,\n        updater = pendingPayload.updater;\n    var source = payload.source,\n        fieldPayloads = payload.fieldPayloads;\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n\n    if (fieldPayloads && fieldPayloads.length) {\n      fieldPayloads.forEach(function (fieldPayload) {\n        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);\n\n        !handler ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : invariant(false) : void 0;\n        handler.update(recordSourceProxy, fieldPayload);\n      });\n    }\n\n    if (updater) {\n      var selector = operation.fragment;\n      !(selector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : invariant(false) : void 0;\n      var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector);\n      var selectorData = lookupSelector(source, selector);\n      updater(recordSourceSelectorProxy, selectorData);\n    }\n\n    var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n    this._store.publish(source, idsMarkedForInvalidation);\n\n    return recordSourceProxy.isStoreMarkedForInvalidation();\n  }\n  /**\n   * _commitData will return a boolean indicating if any of\n   * the pending commits caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._commitData = function _commitData() {\n    var _this2 = this;\n\n    if (!this._pendingData.size) {\n      return false;\n    }\n\n    var invalidatedStore = false;\n\n    this._pendingData.forEach(function (data) {\n      if (data.kind === 'payload') {\n        var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);\n\n        invalidatedStore = invalidatedStore || payloadInvalidatedStore;\n      } else if (data.kind === 'source') {\n        var source = data.source;\n\n        _this2._store.publish(source);\n      } else {\n        var updater = data.updater;\n        var sink = RelayRecordSource.create();\n        var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);\n        var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID);\n        applyWithGuard(updater, null, [recordSourceProxy], null, 'RelayPublishQueue:commitData');\n        invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();\n        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n        _this2._store.publish(sink, idsMarkedForInvalidation);\n      }\n    });\n\n    this._pendingData.clear();\n\n    return invalidatedStore;\n  }\n  /**\n   * Note that unlike _commitData, _applyUpdates will NOT return a boolean\n   * indicating if the store was globally invalidated, since invalidating the\n   * store during an optimistic update is a no-op.\n   */\n  ;\n\n  _proto._applyUpdates = function _applyUpdates() {\n    var _this3 = this;\n\n    var sink = RelayRecordSource.create();\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider); // $FlowFixMe[unclear-type] see explanation above.\n\n    var processUpdate = function processUpdate(optimisticUpdate) {\n      if (optimisticUpdate.storeUpdater) {\n        var storeUpdater = optimisticUpdate.storeUpdater;\n        applyWithGuard(storeUpdater, null, [recordSourceProxy], null, 'RelayPublishQueue:applyUpdates');\n      } else {\n        var operation = optimisticUpdate.operation,\n            payload = optimisticUpdate.payload,\n            updater = optimisticUpdate.updater;\n        var source = payload.source,\n            fieldPayloads = payload.fieldPayloads;\n\n        if (source) {\n          recordSourceProxy.publishSource(source, fieldPayloads);\n        }\n\n        if (updater) {\n          var selectorData;\n\n          if (source) {\n            selectorData = lookupSelector(source, operation.fragment);\n          }\n\n          var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment);\n          applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, 'RelayPublishQueue:applyUpdates');\n        }\n      }\n    }; // rerun all updaters in case we are running a rebase\n\n\n    if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      this._appliedOptimisticUpdates.forEach(processUpdate);\n    } // apply any new updaters\n\n\n    if (this._pendingOptimisticUpdates.size) {\n      this._pendingOptimisticUpdates.forEach(function (optimisticUpdate) {\n        processUpdate(optimisticUpdate);\n\n        _this3._appliedOptimisticUpdates.add(optimisticUpdate);\n      });\n\n      this._pendingOptimisticUpdates.clear();\n    }\n\n    this._store.publish(sink);\n  };\n\n  return RelayPublishQueue;\n}();\n\nfunction lookupSelector(source, selector) {\n  var selectorData = RelayReader.read(source, selector).data;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var deepFreeze = require('../util/deepFreeze');\n\n    if (selectorData) {\n      deepFreeze(selectorData);\n    }\n  }\n\n  return selectorData;\n}\n\nmodule.exports = RelayPublishQueue;"],"mappings":"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"},"metadata":{},"sourceType":"script"}